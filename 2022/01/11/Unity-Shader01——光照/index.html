<!DOCTYPE html><html lang="ch"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Karmotrine"><meta name="copyright" content="Karmotrine"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>Unity Shader01——光照 | Utopia</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", () => {
  Yun.utils.renderKatex();
});</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"karmotrine.fun","root":"/","title":["し","い","な","の","博","客"],"version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Utopia" type="application/atom+xml"><meta name="description" content="前言这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！（虽然溜一遍下来法线好像也能看 Shader基础顶点着色器和片元着色器顶点着色器顶点着色器是流水线的第一个阶段。它负责坐标变换以及逐顶点光照。比如把顶点坐标从模型空间转换到齐次裁剪空间，逐顶点光照在后面会说。 片元着色器片元着色器又称为像素着色器，它的输入是上一个阶段对定点信息插值得到的结果，输出是一个或者多个颜色值。在">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Shader01——光照">
<meta property="og:url" content="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/index.html">
<meta property="og:site_name" content="Utopia">
<meta property="og:description" content="前言这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！（虽然溜一遍下来法线好像也能看 Shader基础顶点着色器和片元着色器顶点着色器顶点着色器是流水线的第一个阶段。它负责坐标变换以及逐顶点光照。比如把顶点坐标从模型空间转换到齐次裁剪空间，逐顶点光照在后面会说。 片元着色器片元着色器又称为像素着色器，它的输入是上一个阶段对定点信息插值得到的结果，输出是一个或者多个颜色值。在">
<meta property="og:locale">
<meta property="og:image" content="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/%E9%80%90%E9%A1%B6%E7%82%B9.png">
<meta property="og:image" content="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/%E9%80%90%E5%83%8F%E7%B4%A0.png">
<meta property="article:published_time" content="2022-01-11T06:20:49.000Z">
<meta property="article:modified_time" content="2022-01-15T07:03:23.007Z">
<meta property="article:author" content="Karmotrine">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/%E5%AF%B9%E6%AF%94.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Karmotrine"><img width="96" loading="lazy" src="https://portrait.gitee.com/uploads/avatars/user/2943/8831424_karmotrine_1616074181.png!avatar100" alt="Karmotrine"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">Karmotrine</a></div><span class="site-name">Utopia</span><sub class="site-subtitle">Kyrie eleison.</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">9</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=657493712&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/karm0tr1ne" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:657493712@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/191503773/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1376395329" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/karmotrine-32" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/85367843" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shader%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Shader基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">顶点着色器和片元着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">片元着色器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">Shader的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">变量声明形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">标准光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%85%89-ambient"><span class="toc-number">3.1.</span> <span class="toc-text">环境光(ambient)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8F%91%E5%85%89-emissive"><span class="toc-number">3.2.</span> <span class="toc-text">自发光(emissive)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84-diffuse"><span class="toc-number">3.3.</span> <span class="toc-text">漫反射(diffuse)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84-specular"><span class="toc-number">3.4.</span> <span class="toc-text">高光反射(specular)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Phong%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">Phong模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Blinn%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">Blinn模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%83%8F%E7%B4%A0%E8%BF%98%E6%98%AF%E9%80%90%E9%A1%B6%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">逐像素还是逐顶点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">漫反射光照模型实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E9%A1%B6%E7%82%B9%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97"><span class="toc-number">4.1.</span> <span class="toc-text">逐顶点光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97"><span class="toc-number">4.2.</span> <span class="toc-text">逐像素光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%85%B0%E4%BC%AF%E7%89%B9%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">半兰伯特模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.</span> <span class="toc-text">高光反射光照模型实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E9%A1%B6%E7%82%B9%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97-1"><span class="toc-number">5.1.</span> <span class="toc-text">逐顶点光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97-1"><span class="toc-number">5.2.</span> <span class="toc-text">逐像素光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blinn-Phong%E6%A8%A1%E5%9E%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">5.3.</span> <span class="toc-text">Blinn-Phong模型计算</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Karmotrine"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Utopia"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Unity Shader01——光照</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-01-11 14:20:49" itemprop="dateCreated datePublished" datetime="2022-01-11T14:20:49+08:00">2022-01-11</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-01-15 15:03:23" itemprop="dateModified" datetime="2022-01-15T15:03:23+08:00">2022-01-15</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">3.4k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">15m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Shader/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Shader</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">笔记</span></a><a class="tag-item" href="/tags/Shader/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Shader</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/6c9385ec68c559cae4e1d7a3e3b483c0?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">Karmotrine.</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27876224&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！<del>（虽然溜一遍下来法线好像也能看</del></p>
<h2 id="Shader基础"><a href="#Shader基础" class="headerlink" title="Shader基础"></a>Shader基础</h2><h3 id="顶点着色器和片元着色器"><a href="#顶点着色器和片元着色器" class="headerlink" title="顶点着色器和片元着色器"></a>顶点着色器和片元着色器</h3><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>顶点着色器是流水线的第一个阶段。它负责坐标变换以及逐顶点光照。比如把顶点坐标从模型空间转换到齐次裁剪空间，逐顶点光照在后面会说。</p>
<h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><p>片元着色器又称为像素着色器，它的输入是上一个阶段对定点信息插值得到的结果，输出是一个或者多个颜色值。在这个阶段可以完成很多重要渲染技术（纹理采样）。但是它只能影响单个片元，无法将任何结果发给其他人。</p>
<h3 id="Shader的结构"><a href="#Shader的结构" class="headerlink" title="Shader的结构"></a>Shader的结构</h3><pre class="language-ShaderLab" data-language="ShaderLab"><code class="language-ShaderLab">Shader&quot;MyShaderName&quot; &#x2F;&#x2F;Shader的名字，里面添加&#x2F;可以创建文件夹
&#123;
Properties&#123;
	&#x2F;&#x2F;属性，声明一些着色需要的变量
	_Color(&quot;Color Tint&quot;,Color)&#x3D;(1,1,1,1)
	&#x2F;&#x2F;代码内叫啥(&quot;窗口里叫啥&quot;,啥类型)&#x3D;赋值
&#125;
SubShader&#123;
&#x2F;&#x2F;针对显卡A的SubShader
Pass&#123;
&#x2F;&#x2F;设置渲染状态和标签，此时声明Properties的变量
Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;

CGPROGRAM &#x2F;&#x2F;开始CG代码的片段

&#x2F;&#x2F;该代码片段的编译指令：
#pragma vertex vert &#x2F;&#x2F;vert函数为顶点着色方式
#pragma fragment frag &#x2F;&#x2F;frag函数为片元着色方式

#include &quot;Lighting.cginc&quot; &#x2F;&#x2F;声明引用的头文件

struct a2v&#123;
	&#x2F;&#x2F;可以在这里声明结构体
&#125;;

struct v2f&#123;

&#125;;

v2f vert(a2v v)&#123;
&#x2F;&#x2F;进行顶点着色器的相关操作
&#125;

fixed4 frag(v2f i):SV_Target&#123;
&#x2F;&#x2F;进行片元着色器的相关操作
&#125;

ENDCG &#x2F;&#x2F;结束CG代码的片段
&#125;
&#x2F;&#x2F;其它需要的Pass
&#125;
FallBack &quot;Diffuse&quot;&#x2F;&#x2F;如果上面SubShader全寄了，就回调双引号内的Unity Shader
&#125;</code></pre>

<h3 id="变量声明形式"><a href="#变量声明形式" class="headerlink" title="变量声明形式"></a>变量声明形式</h3><p>fixed4 :什么精度的数字+多少个连一起</p>
<p>精度： fixed&lt;half&lt;float</p>
<h2 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h2><p>在标准光照模型中，把进入摄像机的模型分成四部分，每个部分分别计算贡献度。四个部分分别为<strong>自发光、高光反射、漫反射、环境光</strong>。</p>
<h3 id="环境光-ambient"><a href="#环境光-ambient" class="headerlink" title="环境光(ambient)"></a>环境光(ambient)</h3><p>用来模拟间接光照。简介光照指在多个物体反射后进入摄像机的光线。环境光为一个全局变量，计算等式为：</p>
<p>$$ c_{ambient}=g_{ambient} $$</p>
<p>在Shader中，我们通过Unity内置变量UNITY_LIGHTMODEL_AMBIENT直接获得环境光颜色和强度信息。</p>
<h3 id="自发光-emissive"><a href="#自发光-emissive" class="headerlink" title="自发光(emissive)"></a>自发光(emissive)</h3><p>直接从光源进入摄像机的光线，计算等式为：</p>
<p>$$ c_{emissive}=m_{emissive} $$</p>
<p>由于大部分物体没有自发光特性，所以不存在Unity变量。对于存在自发光特性的物体，我们要先把材质的自发光颜色添加到输出颜色上再输出就行了。</p>
<h3 id="漫反射-diffuse"><a href="#漫反射-diffuse" class="headerlink" title="漫反射(diffuse)"></a>漫反射(diffuse)</h3><p>用于对那些被物体表面随机散射到各个方向的辐射度进行建模。该光照符合<strong>兰伯特定律</strong>:</p>
<p>$$ c_{diffuse}=(c_{light}*m_{diffuse})max(0,\hat{n}*\hat{l}) $$</p>
<p>其中<em><strong>c</strong></em>light是光源颜色，<em><strong>m</strong></em>diffuse是材质的漫反射颜色，<em><strong>n</strong></em>为表面法线，<em><strong>l</strong></em>为指向光源的单位矢量。当两者夹角为0时，说明光源直射，为最大值1.当两者垂直时值为0，说明光源射不到该表面。而大于90度已经是负值（没有光线反射），所以也算作是0.</p>
<h3 id="高光反射-specular"><a href="#高光反射-specular" class="headerlink" title="高光反射(specular)"></a>高光反射(specular)</h3><p>指完全沿着镜面反射方向被反射的光线，让物体看起来是有光泽的。</p>
<h4 id="Phong模型"><a href="#Phong模型" class="headerlink" title="Phong模型"></a>Phong模型</h4><p>计算高光反射所需信息有表面法线，视角方向，光源方向和反射方向等。其中反射方向可以通过前两个计算而得出：</p>
<p>$$ \hat{r}=2*(\hat(n)*\hat(l))*\hat(n)-\hat(l)$$</p>
<p>（知道法线方向和入射方向求反射方向属于是初中知识了。。。）</p>
<p>这样可以通过上述信息，使用Phong模型计算高光反射的部分：</p>
<p>$$ c_{specular}=（c_{light}*m_{specular})max(0,\hat{v}*\hat{r})^m_{gloss}$$</p>
<p>其中<strong>m</strong>gloss为光泽度，用于控制高光区域“亮点”的宽度。光泽度越大亮点越小。（毕竟下面范围是[0,1]，肯定越大是越小的）<strong>m</strong>specular是材料的高光反射，控制强度和颜色。<strong>c</strong>light是光源颜色和强度。</p>
<h4 id="Blinn模型"><a href="#Blinn模型" class="headerlink" title="Blinn模型"></a>Blinn模型</h4><p>另一种高光反射模型为Blinn模型。它与Phong模型的区别在于避免计算反射方向，而是在对光源方向和视角方向取平均后再归一化后，引入新的矢量得到的。即</p>
<p>$$\hat(h)={\frac {\hat(v)+\hat(l)}{\lvert \hat(v)+\hat(l) \rvert}}$$</p>
<p>后面就和Phong模型差不多，但是是拿n和h之间的夹角计算：</p>
<p>$$ c_{specular}=（c_{light}*m_{specular})max(0,\hat{n}*\hat{h})^m_{gloss}$$</p>
<h3 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h3><p>计算光照可以在两个着色器中计算。其中在片元着色器计算叫做<strong>逐像素光照</strong>（Phong着色），在顶点着色器中计算叫做<strong>逐顶点光照</strong>（高洛德着色）。</p>
<p>由于逐顶点光照只需在每个顶点上计算光照，然后再渲染图元内部线性插值，所以计算量小于逐像素光照。但由于存在非线性计算时，过度依赖线性插值的逐顶点光照就会产生问题。（特别是在高光反射上）</p>
<h2 id="漫反射光照模型实践"><a href="#漫反射光照模型实践" class="headerlink" title="漫反射光照模型实践"></a>漫反射光照模型实践</h2><h3 id="逐顶点光照计算"><a href="#逐顶点光照计算" class="headerlink" title="逐顶点光照计算"></a>逐顶点光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Diffuse Vertex-Level&quot;
&#123;
    Properties
    &#123;
        _Diffuse(&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)
        &#x2F;&#x2F;控制材质的漫反射颜色，可以在hierachy窗口调整
    &#125;
    SubShader
    &#123;
        pass&#123;
        &#x2F;&#x2F;定义正确的LightMode才能得到Unity的内置光照变量（如_LightColor0）
        Tags &#123; &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot; &#125;
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        
        &#x2F;&#x2F;需要使用下面的内置文件
        #include &quot;Lighting.cginc&quot;
		&#x2F;&#x2F;只有定义一个和Properties类型匹配的变量才能使用Properties内变量
        fixed4 _Diffuse;

        struct a2v&#123;
            float4 vertex:POSITION;
            float3 normal:NORMAL; &#x2F;&#x2F;告诉Unity将模型顶点法线信息存储到normal变量内
        &#125;;

        struct v2f&#123;
            float4 pos:SV_POSITION;
            fixed3 color:COLOR;
        &#125;;

        v2f vert(a2v v)&#123;
            v2f o;
            o.pos&#x3D;UnityObjectToClipPos(v.vertex);
            &#x2F;&#x2F;将顶点位置从模型空间转换到裁剪空间
            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;
            &#x2F;&#x2F;获取环境光部分
            fixed3 worldNormal&#x3D;normalize(mul(v.normal,(float3x3)unity_WorldToObject));
            &#x2F;&#x2F;我们选用世界坐标下计算，而v.normal为模型空间下的，所以需要转化为世界坐标
            &#x2F;&#x2F;转化流程为得到两空间的变换矩阵的逆矩阵unity_WorldToObject，然后和法线相乘
            &#x2F;&#x2F;由于法线为一个三维向量，所以只需要截取前三行前三列
            fixed3 worldLight&#x3D;normalize(_WorldSpaceLightPos0.xyz);
            &#x2F;&#x2F;将光源方向归一化处理
            fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLight));
            &#x2F;&#x2F;计算漫反射光照
            o.color&#x3D;ambient+diffuse;
            &#x2F;&#x2F;将漫反射光和环境光部分相加，得到最终光照结果。
            return o;
        &#125;
        fixed4 frag(v2f i):SV_TARGET&#123;
            return fixed4(i.color,1.0);
            &#x2F;&#x2F;由于所有计算在顶点着色器完成了，所以这里直接摸大鱼（
        &#125;
        ENDCG
        &#125;
    &#125;
    FallBack &quot;Diffuse&quot;
&#125;</code></pre>

<p><strong>saturate(x)</strong>:把x锁定在[0,1]范围内；</p>
<p><strong>normalize(x)</strong>:将x归一化，只留下方向；</p>
<p>**UnityObjectToClipPos(v)**：将顶点位置从模型空间转换到裁剪空间；</p>
<p><strong>mul(x,y)</strong>:计算两向量/一向量一矩阵/两矩阵相乘;</p>
<p><strong>dot(x,y)</strong>:计算x,y的点积。</p>
<h3 id="逐像素光照计算"><a href="#逐像素光照计算" class="headerlink" title="逐像素光照计算"></a>逐像素光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader&quot;Custom&#x2F;Diffuse Pixel-Level&#123;
Properties
    &#123;
        _Diffuse(&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)
    &#125;
    SubShader
    &#123;
        pass&#123;
        Tags &#123; &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot; &#125;
        CGPROGRAM
        #pragma vertex vert
        #pragma fragment frag
        
        #include &quot;Lighting.cginc&quot;

        fixed4 _Diffuse;

        struct a2v&#123;
            float4 vertex:POSITION;
            float3 normal:NORMAL;
        &#125;;

        struct v2f&#123;
            float4 pos:SV_POSITION;
            float3 worldNormal:TEXTCOORD0;
        &#125;;

        v2f vert(a2v v)&#123;
            v2f o;
            o.pos&#x3D;UnityObjectToClipPos(v.vertex);
            o.worldNormal&#x3D;mul(v.normal,(float3x3)unity_WorldToObject);
            &#x2F;&#x2F;将法线从世界空间转换为模型空间
            &#x2F;&#x2F;由于计算全给了片元着色器，所以这里摸大鱼(
            return o;
        &#125;
        fixed4 frag(v2f i):SV_TARGET&#123;
            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT;
            fixed3 worldNormal&#x3D;normalize(i.worldNormal);
            fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);
            fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));
            fixed3 color&#x3D;ambient+diffuse;
            return fixed4(color,1.0);
        &#125;
        ENDCG
        &#125;
    &#125;
    FallBack &quot;Diffuse&quot;
    &#125;</code></pre>

<p>完 全 相 同</p>
<h3 id="半兰伯特模型"><a href="#半兰伯特模型" class="headerlink" title="半兰伯特模型"></a>半兰伯特模型</h3><p>由于兰伯特光照模型没照到的地方全是0，莫得光暗变化，所以万能的v社在开发《半条命》的时候整了个半兰伯特光照模型，公式如下：</p>
<p>$$c_{diffuse}=(c_{light}*m_{diffuse})(0.5(\hat(n)*\hat(l))+0.5)$$</p>
<p>这样背光面也有明暗变化，视觉上加强了不少。</p>
<p><img src="%E5%AF%B9%E6%AF%94.png" alt="也亮堂了（" loading="lazy"></p>
<p>代码方面和逐像素计算差不多，但是修改的地方有：</p>
<pre class="language-Shader" data-language="Shader"><code class="language-Shader">fixed4 frag(v2f i):SV_TARGET&#123;
            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT;
            fixed3 worldNormal&#x3D;normalize(i.worldNormal);
            fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);
            fixed halfLambert&#x3D;saturate(dot(worldNormal,worldLightDir))*0.5+0.5;
            &#x2F;&#x2F;这里单独拎出来算了
            fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*halfLambert;
            fixed3 color&#x3D;ambient+diffuse;
            return fixed4(color,1.0);
        &#125;</code></pre>

<h2 id="高光反射光照模型实践"><a href="#高光反射光照模型实践" class="headerlink" title="高光反射光照模型实践"></a>高光反射光照模型实践</h2><p>之前提到过反射方向的计算公式：</p>
<p>$$ \hat{r}=2*(\hat(n)*\hat(l))*\hat(n)-\hat(l)$$</p>
<p>在Unity里，你只需要**reflect(i,n)**就可以（i入射方向，n法线方向）</p>
<h3 id="逐顶点光照计算-1"><a href="#逐顶点光照计算-1" class="headerlink" title="逐顶点光照计算"></a>逐顶点光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Specular Vertex-Level&quot;
&#123;
    Properties
    &#123;
        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)
        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)
        &#x2F;&#x2F;控制高光反射的颜色
        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20
        &#x2F;&#x2F;控制高光反射区域大小
    &#125;
    SubShader
    &#123;
        pass&#123;
            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;

            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;

            struct a2v
            &#123;
                float4 vertex:POSITION;
                float3 normal:NORMAL;
            &#125;;

            struct v2f
            &#123;
                float4 pos:SV_POSITION;
                float3 color:COLOR;
            &#125;;

            v2f vert(a2v v)
            &#123;
                v2f o;
                o.pos&#x3D;UnityObjectToClipPos(v.vertex);
                &#x2F;&#x2F;将顶点位置从模型空间转换到裁剪空间
                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;
                &#x2F;&#x2F;拿环境光
                fixed3 worldNormal&#x3D;normalize(mul(v.normal,(float3x3)unity_WorldToObject));
                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);
                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));
                &#x2F;&#x2F;算漫反射光照
                fixed3 reflectDir&#x3D;normalize(reflect(-worldLightDir,worldNormal));
                &#x2F;&#x2F;计算反射方向，由于reflect函数入射方向要求从光源指向交点，所以worldLightDir要取反
                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-mul(unity_ObjectToWorld,v.vertex).xyz);
                &#x2F;&#x2F;_WorldSpaceCameraPos为摄像机位置，将顶点位置先转换为世界空间，然后与摄像机相减就是视角位置
                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(reflectDir,viewDir)),_Gloss);
                &#x2F;&#x2F;最后进行Phong模型的计算，得出高光反射的贡献度
                o.color&#x3D;ambient+diffuse+specular;
                &#x2F;&#x2F;与环境光、漫反射光相加，存储到最后的颜色里
                return o;
            &#125;

            fixed4 frag(v2f i):SV_Target&#123;
            	&#x2F;&#x2F;由于在顶点着色器都算完了，所以这里摸大鱼
                return fixed4(i.color,1.0);
            &#125;
            ENDCG
            &#125;
    &#125;
    FallBack &quot;Specular&quot;
&#125;</code></pre>

<p>这时逐顶点计算高光反射的弊端就出现了：阴处都是一片片的。</p>
<p><img src="%E9%80%90%E9%A1%B6%E7%82%B9.png" alt="逐顶点" loading="lazy"></p>
<p>这是因为高光反射的计算是非线性的，而在顶点着色器里计算光照再插值是线性的。这样破坏了原来计算的非线性关系。</p>
<h3 id="逐像素光照计算-1"><a href="#逐像素光照计算-1" class="headerlink" title="逐像素光照计算"></a>逐像素光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Unity Shader Book&#x2F;Chapter 6&#x2F;Specular Pixel-Level&quot;
&#123;
    Properties
    &#123;
        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)
        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)
        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20
    &#125;
    SubShader
    &#123;
        pass&#123;
            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;

            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;

            struct a2v
            &#123;
                float4 vertex:POSITION;
                float3 normal:NORMAL;
            &#125;;

            struct v2f
            &#123;
                float4 pos:SV_POSITION;
                float3 worldNormal:TEXCOORD0;
                float3 worldPos:TEXCOORD1;
            &#125;;

            v2f vert(a2v v)
            &#123;
                v2f o;
                o.pos&#x3D;UnityObjectToClipPos(v.vertex);
                o.worldNormal&#x3D;mul(v.normal,(float3x3)unity_WorldToObject);
                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;
                return o;
            &#125;

            fixed4 frag(v2f i):SV_Target&#123;
                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;
                fixed3 worldNormal&#x3D;normalize(i.worldNormal);
                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);
                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));
                fixed3 reflectDir&#x3D;normalize(reflect(-worldLightDir,worldNormal));
                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);
                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(reflectDir,viewDir)),_Gloss);
                return fixed4(ambient+diffuse+specular,1.0);
            &#125;
            ENDCG
            &#125;
    &#125;
    FallBack &quot;Specular&quot;
&#125;</code></pre>

<p>虽然计算过程基本相同，但是得出的效果更令人满意：</p>
<p><img src="%E9%80%90%E5%83%8F%E7%B4%A0.png" alt="逐像素" loading="lazy"></p>
<h3 id="Blinn-Phong模型计算"><a href="#Blinn-Phong模型计算" class="headerlink" title="Blinn-Phong模型计算"></a>Blinn-Phong模型计算</h3><p>由于逐顶点计算高光反射的拉跨程度，所以我们只用逐像素的方法来实践</p>
<pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;BlinnPhong&quot;
&#123;
    Properties
    &#123;
        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)
        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)
        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20
    &#125;
    SubShader
    &#123;
        pass&#123;
            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;

            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;

            struct a2v
            &#123;
                float4 vertex:POSITION;
                float3 normal:NORMAL;
            &#125;;

            struct v2f
            &#123;
                float4 pos:SV_POSITION;
                float3 worldNormal:TEXCOORD0;
                float3 worldPos:TEXCOORD1;
            &#125;;

            v2f vert(a2v v)
            &#123;
                v2f o;
                o.pos&#x3D;UnityObjectToClipPos(v.vertex);
                o.worldNormal&#x3D;mul(v.normal,(float3x3)unity_WorldToObject);
                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;
                return o;
            &#125;

            fixed4 frag(v2f i):SV_Target&#123;
                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;
                fixed3 worldNormal&#x3D;normalize(i.worldNormal);
                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);
                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));
                fixed3 reflectDir&#x3D;normalize(reflect(-worldLightDir,worldNormal));
                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);
                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);
                &#x2F;&#x2F;扣扣大，计算新矢量h
                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);
                &#x2F;&#x2F;然后改成h和n点乘
                return fixed4(ambient+diffuse+specular,1.0);
            &#125;
            ENDCG
            &#125;
    &#125;
    FallBack &quot;Specular&quot;
&#125;</code></pre>

<p>使用Blinn模型的高光反射部分看起来更大、更亮一些，所以大多数情况都会采用Blinn模型。</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Karmotrine.</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/" title="Unity Shader01——光照">https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/01/11/Unity-Shader02%E2%80%94%E2%80%94%E7%BA%B9%E7%90%86/" rel="prev" title="Unity Shader02——纹理"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Unity Shader02——纹理</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/01/10/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E5%BD%95%E7%9A%84Unity%E4%B8%80%E8%BD%AE%E6%95%99%E7%A8%8B/" rel="next" title="胡言乱语录的Unity一轮教程"><span class="post-nav-text">胡言乱语录的Unity一轮教程</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Karmotrine</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.0.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-01-07T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="7226373375" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listfolded data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>