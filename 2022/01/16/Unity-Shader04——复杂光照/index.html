<!DOCTYPE html><html lang="ch"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Karmotrine"><meta name="copyright" content="Karmotrine"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>Unity Shader04——复杂光照 | Utopia</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", () => {
  Yun.utils.renderKatex();
});</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"karmotrine.fun","root":"/","title":["し","い","な","の","博","客"],"version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Utopia" type="application/atom+xml"><meta name="description" content="前言这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！（虽然溜一遍下来发现好像也能看 Unity的渲染路径概念渲染路径决定光照是如何应用到Unity Shader里的。只有为每个Pass指定正确的渲染路径才能正确执行光照计算。Unity的渲染路径有三种：前向渲染路径、延迟渲染路径和顶点照明渲染路径。每个摄像机可以通过修改Camera组件内的Rendering Path决定该">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Shader04——复杂光照">
<meta property="og:url" content="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/index.html">
<meta property="og:site_name" content="Utopia">
<meta property="og:description" content="前言这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！（虽然溜一遍下来发现好像也能看 Unity的渲染路径概念渲染路径决定光照是如何应用到Unity Shader里的。只有为每个Pass指定正确的渲染路径才能正确执行光照计算。Unity的渲染路径有三种：前向渲染路径、延迟渲染路径和顶点照明渲染路径。每个摄像机可以通过修改Camera组件内的Rendering Path决定该">
<meta property="og:locale">
<meta property="og:image" content="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/%E8%A1%A8%E4%B8%80.png">
<meta property="og:image" content="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/%E8%A1%A8%E4%BA%8C.png">
<meta property="og:image" content="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/%E8%A1%A8%E4%B8%89.png">
<meta property="article:published_time" content="2022-01-16T09:07:41.000Z">
<meta property="article:modified_time" content="2022-01-16T13:48:13.022Z">
<meta property="article:author" content="Karmotrine">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/%E8%A1%A8%E4%B8%80.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Karmotrine"><img width="96" loading="lazy" src="https://portrait.gitee.com/uploads/avatars/user/2943/8831424_karmotrine_1616074181.png!avatar100" alt="Karmotrine"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">Karmotrine</a></div><span class="site-name">Utopia</span><sub class="site-subtitle">Kyrie eleison.</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">11</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=657493712&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/karm0tr1ne" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:657493712@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/191503773/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1376395329" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/karmotrine-32" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/85367843" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">2.</span> <span class="toc-text">Unity的渲染路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">2.2.</span> <span class="toc-text">前向渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%85%A7%E6%98%8E%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.</span> <span class="toc-text">顶点照明渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">2.4.</span> <span class="toc-text">延迟渲染路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.</span> <span class="toc-text">Unity的光源类型与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%8C%E5%85%89"><span class="toc-number">3.1.</span> <span class="toc-text">平行光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%85%89%E6%BA%90"><span class="toc-number">3.2.</span> <span class="toc-text">点光源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%85%89%E7%81%AF"><span class="toc-number">3.3.</span> <span class="toc-text">聚光灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.4.</span> <span class="toc-text">前向渲染路径实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%BA%BF%E8%A1%B0%E5%87%8F%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.5.</span> <span class="toc-text">光线衰减纹理采样原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E9%98%B4%E5%BD%B1%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">Unity的阴影与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.1.</span> <span class="toc-text">不透明物体的阴影实践</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Karmotrine"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Utopia"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Unity Shader04——复杂光照</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-01-16 17:07:41" itemprop="dateCreated datePublished" datetime="2022-01-16T17:07:41+08:00">2022-01-16</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">3k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">11m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Shader/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Shader</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">笔记</span></a><a class="tag-item" href="/tags/Shader/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Shader</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/6c9385ec68c559cae4e1d7a3e3b483c0?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">Karmotrine.</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1903397110&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！<del>（虽然溜一遍下来发现好像也能看</del></p>
<h2 id="Unity的渲染路径"><a href="#Unity的渲染路径" class="headerlink" title="Unity的渲染路径"></a>Unity的渲染路径</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>渲染路径</strong>决定光照是如何应用到Unity Shader里的。只有为每个Pass指定正确的渲染路径才能正确执行光照计算。Unity的渲染路径有三种：前向渲染路径、延迟渲染路径和顶点照明渲染路径。每个摄像机可以通过修改Camera组件内的Rendering Path决定该摄像机对光照的渲染路径。如果没有设置，摄像机会遵从Unity设置的渲染路径（即前向渲染路径）。</p>
<p>Pass内部通过标签（<code>Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</code>）决定使用的渲染路径。（比如“ForwardBase”、“FowardAdd”就是前向渲染路径）所有标签如下：</p>
<p><img src="%E8%A1%A8%E4%B8%80.png" alt="表一" loading="lazy"></p>
<h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h3><p>传统、常用的渲染路径。首先利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区的颜色值，然后再遍历该模型的下一个片元。当然计算结果仅仅是一个光源的影响结果，如果有多个光源则要再次重复上述步骤。因此，假设场景有N个物体，每个物体受M个光照影响，渲染整个场景就需要N*M个Pass。（然后每个Pass又要渲染该物体的所有片元）。所以如果有大量逐像素光照，需要执行的数目也会很多。</p>
<p>对此，Unity中的前向渲染路径有3种：逐顶点处理、逐像素处理、球谐函数。我们可以在Light组件的Render Mode调整处理方式：</p>
<p>1.设置成Not Important以逐顶点或球谐函数处理；</p>
<p>2.设置成Important的和场景中最亮的平行光按逐像素处理；</p>
<p>3.上述规则得到的逐像素光源数量小于Quality Settings的数量，会有更多光源以逐像素的方式渲染。</p>
<p>前向渲染又有两种Pass：<strong>Base Pass</strong>和<strong>Additional Pass</strong>。</p>
<p><strong>Base Pass</strong>：计算一个逐像素的平行光以及所有逐顶点和SH光源，可以实现光照纹理、环境光、自发光和平行光的阴影；一个Base Pass只会调用一次。</p>
<p><strong>Additional Pass</strong>：计算其它影响该物体的逐像素光源（每个光源执行一次Pass），默认情况下不支持阴影；每个逐像素光源会执行一次Additional Pass。</p>
<p>对于前向渲染来说，一个Unity Shader通常会定义一个Base Pass和一个Additional Pass。</p>
<p>前向渲染可以使用的内置光照变量为：</p>
<p><img src="%E8%A1%A8%E4%BA%8C.png" alt="表二" loading="lazy"></p>
<p>前向渲染可以使用的内置光照函数为：</p>
<p><img src="%E8%A1%A8%E4%B8%89.png" alt="表三" loading="lazy"></p>
<h3 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h3><p>以逐顶点的方式来计算光照。因为前面的前向渲染路径也可以计算这个，所以不是很有用。</p>
<h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h3><p>是一种更为古老的渲染方法。它也是两个Pass。第一个Pass不进行任何光照计算，只是计算那些片元是可见的，如果可见就把相关信息存储到G缓冲区中。在第一个Pass执行完毕后进行第二个Pass，利用G缓冲区的各个片元信息进行真正的光照计算。如果说<strong>前向渲染路径</strong>是一计算可见就进行光照计算，<strong>延迟渲染路径</strong>就是计算可见先存储到缓冲区中，最后统一进行光照计算。</p>
<p>综上可得，延迟渲染就2个Pass，与场景中包含的光源数目没有关系，可以很好的解决<strong>前向渲染路径</strong>中包含大量实时光源时性能下降的问题。而且延迟渲染路径中每个光源都可以按逐像素的方式处理。但是，它也有着缺点：</p>
<p>1.不支持真正的抗锯齿功能；</p>
<p>2.无法处理半透明物体；</p>
<p>3.显卡要支持MRT等要求。</p>
<p><strong>延迟渲染路径</strong>可访问的内置变量和函数：</p>
<p><strong>_LightColor</strong>：光源颜色（float4）</p>
<p><strong>_LightMatrix0</strong>：从世界空间到光源空间的变换矩阵（float4x4）</p>
<h2 id="Unity的光源类型与实践"><a href="#Unity的光源类型与实践" class="headerlink" title="Unity的光源类型与实践"></a>Unity的光源类型与实践</h2><p>光源属性有5个：<strong>位置</strong>、<strong>方向</strong>、<strong>颜色</strong>、<strong>强度</strong>和<strong>衰减</strong></p>
<p>光源类型有四个（面光源暂不介绍）：</p>
<h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p>作为太阳这种角色在场景中出现，可以照亮的范围没有限制（所以嗯调位置一点用没有），也没有衰减（光照强度不会随距离发生改变）</p>
<h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p>照亮空间时以光源为圆心的一个球体，光向所有方向延伸。球体的半径可以通过Range属性调整，光源颜色和强度可以在Light组件内调整。存在衰减，球心处光照强度最强，边界最弱，值为0.</p>
<h3 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h3><p>照亮空间时以光源为圆锥体最顶端（即尖端），向下投射出的圆锥体，光向特定方向延伸。锥形区域半径由Range属性决定，张开角度由Spot Angle属性决定。存在衰减，锥形顶点处光照强度最强，边界处强度为0.</p>
<h3 id="前向渲染路径实践"><a href="#前向渲染路径实践" class="headerlink" title="前向渲染路径实践"></a>前向渲染路径实践</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;ForwardRendering&quot;
&#123;
    Properties
    &#123;
        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)
        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)
        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20
        _Atten (&quot;Atten&quot;,Range(0,256))&#x3D;1.0
    &#125;
    SubShader
    &#123;
        Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;
        &#x2F;&#x2F;Base Pass
        Pass&#123;
            Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;
            &#x2F;&#x2F;设置Base Pass
            CGPROGRAM

            #pragma multi_compile_fwdbase
            &#x2F;&#x2F;使用该指令可以保证我们使用光照衰减等光照变量可以被正确赋值（和Tag一样一定要写）。
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;

            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;
            fixed _Atten;
            &#x2F;&#x2F;衰减值

            struct a2v
            &#123;
                float4 vertex:POSITION;
                float3 normal:NORMAL;
            &#125;;

            struct v2f
            &#123;
                float4 pos:SV_POSITION;
                float3 worldNormal:TEXCOORD0;
                float3 worldPos:TEXCOORD1;
            &#125;;

            v2f vert(a2v v)
            &#123;
                v2f o;
                o.pos&#x3D;UnityObjectToClipPos(v.vertex);
                o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal);
                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;
                return o;
            &#125;

            fixed4 frag(v2f i):SV_Target&#123;
                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;
                &#x2F;&#x2F;如上文，环境光只需计算一次，所以后面的Additional Pass就不会计算
                fixed3 worldNormal&#x3D;normalize(i.worldNormal);
                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);
                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));
                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);
                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);
                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);
                return fixed4(ambient+(diffuse+specular)*_Atten,1.0);
            &#125;
            ENDCG
            &#125;
        Pass&#123;
            Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardAdd&quot;&#125;
            &#x2F;&#x2F;Additional Pass的标签
            Blend One One
            &#x2F;&#x2F;将该Pass光照计算结果和Base Pass结果混合
            &#x2F;&#x2F;如果没有Blend命令，Additional Pass会把Base Pass直接覆盖
            CGPROGRAM
            #pragma multi_compile_fwdadd
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;Lighting.cginc&quot;
            #include &quot;AutoLight.cginc&quot;

            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;
            fixed _Atten;

            struct a2v
            &#123;
                float4 vertex:POSITION;
                float3 normal:NORMAL;
            &#125;;

            struct v2f
            &#123;
                float4 pos:SV_POSITION;
                float3 worldNormal:TEXCOORD0;
                float3 worldPos:TEXCOORD1;
            &#125;;

            v2f vert(a2v v)
            &#123;
                v2f o;
                o.pos&#x3D;UnityObjectToClipPos(v.vertex);
                o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal);
                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;
                return o;
            &#125;

            fixed4 frag(v2f i):SV_Target&#123;
                fixed3 worldNormal&#x3D;normalize(i.worldNormal);
                #ifdef USING_DIRECTIONAL_LIGHT
                &#x2F;&#x2F;如果处理的光照类型是平行光
					fixed3 worldLightDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);
					&#x2F;&#x2F;就直接是
				#else
					fixed3 worldLightDir &#x3D; normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);
					&#x2F;&#x2F;不然就要用这个位置减去世界空间下的顶点位置
				#endif
                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));
                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);
                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);
                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);
                #ifdef USING_DIRECTIONAL_LIGHT
					fixed atten &#x3D; 1.0;
				#else
					#if defined (POINT)
				        float3 lightCoord &#x3D; mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;
				        fixed atten &#x3D; tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;
				        &#x2F;&#x2F;采样原因如下
				    #elif defined (SPOT)
				        float4 lightCoord &#x3D; mul(unity_WorldToLight, float4(i.worldPos, 1));
				        fixed atten &#x3D; (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy &#x2F; lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;
				    #else
				        fixed atten &#x3D; 1.0;
				    #endif
				#endif
                return fixed4((diffuse+specular)*_Atten,1.0);
            &#125;
            ENDCG
            &#125;
    &#125;
    FallBack &quot;Specular&quot;
&#125;</code></pre>

<h3 id="光线衰减纹理采样原因"><a href="#光线衰减纹理采样原因" class="headerlink" title="光线衰减纹理采样原因"></a>光线衰减纹理采样原因</h3><p>光线衰减的计算往往涉及开根号、除法等计算量相对较大的操作。因此Unity选择了使用一张纹理作为查找表以在片元着色器中得到光源的衰减。纹理名称为**_LightTexture0**，坐标(0,0)是与光源位置重合的点，(1,1)是和光源距离最远的。</p>
<p>为了得到纹理定点的相关数值，我们要得到该点在光源空间的位置：</p>
<p><code>float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</code></p>
<p>将世界空间的顶点坐标和转换矩阵相乘得到</p>
<p><code>fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</code></p>
<p>这里将光源空间的顶点距离的平方进行采样（没有使用距离值是因为可以避免开方操作）。然后使用宏<strong>UNITY_ATTEN_CHANNEL</strong>得到衰减纹理中衰减值所在分量，以得到最终衰减值。</p>
<p>也可以使用公式自行计算光源衰减，比如（这是线性衰减）：</p>
<p><code>float distance=length(_WorldSpaceLightPos0.xyz-i.worldPosition.xyz);</code></p>
<p><code>atten=1.0/distance;</code></p>
<h2 id="Unity的阴影与实践"><a href="#Unity的阴影与实践" class="headerlink" title="Unity的阴影与实践"></a>Unity的阴影与实践</h2><p>在实时渲染中，会使用<strong>Shadow Map</strong>技术，它会吧摄像头位置放在与光源重合的位置上，这样场景中该光源的阴影区域就是摄像头看不到的地方。</p>
<p>在前向渲染路径中，如果平行光打开了阴影，Unity会计算该光源的阴影映射纹理。它本身也是一张深度图，记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）。</p>
<p>计算深度信息的方法可以通过把摄像头挂在光源的位置，然后按正常渲染流程调用Base Pass和Additional Pass进行，但是这样会浪费性能：<strong>我们只要深度信息就行了，而不需要光源的相关计算</strong>。最好的办法是额外使用一个Pass来计算，也就是<code>Tags&#123;&quot;LightMode&quot;=&quot;ShadowCaster&quot;&#125;</code>的Pass。Unity会先把摄像机挂在光源的位置，然后找到LightMode是ShadowCaster的Pass。找不到就去Fallback指定的Shader里继续找。</p>
<p><strong>传统的阴影映射纹理</strong>的实现中，我们先在正常Pass中把顶点位置变换到光源空间，然后使用xy分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值，就说明该点位于阴影中。但<strong>屏幕空间的阴影映射技术</strong>中，Unity会调用<code>Tags&#123;&quot;LightMode&quot;=&quot;ShadowCaster&quot;&#125;</code>的Pass来得到可投射阴影的光源阴影映射纹理和摄像机的深度纹理。然后根据上述得到屏幕空间的阴影图。如果摄像机的深度图中表面深度大于转换到阴影映射纹理的深度值，说明该表面虽然可见，但是在该光源的阴影中。这样阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接受来自其他物体的阴影，首先需要把表面坐标从模型空间变换到屏幕空间，然后使用该坐标对阴影图进行采样即可。</p>
<p>综上，一个物体接收其它物体的阴影和一个物体向其它物体投射阴影是两个过程：</p>
<p><strong>一个物体接受其它物体的阴影</strong>：必须在Shader里对阴影映射纹理进行采样，把采样结果和最后光照结果相乘。</p>
<p><strong>一个物体向其它物体投射阴影</strong>：把该物体加入到光源的阴影映射纹理计算中，从而让其它物体在对阴影映射纹理采样时得到该物体的相关信息。这个过程由“ShadowCaster”的Pass实现。</p>
<h3 id="不透明物体的阴影实践"><a href="#不透明物体的阴影实践" class="headerlink" title="不透明物体的阴影实践"></a>不透明物体的阴影实践</h3></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Karmotrine.</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/" title="Unity Shader04——复杂光照">https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/01/16/Unity-Shader05%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/" rel="prev" title="Unity Shader05——高级纹理"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Unity Shader05——高级纹理</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/01/13/Unity-Shader03%E2%80%94%E2%80%94%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/" rel="next" title="Unity Shader03——透明效果"><span class="post-nav-text">Unity Shader03——透明效果</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Karmotrine</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.0.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-01-07T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="7226373375" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listfolded data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>