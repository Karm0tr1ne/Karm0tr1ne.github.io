<!DOCTYPE html><html lang="ch"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Karmotrine"><meta name="copyright" content="Karmotrine"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>简析Unity有限状态机的实现方法与使用 | Utopia</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":["し","い","な","の","博","客"],"version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Utopia" type="application/atom+xml"><meta name="description" content="（冰海战记真好看，大家快点都去看） 前言​        寒假终于来力，有时间摸一摸博客了。今天就来介绍一下我一直很想写的有限状态机（FSM）。它虽然起步比较难，但是对于代码结构的优化和游戏人物的控制真的非常的舒适（起码不用声明114514个布尔值来控制角色的动作了）。如果有学弟看到我的这篇拙作也可以挑战一下使用有限状态机来做三轮捏（bushi 为什么要使用FSM一个哈人的bug在解答这个问题">
<meta property="og:type" content="article">
<meta property="og:title" content="简析Unity有限状态机的实现方法与使用">
<meta property="og:url" content="http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="Utopia">
<meta property="og:description" content="（冰海战记真好看，大家快点都去看） 前言​        寒假终于来力，有时间摸一摸博客了。今天就来介绍一下我一直很想写的有限状态机（FSM）。它虽然起步比较难，但是对于代码结构的优化和游戏人物的控制真的非常的舒适（起码不用声明114514个布尔值来控制角色的动作了）。如果有学弟看到我的这篇拙作也可以挑战一下使用有限状态机来做三轮捏（bushi 为什么要使用FSM一个哈人的bug在解答这个问题">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/animator.png">
<meta property="article:published_time" content="2022-01-09T14:58:15.000Z">
<meta property="article:modified_time" content="2022-01-09T17:30:42.372Z">
<meta property="article:author" content="Karmotrine">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/animator.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Karmotrine"><img width="96" loading="lazy" src="https://portrait.gitee.com/uploads/avatars/user/2943/8831424_karmotrine_1616074181.png!avatar100" alt="Karmotrine"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">Karmotrine</a></div><span class="site-name">Utopia</span><sub class="site-subtitle">Kyrie eleison.</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">5</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=657493712&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/karm0tr1ne" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:657493712@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/191503773/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1376395329" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/karmotrine-32" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/85367843" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8FSM"><span class="toc-number">2.</span> <span class="toc-text">为什么要使用FSM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%93%88%E4%BA%BA%E7%9A%84bug"><span class="toc-number">2.1.</span> <span class="toc-text">一个哈人的bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%89%E9%99%90%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">2.2.</span> <span class="toc-text">一个有限的状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.</span> <span class="toc-text">如何构建有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%8E%A5%E5%8F%A3IState"><span class="toc-number">3.1.</span> <span class="toc-text">状态继承的接口IState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E6%89%80%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.2.</span> <span class="toc-text">角色所有状态的枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%8A%B6%E6%80%81%E7%9A%84%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">每个相关状态的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%B4%E6%88%8F%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%99%A8%E8%84%9A%E6%9C%AC"><span class="toc-number">3.4.</span> <span class="toc-text">重头戏：控制器脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E9%83%A8%E5%88%86"><span class="toc-number">3.4.1.</span> <span class="toc-text">声明部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E9%83%A8%E5%88%86"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">1.杂七杂八部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%8A%B6%E6%80%81%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">2.状态控制相关</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Start%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">Start方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E9%83%A8%E5%88%86-1"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">1.杂七杂八部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">2.注册键值对</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E5%85%A5%E5%9C%BA%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">3.设置入场状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Update%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">Update方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">3.4.4.</span> <span class="toc-text">状态转换方法和重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8EQ-amp-A"><span class="toc-number">4.</span> <span class="toc-text">总结与Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E6%98%AF%E5%8F%AA%E8%83%BD%E7%94%A8%E5%9C%A8%E6%80%AA%E7%89%A9%E9%80%BB%E8%BE%91%E4%B8%8A%E5%90%97%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">1.有限状态机是只能用在怪物逻辑上吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E6%88%91%E8%A6%81%E5%AF%B9%E5%A4%9A%E7%A7%8D%E6%80%AA%E7%89%A9%E5%92%8C%E7%8E%A9%E5%AE%B6%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%94%A8%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">2.如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Karmotrine"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Utopia"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">简析Unity有限状态机的实现方法与使用</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-01-09 22:58:15" itemprop="dateCreated datePublished" datetime="2022-01-09T22:58:15+08:00">2022-01-09</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-01-10 01:30:42" itemprop="dateModified" datetime="2022-01-10T01:30:42+08:00">2022-01-10</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">5.5k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">22m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Unity/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Unity</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E6%95%99%E7%A8%8B/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">教程</span></a><a class="tag-item" href="/tags/Unity/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Unity</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/6c9385ec68c559cae4e1d7a3e3b483c0?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">Karmotrine.</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1382359170&auto=1&height=66"></iframe>

<p>（冰海战记真好看，大家快点都去看）</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        寒假终于来力，有时间摸一摸博客了。今天就来介绍一下我一直很想写的有限状态机（FSM）。它虽然起步比较难，但是对于代码结构的优化和游戏人物的控制真的非常的舒适（起码不用声明114514个布尔值来控制角色的动作了）。如果有学弟看到我的这篇拙作也可以挑战一下使用有限状态机来做三轮捏（bushi</p>
<h2 id="为什么要使用FSM"><a href="#为什么要使用FSM" class="headerlink" title="为什么要使用FSM"></a>为什么要使用FSM</h2><h3 id="一个哈人的bug"><a href="#一个哈人的bug" class="headerlink" title="一个哈人的bug"></a>一个哈人的bug</h3><p>在解答这个问题之前，我想问问读者一个问题：</p>
<p>​        假如你是李华，你想通过一个程序来控制游戏内一个怪物的各种状态（比如走路，静止，攻击，跳跃，冲刺等等），让这个怪物血量每减少三分之一的时候会跳在中间捶地板，在平常的时候可以抡大锤砸玩家，在被逼到死角的时候使用锤子砸地形成一个冲击波，在把玩家逼到死角的时候会自动往后跳不至于逼死玩家。。。<del>（假骑士是什么，我不知道）</del>这样应该怎么写呢？我想大多数人会在控制怪物的脚本里先洋洋洒洒声明一堆布尔值（至少以前我是这样的）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private bool isLuning; //正在抡大锤</span><br><span class="line">private bool isZaDaChui; //正在砸地形成冲击波</span><br><span class="line">private bool isHouTiao; //正在后跳</span><br><span class="line">private bool isChui; //正在捶地板</span><br></pre></td></tr></table></figure>

<p>​        我不能说这样做不对，因为事实上这样做是可以实现功能的。但是这样做却有一个隐患，就是切换不同状态时会发生问题。举个例子，当假骑士<del>（你刚刚说了假骑士对吧，对吧？！）</del>抡锤子时正好把玩家逼入了死角，同时血量掉了三分之一时，它应该被切换成什么状态呢？这个时候三个控制状态的布尔值都是真的，那假骑士这个时候要干什么，我是想都不敢想（</p>
<p>​        当一个角色的状态有很多时，如何顺利进行不同状态之间的过渡就成了我们头疼的事情。如果是怪物状态的控制那还好，因为怪物后面都是有着固定的逻辑的。但如果是玩家状态的控制呢？要知道，玩家背后的逻辑可是敢在酒吧里点炒饭，吃程序员不吐骨头的广大游戏玩家啊。当游戏玩家在奔跑时按下飞行键，或者在怕爬梯子时按下跳跃键，产生的后果肯定是让人啼笑皆非的。</p>
<p>​        而在上述的问题中，眼尖的读者就能看出真正的问题所在：这些问题的产生都是由于两个不同状态的同时进行导致的。也就是在跳跃时又进行了飞行的功能，在走路时又进行了奔跑的功能。那这样的话，我们只要用枚举的方式把所有状态囊括在一起不就好了嘛。因为枚举只能有一个状态，恰好可以完美解决上面的状态并发问题。而这个思想，也就是我今天想要写的有限状态机（FSM）。</p>
<h3 id="一个有限的状态机"><a href="#一个有限的状态机" class="headerlink" title="一个有限的状态机"></a>一个有限的状态机</h3><p>​        FSM，又称为有限状态机。它的意思就是我们列举出一系列有限的状态（以玩家本身为例，状态就有奔跑，静止，攻击，跳跃等等），以及这个状态应该运行的代码，其中包括状态开始，状态进行和状态结束的方法（比如跳跃的时候角色要先起跳，然后一直在半空什么的）。接着，我们编写一个程序来控制状态的切换以及进入一个状态在什么阶段应该运行的相关代码。由于这个状态是枚举的，而且有关动作只有在玩家当前为这个状态时才可以执行，所以理论上可以完美解决上面的问题。</p>
<p>​        这个结构其实在Unity内部就有了实践，那就是animator组件：</p>
<p><img src="animator.png" alt="animator" loading="lazy"></p>
<p>每个动画都被框在了一个状态里，只有当控制器运行到了这个状态时才会播放里面的动画，根本不会出现两个动画并发的现象，而我们的有限状态机也会沿用这个思想，只不过每个状态里存储的不是动画，而是一串串代码。</p>
<h2 id="如何构建有限状态机"><a href="#如何构建有限状态机" class="headerlink" title="如何构建有限状态机"></a>如何构建有限状态机</h2><p>​        有限状态机的图解如下：</p>
<h3 id="状态继承的接口IState"><a href="#状态继承的接口IState" class="headerlink" title="状态继承的接口IState"></a>状态继承的接口IState</h3><p>​        正如上文所说，状态机应该拥有进入这个状态，维持这个状态，以及退出这个状态的相应动作（就像碰撞检测中OnColliderEnter,OnColliderStay,OnColliderExit这仨一样）。所以作为每个状态都应该继承的接口应该有这三个对应的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IState</span><br><span class="line">&#123;</span><br><span class="line">    void OnEnter(); //进入状态的方法</span><br><span class="line">    void OnUpdate(); //维持状态的方法</span><br><span class="line">    void OnExit(); //退出状态的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="角色所有状态的枚举"><a href="#角色所有状态的枚举" class="headerlink" title="角色所有状态的枚举"></a>角色所有状态的枚举</h3><p>上文也提到了有限状态机的枚举思想，所以我们也需要一个枚举来囊括角色的所有状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum StateType</span><br><span class="line">&#123;</span><br><span class="line">    Enter,//入场</span><br><span class="line">    Defense,//防御</span><br><span class="line">    Die,//死亡</span><br><span class="line">    Attack,//攻击</span><br><span class="line">    RecoverHP,//回血</span><br><span class="line">    Dodge,//闪避</span><br><span class="line">    Idle //站着不动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这些状态都是你自己定的，上面这个例子的状态仅作为参考。</p>
<h3 id="每个相关状态的类"><a href="#每个相关状态的类" class="headerlink" title="每个相关状态的类"></a>每个相关状态的类</h3><p>接着就是每个状态独占的一个类了。通过继承IState接口，控制器脚本可以直接调用相关状态类的方法来控制角色的动作（这里以角色进场的状态为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class EnterState : IState //继承Istate接口</span><br><span class="line">&#123;</span><br><span class="line">    private FSM manager; //控制角色的控制器脚本，通过这个脚本来控制角色的状态（脚本在后文会说）</span><br><span class="line">    public EnterState(FSM manager) //每个状态类的构造方法</span><br><span class="line">    &#123;</span><br><span class="line">        this.manager = manager; //绑定控制器脚本，这样可以更方便调用状态类内部方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnEnter() //进入这个状态应该进行的方法</span><br><span class="line">    &#123;</span><br><span class="line">        manager.currentStateType = StateType.Enter;  </span><br><span class="line">        //让控制器脚本的当前状态改成该状态（你都进入这个状态了，当前状态也肯定是这个）</span><br><span class="line">        manager.PlayAnimation(manager.animationNames.Anim_Enter);</span><br><span class="line">        //让控制器脚本播放这个状态的相关动画</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnUpdate() //维持这个状态的方法</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public void OnExit() //退出这个状态应该执行的方法</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个框架仅仅是最简单的状态。如果你的状态还需要更多的动作的话还要进行更多的操作（这里以角色的攻击为例，代码我不想细说，只是体现你可以在上面框架的基础上随便添加别的东西而已）<del>（一个猜想，你是不是想水字数）</del>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public class PAttackState : IState</span><br><span class="line">&#123;</span><br><span class="line">    private PlayerFSM manager;</span><br><span class="line">    private PAttackSkill currentEnemySkill;</span><br><span class="line"></span><br><span class="line">    public PAttackState(PlayerFSM manager)</span><br><span class="line">    &#123;</span><br><span class="line">        this.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnEnter()</span><br><span class="line">    &#123;</span><br><span class="line">        manager.currentStateType = StateType.Attack;</span><br><span class="line">        manager.PlayAnimation(currentEnemySkill.anim);</span><br><span class="line">        #region 判断在不在行为树上</span><br><span class="line">        if (currentEnemySkill.attackType == BehaviourClass.HeavyHit)</span><br><span class="line">        &#123;</span><br><span class="line">            manager.currentAct *= 2;</span><br><span class="line">            if (manager.currentAct &gt; 256)</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (manager.actTree[manager.currentAct].BehaviourClass == BehaviourClass.HeavyHit)</span><br><span class="line">            &#123;</span><br><span class="line">                SetAffect(manager.actTree[manager.currentAct].AffectClass);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (currentEnemySkill.attackType == BehaviourClass.LightHit)</span><br><span class="line">        &#123;</span><br><span class="line">            manager.currentAct *= 2;</span><br><span class="line">            manager.currentAct++;</span><br><span class="line">            if (manager.currentAct &gt; 256)</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (manager.actTree[manager.currentAct].BehaviourClass == BehaviourClass.LightHit)</span><br><span class="line">            &#123;</span><br><span class="line">                SetAffect(manager.actTree[manager.currentAct].AffectClass);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetAffect(AffectClass affectClass)</span><br><span class="line">    &#123;</span><br><span class="line">        switch (affectClass)</span><br><span class="line">        &#123;</span><br><span class="line">            case AffectClass.AddDamage:</span><br><span class="line">                currentEnemySkill.damage = (int)(currentEnemySkill.damage * 1.5f);</span><br><span class="line">                break;</span><br><span class="line">            case AffectClass.BreakDefense:</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case AffectClass.LongDizzy:</span><br><span class="line">                &#123;</span><br><span class="line">                    currentEnemySkill.dizzy += 2;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case AffectClass.ShortDizzy:</span><br><span class="line">                &#123;</span><br><span class="line">                    currentEnemySkill.dizzy++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        if (manager.IsAnimationEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            manager.TransitionState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ReSharper disable Unity.PerformanceAnalysis</span><br><span class="line">    public void OnExit()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 返回当前招式</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public PAttackSkill GetCurrentSkill()</span><br><span class="line">    &#123;</span><br><span class="line">        return currentEnemySkill;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 设置当前连招</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void SetCurrentSkill(PAttackSkill attack)</span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemySkill = attack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重头戏：控制器脚本"><a href="#重头戏：控制器脚本" class="headerlink" title="重头戏：控制器脚本"></a>重头戏：控制器脚本</h3><p>控制器脚本是十分重要的脚本，可以说是有限状态机的核心所在。它的任务是记录当前的状态，根据不同条件切换状态，以及执行相关状态的代码。这也是有限状态机的难点所在。</p>
<p>下面贴出的代码只是针对之前项目特化的控制器脚本，大家扫一眼就好。接着我会分模块讲解控制器脚本应该有什么。<del>（你是不是又在水字数）</del></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 有限状态机</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[RequireComponent(typeof(Feedback))]//需要反馈类</span><br><span class="line">public class FSM : MonoBehaviour</span><br><span class="line">&#123;   </span><br><span class="line">    public GameObject character;</span><br><span class="line">    public FSM_Parameter parameter;//声明参数类，在编辑面板编辑其参数</span><br><span class="line">    public FSM_AnimationNames animationNames;//声明动画类</span><br><span class="line">    public FSM_SoundEffects soundEffects;//声明音效类</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public int hp;//实时血量</span><br><span class="line">    [HideInInspector] public bool isDefense;//是否处于防御状态</span><br><span class="line"></span><br><span class="line">    private Animator animator;//动画组件</span><br><span class="line">    protected SoundManager soundManager;</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public IState currentState;//当前状态</span><br><span class="line">    [HideInInspector] public Dictionary&lt;StateType, IState&gt; states = new Dictionary&lt;StateType, IState&gt;();//创建字典，以枚举类型StateType作为Key</span><br><span class="line">    public StateType currentStateType;//当前状态类型</span><br><span class="line"></span><br><span class="line">    //敌人需要</span><br><span class="line">    [HideInInspector] public int index1;//当前连招数指示器</span><br><span class="line"></span><br><span class="line">    protected virtual void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        character = transform.GetChild(0).gameObject;</span><br><span class="line">        #region 注册状态</span><br><span class="line">        //添加键值对</span><br><span class="line">        states.Add(StateType.Enter, new EnterState(this));</span><br><span class="line">        states.Add(StateType.Defense, new DefenseState(this));</span><br><span class="line">        states.Add(StateType.Die, new DieState(this));</span><br><span class="line">        states.Add(StateType.RecoverHP, new RecoverHPState(this));</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        hp = parameter.HP;//血量初始为最大值</span><br><span class="line"></span><br><span class="line">        animator = character.GetComponent&lt;Animator&gt;();//获取动画器组件</span><br><span class="line">        soundManager = GameObject.FindGameObjectWithTag(&quot;SoundManager&quot;).GetComponent&lt;SoundManager&gt;();//获取声音管理器</span><br><span class="line">        TransitionState(StateType.Enter);//设置初始状态为入场状态</span><br><span class="line">    &#125;</span><br><span class="line">    protected virtual void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnUpdate();//在Update中进行当前状态的OnUpdate方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #region FSM为状态类及反馈类等提供的方法</span><br><span class="line"></span><br><span class="line">    #region 转换状态方法及重载</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 状态结束后默认调用此方法，进行状态间的过渡</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void TransitionState()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为指定状态</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;type&quot;&gt;指定状态&lt;/param&gt;</span><br><span class="line">    public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;攻击状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;攻击类型&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState,AttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((AttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 主角转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState, PAttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((PAttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为回血状态，并提供回血量</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;RecoverHPState&quot;&gt;回血状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType RecoverHPState, int health)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.RecoverHP];//切换当前状态</span><br><span class="line">        ((RecoverHPState)states[StateType.RecoverHP]).health = health;</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为防御状态，并提供防御时间</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;DefenseState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;defenseTime&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected virtual void TransitionState(StateType DefenseState, float defenseTime)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DefenseState==StateType.Defense)</span><br><span class="line">        &#123;</span><br><span class="line">                //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">                if (currentState != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentState.OnExit();</span><br><span class="line">                &#125;</span><br><span class="line">                ((DefenseState)states[StateType.Defense]).defenseTime = defenseTime;</span><br><span class="line">            currentState = states[StateType.Defense];//切换当前状态</span><br><span class="line">                </span><br><span class="line">                currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">        else if(DefenseState==StateType.Dodge)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">            if (currentState != null)</span><br><span class="line">            &#123;</span><br><span class="line">                currentState.OnExit();</span><br><span class="line">            &#125;</span><br><span class="line">            currentState = states[StateType.Dodge];//切换当前状态</span><br><span class="line">            ((DodgeState)states[StateType.Dodge]).dodgeTime = defenseTime;</span><br><span class="line">            currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void GetDizzy(float time)</span><br><span class="line">    &#123;</span><br><span class="line">        TransitionState(StateType.Idle,time);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 回血方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    public void Recover(int health)</span><br><span class="line">    &#123;</span><br><span class="line">        PlaySoundEffect(soundEffects.recoverAudioClip);</span><br><span class="line">        hp = hp + health &gt; parameter.HP ? parameter.HP : hp + health;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 受击方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;damage&quot;&gt;伤害值&lt;/param&gt;</span><br><span class="line">    public virtual void GetInjured(int damage)</span><br><span class="line">    &#123;</span><br><span class="line">        #region 防御判定</span><br><span class="line">        if (isDefense)</span><br><span class="line">        &#123;</span><br><span class="line">            PlaySoundEffect(soundEffects.defenseAudioClip);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        PlayAnimation(animationNames.Anim_Injured);//播放受伤动画</span><br><span class="line">        PlaySoundEffect(soundEffects.injuredAudioClip);//播放受伤音效</span><br><span class="line"></span><br><span class="line">        hp -= damage;//减血</span><br><span class="line"></span><br><span class="line">        #region 死亡判定</span><br><span class="line">        if (hp &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            hp = 0;</span><br><span class="line">            TransitionState(StateType.Die);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 死亡方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void Die()</span><br><span class="line">    &#123;</span><br><span class="line">        PlaySoundEffect(soundManager.end);</span><br><span class="line">        #region 测试用，播完动画后销毁物体什么的</span><br><span class="line">        Debug.Log(&quot;死啦&quot;);</span><br><span class="line">        #endregion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 被破防方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void GetDefenseBroken()</span><br><span class="line">    &#123;</span><br><span class="line">        if (currentState == states[StateType.Defense])</span><br><span class="line">        &#123;</span><br><span class="line">            PlayAnimation(animationNames.Anim_Idle);</span><br><span class="line">            isDefense = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 播放动画方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;anim&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public virtual void PlayAnimation(string anim)</span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(anim,-1,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 判断动画是否播放完毕的方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public bool IsAnimationEnd()</span><br><span class="line">    &#123; </span><br><span class="line">        AnimatorStateInfo info =animator.GetCurrentAnimatorStateInfo(0);</span><br><span class="line">        if (info.normalizedTime &gt;= 1.0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 播放音效方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    protected virtual void PlaySoundEffect(AudioClip soundEffect)</span><br><span class="line">    &#123;</span><br><span class="line">        if (soundEffect == null) return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #endregion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="声明部分"><a href="#声明部分" class="headerlink" title="声明部分"></a>声明部分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public GameObject character;</span><br><span class="line">    public FSM_Parameter parameter;//声明参数类，在编辑面板编辑其参数</span><br><span class="line">    public FSM_AnimationNames animationNames;//声明动画类</span><br><span class="line">    public FSM_SoundEffects soundEffects;//声明音效类</span><br><span class="line"></span><br><span class="line">    private Animator animator;//动画组件</span><br><span class="line">    protected SoundManager soundManager;</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public IState currentState;//当前状态</span><br><span class="line">    [HideInInspector] public Dictionary&lt;StateType, IState&gt; states = new Dictionary&lt;StateType, IState&gt;();//创建字典，以枚举类型StateType作为Key</span><br><span class="line">    public StateType currentStateType;//当前状态类型</span><br><span class="line"></span><br><span class="line">    //敌人需要</span><br><span class="line">    [HideInInspector] public int index1;//当前连招数指示器</span><br></pre></td></tr></table></figure>

<p>声明的变量主要包括两个部分：</p>
<h5 id="1-杂七杂八部分"><a href="#1-杂七杂八部分" class="headerlink" title="1.杂七杂八部分"></a>1.杂七杂八部分</h5><p>这个部分主要是玩家控制角色的音效、动画、血量属性方面的变量。当然这也是每个角色脚本必须的东西。（上面自定义的FSM_blabla类也是这个里面的，不用在意）。</p>
<h5 id="2-状态控制相关"><a href="#2-状态控制相关" class="headerlink" title="2.状态控制相关"></a>2.状态控制相关</h5><p>（1)字典states：它主要用来绑定每个枚举类型（状态名）和状态类（这个状态应该进行的方法）。通过这个字典我们可以直接通过当前角色的状态来找到这个状态应该执行的代码</p>
<p>（2）当前状态的类：虽然有字典，但是通过字典找到方法的过程未免还是太慢了。所以还是要个状态类存储当前状态</p>
<p>（3）当前状态的枚举：存储当前状态的相关枚举。没有这个，有限状态机的实现可以说是不可能。</p>
<h4 id="Start方法"><a href="#Start方法" class="headerlink" title="Start方法"></a>Start方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        character = transform.GetChild(0).gameObject;</span><br><span class="line">        #region 注册状态</span><br><span class="line">        //添加键值对</span><br><span class="line">        states.Add(StateType.Enter, new EnterState(this));</span><br><span class="line">        states.Add(StateType.Defense, new DefenseState(this));</span><br><span class="line">        states.Add(StateType.Die, new DieState(this));</span><br><span class="line">        states.Add(StateType.RecoverHP, new RecoverHPState(this));</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        hp = parameter.HP;//血量初始为最大值</span><br><span class="line"></span><br><span class="line">        animator = character.GetComponent&lt;Animator&gt;();//获取动画器组件</span><br><span class="line">        soundManager = GameObject.FindGameObjectWithTag(&quot;SoundManager&quot;).GetComponent&lt;SoundManager&gt;();//获取声音管理器</span><br><span class="line">        TransitionState(StateType.Enter);//设置初始状态为入场状态</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>还是三类：</p>
<h5 id="1-杂七杂八部分-1"><a href="#1-杂七杂八部分-1" class="headerlink" title="1.杂七杂八部分"></a>1.杂七杂八部分</h5><p>也就是获取相关组件，把角色基础属性确定好。</p>
<h5 id="2-注册键值对"><a href="#2-注册键值对" class="headerlink" title="2.注册键值对"></a>2.注册键值对</h5><p>往声明的字典里狂暴注入该角色应该有的所有状态的键值对，其中键值对里<code>new EnterState(this)</code>里面的this指的是控制器脚本（别忘了状态类构造方法里的变量:<code>FSM manager</code>）</p>
<h5 id="3-设置入场状态"><a href="#3-设置入场状态" class="headerlink" title="3.设置入场状态"></a>3.设置入场状态</h5><p>如果你的角色有什么入场状态（比如芬达哥开场要来一句战吼：“啊！！！！！芬达！！！！！！”什么的），最好在这里就可以转换状态了。</p>
<h4 id="Update方法"><a href="#Update方法" class="headerlink" title="Update方法"></a>Update方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnUpdate();//在Update中进行当前状态的OnUpdate方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这就很简单了。如何让维持这个状态的方法一直运行？直接把它丢进Update里就行了！</p>
<h4 id="状态转换方法和重载"><a href="#状态转换方法和重载" class="headerlink" title="状态转换方法和重载"></a>状态转换方法和重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#region 转换状态方法及重载</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 状态结束后默认调用此方法，进行状态间的过渡</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void TransitionState()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为指定状态</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;type&quot;&gt;指定状态&lt;/param&gt;</span><br><span class="line">    public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;攻击状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;攻击类型&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState,AttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((AttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为回血状态，并提供回血量</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;RecoverHPState&quot;&gt;回血状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType RecoverHPState, int health)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.RecoverHP];//切换当前状态</span><br><span class="line">        ((RecoverHPState)states[StateType.RecoverHP]).health = health;</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为防御状态，并提供防御时间</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;DefenseState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;defenseTime&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected virtual void TransitionState(StateType DefenseState, float defenseTime)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DefenseState==StateType.Defense)</span><br><span class="line">        &#123;</span><br><span class="line">                //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">                if (currentState != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentState.OnExit();</span><br><span class="line">                &#125;</span><br><span class="line">                ((DefenseState)states[StateType.Defense]).defenseTime = defenseTime;</span><br><span class="line">            currentState = states[StateType.Defense];//切换当前状态</span><br><span class="line">                </span><br><span class="line">                currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">        else if(DefenseState==StateType.Dodge)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">            if (currentState != null)</span><br><span class="line">            &#123;</span><br><span class="line">                currentState.OnExit();</span><br><span class="line">            &#125;</span><br><span class="line">            currentState = states[StateType.Dodge];//切换当前状态</span><br><span class="line">            ((DodgeState)states[StateType.Dodge]).dodgeTime = defenseTime;</span><br><span class="line">            currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br></pre></td></tr></table></figure>

<p>看起来重载方法实在是pang多，但实际上只是针对某些状态特化的方法而已（比如对造成伤害的重载加了伤害量，防御的重载加了防御），真正的切换状态方法是这个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先，执行上一个状态的OnExit方法，然后切换当前的状态（这里可以看到是通过字典进行的搜索），最后执行切换后的OnEnter方法。</p>
<p>当然，这个还是太粗糙了。如果有些状态需要调整角色本身的属性数据该怎么办呢？所以就有了后面的重载方法。在重载方法中有很多需要添加的操作，但上面这三个是万万不能少的。</p>
<p>然而这个重载方法是为了什么存在的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public virtual void TransitionState()</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><del>答案是水行数</del> 答案是为了子类对切换状态的重写啊。一个游戏里不同角色都可以使用有限状态机，而上面的代码正好可以作为所有有限状态机的父类。写这么一个空方法就是为了后续的扩展操作。说不定有些角色不需要声明当前状态就能切换状态呢？</p>
<h2 id="总结与Q-amp-A"><a href="#总结与Q-amp-A" class="headerlink" title="总结与Q&amp;A"></a>总结与Q&amp;A</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        综上，有限状态机的优点就是可以在拥有很多状态的角色时，可以完美实现不同状态的过渡和存储。但是它也有着明显的缺点：代码量的指数级提升和更高编程技巧的掌握。所以当一个角色的状态不是很多的话，有限状态机可能并不是一个很好的选择。同时，我在上面讲的仅仅是一个有限状态机最最基础的框架，在正常的游戏开发中还需要加入这个角色特化的相关变量和方法。最后是一些可能存在的问题，我先写上了：</p>
<h3 id="1-有限状态机是只能用在怪物逻辑上吗？"><a href="#1-有限状态机是只能用在怪物逻辑上吗？" class="headerlink" title="1.有限状态机是只能用在怪物逻辑上吗？"></a>1.有限状态机是只能用在怪物逻辑上吗？</h3><p>​        在目前的教程中，有限状态机很多都用在怪物的逻辑上面。比如怪物一开始的状态是巡逻，但是一旦玩家接近怪物，怪物的状态就会切换成追逐状态，也就是追着玩家不放，直到玩家远离怪物一段距离，然后重新恢复巡逻状态。要想实现这个效果，使用有限状态机无疑会十分轻松。但是实际上，有限状态机也可以运用于玩家本身上，理由的话我在上文也提到过：为了防止不同状态过渡时产生的问题。</p>
<h3 id="2-如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？"><a href="#2-如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？" class="headerlink" title="2.如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？"></a>2.如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？</h3><p>​        答案是把FSM作为父类，然后声明不同怪物的控制器脚本继承这个类。这样的话要注意字典里的键值对，父类只能注册大家都有的状态的键值对，不然就会出错。并且如果不同怪物的相同状态有着不同方法（比如诺斯克和芬达哥都有进场状态，但是芬达哥是啊！！！！！！芬达！！！！！！，诺斯克是给你来个大变活人），那一定要区分这些状态（比如诺斯克进场的状态类叫做NEnterState，芬达哥进场的状态类叫做FEnterState），毕竟类是没有重载这个东西的。</p>
<p>（寒假来了，开始爆更模式）</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Karmotrine.</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="简析Unity有限状态机的实现方法与使用">http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/" rel="next" title="简析Unity射线检测的概念与应用"><span class="post-nav-text">简析Unity射线检测的概念与应用</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Karmotrine</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.0.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-01-07T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="7226373375" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listfolded data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>