<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utopia</title>
  
  <subtitle>Kyrie eleison.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-10T14:56:40.383Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Karmotrine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>胡言乱语录的Unity一轮教程</title>
    <link href="http://example.com/2022/01/10/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E5%BD%95%E7%9A%84Unity%E4%B8%80%E8%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/10/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E5%BD%95%E7%9A%84Unity%E4%B8%80%E8%BD%AE%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-10T14:55:28.000Z</published>
    <updated>2022-01-10T14:56:40.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简析Unity有限状态机的实现方法与使用</title>
    <link href="http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-09T14:58:15.000Z</published>
    <updated>2022-01-09T17:30:42.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1382359170&auto=1&height=66"></iframe><p>（冰海战记真好看，大家快点都去看）</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        寒假终于来力，有时间摸一摸博客了。今天就来介绍一下我一直很想写的有限状态机（FSM）。它虽然起步比较难，但是对于代码结构的优化和游戏人物的控制真的非常的舒适（起码不用声明114514个布尔值来控制角色的动作了）。如果有学弟看到我的这篇拙作也可以挑战一下使用有限状态机来做三轮捏（bushi</p><h2 id="为什么要使用FSM"><a href="#为什么要使用FSM" class="headerlink" title="为什么要使用FSM"></a>为什么要使用FSM</h2><h3 id="一个哈人的bug"><a href="#一个哈人的bug" class="headerlink" title="一个哈人的bug"></a>一个哈人的bug</h3><p>在解答这个问题之前，我想问问读者一个问题：</p><p>​        假如你是李华，你想通过一个程序来控制游戏内一个怪物的各种状态（比如走路，静止，攻击，跳跃，冲刺等等），让这个怪物血量每减少三分之一的时候会跳在中间捶地板，在平常的时候可以抡大锤砸玩家，在被逼到死角的时候使用锤子砸地形成一个冲击波，在把玩家逼到死角的时候会自动往后跳不至于逼死玩家。。。<del>（假骑士是什么，我不知道）</del>这样应该怎么写呢？我想大多数人会在控制怪物的脚本里先洋洋洒洒声明一堆布尔值（至少以前我是这样的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private bool isLuning; //正在抡大锤</span><br><span class="line">private bool isZaDaChui; //正在砸地形成冲击波</span><br><span class="line">private bool isHouTiao; //正在后跳</span><br><span class="line">private bool isChui; //正在捶地板</span><br></pre></td></tr></table></figure><p>​        我不能说这样做不对，因为事实上这样做是可以实现功能的。但是这样做却有一个隐患，就是切换不同状态时会发生问题。举个例子，当假骑士<del>（你刚刚说了假骑士对吧，对吧？！）</del>抡锤子时正好把玩家逼入了死角，同时血量掉了三分之一时，它应该被切换成什么状态呢？这个时候三个控制状态的布尔值都是真的，那假骑士这个时候要干什么，我是想都不敢想（</p><p>​        当一个角色的状态有很多时，如何顺利进行不同状态之间的过渡就成了我们头疼的事情。如果是怪物状态的控制那还好，因为怪物后面都是有着固定的逻辑的。但如果是玩家状态的控制呢？要知道，玩家背后的逻辑可是敢在酒吧里点炒饭，吃程序员不吐骨头的广大游戏玩家啊。当游戏玩家在奔跑时按下飞行键，或者在怕爬梯子时按下跳跃键，产生的后果肯定是让人啼笑皆非的。</p><p>​        而在上述的问题中，眼尖的读者就能看出真正的问题所在：这些问题的产生都是由于两个不同状态的同时进行导致的。也就是在跳跃时又进行了飞行的功能，在走路时又进行了奔跑的功能。那这样的话，我们只要用枚举的方式把所有状态囊括在一起不就好了嘛。因为枚举只能有一个状态，恰好可以完美解决上面的状态并发问题。而这个思想，也就是我今天想要写的有限状态机（FSM）。</p><h3 id="一个有限的状态机"><a href="#一个有限的状态机" class="headerlink" title="一个有限的状态机"></a>一个有限的状态机</h3><p>​        FSM，又称为有限状态机。它的意思就是我们列举出一系列有限的状态（以玩家本身为例，状态就有奔跑，静止，攻击，跳跃等等），以及这个状态应该运行的代码，其中包括状态开始，状态进行和状态结束的方法（比如跳跃的时候角色要先起跳，然后一直在半空什么的）。接着，我们编写一个程序来控制状态的切换以及进入一个状态在什么阶段应该运行的相关代码。由于这个状态是枚举的，而且有关动作只有在玩家当前为这个状态时才可以执行，所以理论上可以完美解决上面的问题。</p><p>​        这个结构其实在Unity内部就有了实践，那就是animator组件：</p><p><img src="animator.png" alt="animator" loading="lazy"></p><p>每个动画都被框在了一个状态里，只有当控制器运行到了这个状态时才会播放里面的动画，根本不会出现两个动画并发的现象，而我们的有限状态机也会沿用这个思想，只不过每个状态里存储的不是动画，而是一串串代码。</p><h2 id="如何构建有限状态机"><a href="#如何构建有限状态机" class="headerlink" title="如何构建有限状态机"></a>如何构建有限状态机</h2><p>​        有限状态机的图解如下：</p><h3 id="状态继承的接口IState"><a href="#状态继承的接口IState" class="headerlink" title="状态继承的接口IState"></a>状态继承的接口IState</h3><p>​        正如上文所说，状态机应该拥有进入这个状态，维持这个状态，以及退出这个状态的相应动作（就像碰撞检测中OnColliderEnter,OnColliderStay,OnColliderExit这仨一样）。所以作为每个状态都应该继承的接口应该有这三个对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IState</span><br><span class="line">&#123;</span><br><span class="line">    void OnEnter(); //进入状态的方法</span><br><span class="line">    void OnUpdate(); //维持状态的方法</span><br><span class="line">    void OnExit(); //退出状态的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="角色所有状态的枚举"><a href="#角色所有状态的枚举" class="headerlink" title="角色所有状态的枚举"></a>角色所有状态的枚举</h3><p>上文也提到了有限状态机的枚举思想，所以我们也需要一个枚举来囊括角色的所有状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum StateType</span><br><span class="line">&#123;</span><br><span class="line">    Enter,//入场</span><br><span class="line">    Defense,//防御</span><br><span class="line">    Die,//死亡</span><br><span class="line">    Attack,//攻击</span><br><span class="line">    RecoverHP,//回血</span><br><span class="line">    Dodge,//闪避</span><br><span class="line">    Idle //站着不动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这些状态都是你自己定的，上面这个例子的状态仅作为参考。</p><h3 id="每个相关状态的类"><a href="#每个相关状态的类" class="headerlink" title="每个相关状态的类"></a>每个相关状态的类</h3><p>接着就是每个状态独占的一个类了。通过继承IState接口，控制器脚本可以直接调用相关状态类的方法来控制角色的动作（这里以角色进场的状态为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class EnterState : IState //继承Istate接口</span><br><span class="line">&#123;</span><br><span class="line">    private FSM manager; //控制角色的控制器脚本，通过这个脚本来控制角色的状态（脚本在后文会说）</span><br><span class="line">    public EnterState(FSM manager) //每个状态类的构造方法</span><br><span class="line">    &#123;</span><br><span class="line">        this.manager = manager; //绑定控制器脚本，这样可以更方便调用状态类内部方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnEnter() //进入这个状态应该进行的方法</span><br><span class="line">    &#123;</span><br><span class="line">        manager.currentStateType = StateType.Enter;  </span><br><span class="line">        //让控制器脚本的当前状态改成该状态（你都进入这个状态了，当前状态也肯定是这个）</span><br><span class="line">        manager.PlayAnimation(manager.animationNames.Anim_Enter);</span><br><span class="line">        //让控制器脚本播放这个状态的相关动画</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnUpdate() //维持这个状态的方法</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public void OnExit() //退出这个状态应该执行的方法</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架仅仅是最简单的状态。如果你的状态还需要更多的动作的话还要进行更多的操作（这里以角色的攻击为例，代码我不想细说，只是体现你可以在上面框架的基础上随便添加别的东西而已）<del>（一个猜想，你是不是想水字数）</del>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public class PAttackState : IState</span><br><span class="line">&#123;</span><br><span class="line">    private PlayerFSM manager;</span><br><span class="line">    private PAttackSkill currentEnemySkill;</span><br><span class="line"></span><br><span class="line">    public PAttackState(PlayerFSM manager)</span><br><span class="line">    &#123;</span><br><span class="line">        this.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnEnter()</span><br><span class="line">    &#123;</span><br><span class="line">        manager.currentStateType = StateType.Attack;</span><br><span class="line">        manager.PlayAnimation(currentEnemySkill.anim);</span><br><span class="line">        #region 判断在不在行为树上</span><br><span class="line">        if (currentEnemySkill.attackType == BehaviourClass.HeavyHit)</span><br><span class="line">        &#123;</span><br><span class="line">            manager.currentAct *= 2;</span><br><span class="line">            if (manager.currentAct &gt; 256)</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (manager.actTree[manager.currentAct].BehaviourClass == BehaviourClass.HeavyHit)</span><br><span class="line">            &#123;</span><br><span class="line">                SetAffect(manager.actTree[manager.currentAct].AffectClass);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (currentEnemySkill.attackType == BehaviourClass.LightHit)</span><br><span class="line">        &#123;</span><br><span class="line">            manager.currentAct *= 2;</span><br><span class="line">            manager.currentAct++;</span><br><span class="line">            if (manager.currentAct &gt; 256)</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (manager.actTree[manager.currentAct].BehaviourClass == BehaviourClass.LightHit)</span><br><span class="line">            &#123;</span><br><span class="line">                SetAffect(manager.actTree[manager.currentAct].AffectClass);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetAffect(AffectClass affectClass)</span><br><span class="line">    &#123;</span><br><span class="line">        switch (affectClass)</span><br><span class="line">        &#123;</span><br><span class="line">            case AffectClass.AddDamage:</span><br><span class="line">                currentEnemySkill.damage = (int)(currentEnemySkill.damage * 1.5f);</span><br><span class="line">                break;</span><br><span class="line">            case AffectClass.BreakDefense:</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case AffectClass.LongDizzy:</span><br><span class="line">                &#123;</span><br><span class="line">                    currentEnemySkill.dizzy += 2;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case AffectClass.ShortDizzy:</span><br><span class="line">                &#123;</span><br><span class="line">                    currentEnemySkill.dizzy++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        if (manager.IsAnimationEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            manager.TransitionState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ReSharper disable Unity.PerformanceAnalysis</span><br><span class="line">    public void OnExit()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 返回当前招式</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public PAttackSkill GetCurrentSkill()</span><br><span class="line">    &#123;</span><br><span class="line">        return currentEnemySkill;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 设置当前连招</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void SetCurrentSkill(PAttackSkill attack)</span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemySkill = attack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重头戏：控制器脚本"><a href="#重头戏：控制器脚本" class="headerlink" title="重头戏：控制器脚本"></a>重头戏：控制器脚本</h3><p>控制器脚本是十分重要的脚本，可以说是有限状态机的核心所在。它的任务是记录当前的状态，根据不同条件切换状态，以及执行相关状态的代码。这也是有限状态机的难点所在。</p><p>下面贴出的代码只是针对之前项目特化的控制器脚本，大家扫一眼就好。接着我会分模块讲解控制器脚本应该有什么。<del>（你是不是又在水字数）</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 有限状态机</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[RequireComponent(typeof(Feedback))]//需要反馈类</span><br><span class="line">public class FSM : MonoBehaviour</span><br><span class="line">&#123;   </span><br><span class="line">    public GameObject character;</span><br><span class="line">    public FSM_Parameter parameter;//声明参数类，在编辑面板编辑其参数</span><br><span class="line">    public FSM_AnimationNames animationNames;//声明动画类</span><br><span class="line">    public FSM_SoundEffects soundEffects;//声明音效类</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public int hp;//实时血量</span><br><span class="line">    [HideInInspector] public bool isDefense;//是否处于防御状态</span><br><span class="line"></span><br><span class="line">    private Animator animator;//动画组件</span><br><span class="line">    protected SoundManager soundManager;</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public IState currentState;//当前状态</span><br><span class="line">    [HideInInspector] public Dictionary&lt;StateType, IState&gt; states = new Dictionary&lt;StateType, IState&gt;();//创建字典，以枚举类型StateType作为Key</span><br><span class="line">    public StateType currentStateType;//当前状态类型</span><br><span class="line"></span><br><span class="line">    //敌人需要</span><br><span class="line">    [HideInInspector] public int index1;//当前连招数指示器</span><br><span class="line"></span><br><span class="line">    protected virtual void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        character = transform.GetChild(0).gameObject;</span><br><span class="line">        #region 注册状态</span><br><span class="line">        //添加键值对</span><br><span class="line">        states.Add(StateType.Enter, new EnterState(this));</span><br><span class="line">        states.Add(StateType.Defense, new DefenseState(this));</span><br><span class="line">        states.Add(StateType.Die, new DieState(this));</span><br><span class="line">        states.Add(StateType.RecoverHP, new RecoverHPState(this));</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        hp = parameter.HP;//血量初始为最大值</span><br><span class="line"></span><br><span class="line">        animator = character.GetComponent&lt;Animator&gt;();//获取动画器组件</span><br><span class="line">        soundManager = GameObject.FindGameObjectWithTag(&quot;SoundManager&quot;).GetComponent&lt;SoundManager&gt;();//获取声音管理器</span><br><span class="line">        TransitionState(StateType.Enter);//设置初始状态为入场状态</span><br><span class="line">    &#125;</span><br><span class="line">    protected virtual void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnUpdate();//在Update中进行当前状态的OnUpdate方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #region FSM为状态类及反馈类等提供的方法</span><br><span class="line"></span><br><span class="line">    #region 转换状态方法及重载</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 状态结束后默认调用此方法，进行状态间的过渡</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void TransitionState()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为指定状态</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;type&quot;&gt;指定状态&lt;/param&gt;</span><br><span class="line">    public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;攻击状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;攻击类型&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState,AttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((AttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 主角转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState, PAttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((PAttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为回血状态，并提供回血量</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;RecoverHPState&quot;&gt;回血状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType RecoverHPState, int health)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.RecoverHP];//切换当前状态</span><br><span class="line">        ((RecoverHPState)states[StateType.RecoverHP]).health = health;</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为防御状态，并提供防御时间</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;DefenseState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;defenseTime&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected virtual void TransitionState(StateType DefenseState, float defenseTime)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DefenseState==StateType.Defense)</span><br><span class="line">        &#123;</span><br><span class="line">                //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">                if (currentState != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentState.OnExit();</span><br><span class="line">                &#125;</span><br><span class="line">                ((DefenseState)states[StateType.Defense]).defenseTime = defenseTime;</span><br><span class="line">            currentState = states[StateType.Defense];//切换当前状态</span><br><span class="line">                </span><br><span class="line">                currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">        else if(DefenseState==StateType.Dodge)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">            if (currentState != null)</span><br><span class="line">            &#123;</span><br><span class="line">                currentState.OnExit();</span><br><span class="line">            &#125;</span><br><span class="line">            currentState = states[StateType.Dodge];//切换当前状态</span><br><span class="line">            ((DodgeState)states[StateType.Dodge]).dodgeTime = defenseTime;</span><br><span class="line">            currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void GetDizzy(float time)</span><br><span class="line">    &#123;</span><br><span class="line">        TransitionState(StateType.Idle,time);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 回血方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    public void Recover(int health)</span><br><span class="line">    &#123;</span><br><span class="line">        PlaySoundEffect(soundEffects.recoverAudioClip);</span><br><span class="line">        hp = hp + health &gt; parameter.HP ? parameter.HP : hp + health;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 受击方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;damage&quot;&gt;伤害值&lt;/param&gt;</span><br><span class="line">    public virtual void GetInjured(int damage)</span><br><span class="line">    &#123;</span><br><span class="line">        #region 防御判定</span><br><span class="line">        if (isDefense)</span><br><span class="line">        &#123;</span><br><span class="line">            PlaySoundEffect(soundEffects.defenseAudioClip);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        PlayAnimation(animationNames.Anim_Injured);//播放受伤动画</span><br><span class="line">        PlaySoundEffect(soundEffects.injuredAudioClip);//播放受伤音效</span><br><span class="line"></span><br><span class="line">        hp -= damage;//减血</span><br><span class="line"></span><br><span class="line">        #region 死亡判定</span><br><span class="line">        if (hp &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            hp = 0;</span><br><span class="line">            TransitionState(StateType.Die);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 死亡方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void Die()</span><br><span class="line">    &#123;</span><br><span class="line">        PlaySoundEffect(soundManager.end);</span><br><span class="line">        #region 测试用，播完动画后销毁物体什么的</span><br><span class="line">        Debug.Log(&quot;死啦&quot;);</span><br><span class="line">        #endregion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 被破防方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void GetDefenseBroken()</span><br><span class="line">    &#123;</span><br><span class="line">        if (currentState == states[StateType.Defense])</span><br><span class="line">        &#123;</span><br><span class="line">            PlayAnimation(animationNames.Anim_Idle);</span><br><span class="line">            isDefense = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 播放动画方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;anim&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public virtual void PlayAnimation(string anim)</span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(anim,-1,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 判断动画是否播放完毕的方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public bool IsAnimationEnd()</span><br><span class="line">    &#123; </span><br><span class="line">        AnimatorStateInfo info =animator.GetCurrentAnimatorStateInfo(0);</span><br><span class="line">        if (info.normalizedTime &gt;= 1.0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 播放音效方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    protected virtual void PlaySoundEffect(AudioClip soundEffect)</span><br><span class="line">    &#123;</span><br><span class="line">        if (soundEffect == null) return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #endregion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明部分"><a href="#声明部分" class="headerlink" title="声明部分"></a>声明部分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public GameObject character;</span><br><span class="line">    public FSM_Parameter parameter;//声明参数类，在编辑面板编辑其参数</span><br><span class="line">    public FSM_AnimationNames animationNames;//声明动画类</span><br><span class="line">    public FSM_SoundEffects soundEffects;//声明音效类</span><br><span class="line"></span><br><span class="line">    private Animator animator;//动画组件</span><br><span class="line">    protected SoundManager soundManager;</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public IState currentState;//当前状态</span><br><span class="line">    [HideInInspector] public Dictionary&lt;StateType, IState&gt; states = new Dictionary&lt;StateType, IState&gt;();//创建字典，以枚举类型StateType作为Key</span><br><span class="line">    public StateType currentStateType;//当前状态类型</span><br><span class="line"></span><br><span class="line">    //敌人需要</span><br><span class="line">    [HideInInspector] public int index1;//当前连招数指示器</span><br></pre></td></tr></table></figure><p>声明的变量主要包括两个部分：</p><h5 id="1-杂七杂八部分"><a href="#1-杂七杂八部分" class="headerlink" title="1.杂七杂八部分"></a>1.杂七杂八部分</h5><p>这个部分主要是玩家控制角色的音效、动画、血量属性方面的变量。当然这也是每个角色脚本必须的东西。（上面自定义的FSM_blabla类也是这个里面的，不用在意）。</p><h5 id="2-状态控制相关"><a href="#2-状态控制相关" class="headerlink" title="2.状态控制相关"></a>2.状态控制相关</h5><p>（1)字典states：它主要用来绑定每个枚举类型（状态名）和状态类（这个状态应该进行的方法）。通过这个字典我们可以直接通过当前角色的状态来找到这个状态应该执行的代码</p><p>（2）当前状态的类：虽然有字典，但是通过字典找到方法的过程未免还是太慢了。所以还是要个状态类存储当前状态</p><p>（3）当前状态的枚举：存储当前状态的相关枚举。没有这个，有限状态机的实现可以说是不可能。</p><h4 id="Start方法"><a href="#Start方法" class="headerlink" title="Start方法"></a>Start方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        character = transform.GetChild(0).gameObject;</span><br><span class="line">        #region 注册状态</span><br><span class="line">        //添加键值对</span><br><span class="line">        states.Add(StateType.Enter, new EnterState(this));</span><br><span class="line">        states.Add(StateType.Defense, new DefenseState(this));</span><br><span class="line">        states.Add(StateType.Die, new DieState(this));</span><br><span class="line">        states.Add(StateType.RecoverHP, new RecoverHPState(this));</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        hp = parameter.HP;//血量初始为最大值</span><br><span class="line"></span><br><span class="line">        animator = character.GetComponent&lt;Animator&gt;();//获取动画器组件</span><br><span class="line">        soundManager = GameObject.FindGameObjectWithTag(&quot;SoundManager&quot;).GetComponent&lt;SoundManager&gt;();//获取声音管理器</span><br><span class="line">        TransitionState(StateType.Enter);//设置初始状态为入场状态</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还是三类：</p><h5 id="1-杂七杂八部分-1"><a href="#1-杂七杂八部分-1" class="headerlink" title="1.杂七杂八部分"></a>1.杂七杂八部分</h5><p>也就是获取相关组件，把角色基础属性确定好。</p><h5 id="2-注册键值对"><a href="#2-注册键值对" class="headerlink" title="2.注册键值对"></a>2.注册键值对</h5><p>往声明的字典里狂暴注入该角色应该有的所有状态的键值对，其中键值对里<code>new EnterState(this)</code>里面的this指的是控制器脚本（别忘了状态类构造方法里的变量:<code>FSM manager</code>）</p><h5 id="3-设置入场状态"><a href="#3-设置入场状态" class="headerlink" title="3.设置入场状态"></a>3.设置入场状态</h5><p>如果你的角色有什么入场状态（比如芬达哥开场要来一句战吼：“啊！！！！！芬达！！！！！！”什么的），最好在这里就可以转换状态了。</p><h4 id="Update方法"><a href="#Update方法" class="headerlink" title="Update方法"></a>Update方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnUpdate();//在Update中进行当前状态的OnUpdate方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这就很简单了。如何让维持这个状态的方法一直运行？直接把它丢进Update里就行了！</p><h4 id="状态转换方法和重载"><a href="#状态转换方法和重载" class="headerlink" title="状态转换方法和重载"></a>状态转换方法和重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#region 转换状态方法及重载</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 状态结束后默认调用此方法，进行状态间的过渡</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void TransitionState()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为指定状态</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;type&quot;&gt;指定状态&lt;/param&gt;</span><br><span class="line">    public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;攻击状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;攻击类型&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState,AttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((AttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为回血状态，并提供回血量</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;RecoverHPState&quot;&gt;回血状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType RecoverHPState, int health)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.RecoverHP];//切换当前状态</span><br><span class="line">        ((RecoverHPState)states[StateType.RecoverHP]).health = health;</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为防御状态，并提供防御时间</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;DefenseState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;defenseTime&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected virtual void TransitionState(StateType DefenseState, float defenseTime)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DefenseState==StateType.Defense)</span><br><span class="line">        &#123;</span><br><span class="line">                //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">                if (currentState != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentState.OnExit();</span><br><span class="line">                &#125;</span><br><span class="line">                ((DefenseState)states[StateType.Defense]).defenseTime = defenseTime;</span><br><span class="line">            currentState = states[StateType.Defense];//切换当前状态</span><br><span class="line">                </span><br><span class="line">                currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">        else if(DefenseState==StateType.Dodge)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">            if (currentState != null)</span><br><span class="line">            &#123;</span><br><span class="line">                currentState.OnExit();</span><br><span class="line">            &#125;</span><br><span class="line">            currentState = states[StateType.Dodge];//切换当前状态</span><br><span class="line">            ((DodgeState)states[StateType.Dodge]).dodgeTime = defenseTime;</span><br><span class="line">            currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br></pre></td></tr></table></figure><p>看起来重载方法实在是pang多，但实际上只是针对某些状态特化的方法而已（比如对造成伤害的重载加了伤害量，防御的重载加了防御），真正的切换状态方法是这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先，执行上一个状态的OnExit方法，然后切换当前的状态（这里可以看到是通过字典进行的搜索），最后执行切换后的OnEnter方法。</p><p>当然，这个还是太粗糙了。如果有些状态需要调整角色本身的属性数据该怎么办呢？所以就有了后面的重载方法。在重载方法中有很多需要添加的操作，但上面这三个是万万不能少的。</p><p>然而这个重载方法是为了什么存在的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public virtual void TransitionState()</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><del>答案是水行数</del> 答案是为了子类对切换状态的重写啊。一个游戏里不同角色都可以使用有限状态机，而上面的代码正好可以作为所有有限状态机的父类。写这么一个空方法就是为了后续的扩展操作。说不定有些角色不需要声明当前状态就能切换状态呢？</p><h2 id="总结与Q-amp-A"><a href="#总结与Q-amp-A" class="headerlink" title="总结与Q&amp;A"></a>总结与Q&amp;A</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        综上，有限状态机的优点就是可以在拥有很多状态的角色时，可以完美实现不同状态的过渡和存储。但是它也有着明显的缺点：代码量的指数级提升和更高编程技巧的掌握。所以当一个角色的状态不是很多的话，有限状态机可能并不是一个很好的选择。同时，我在上面讲的仅仅是一个有限状态机最最基础的框架，在正常的游戏开发中还需要加入这个角色特化的相关变量和方法。最后是一些可能存在的问题，我先写上了：</p><h3 id="1-有限状态机是只能用在怪物逻辑上吗？"><a href="#1-有限状态机是只能用在怪物逻辑上吗？" class="headerlink" title="1.有限状态机是只能用在怪物逻辑上吗？"></a>1.有限状态机是只能用在怪物逻辑上吗？</h3><p>​        在目前的教程中，有限状态机很多都用在怪物的逻辑上面。比如怪物一开始的状态是巡逻，但是一旦玩家接近怪物，怪物的状态就会切换成追逐状态，也就是追着玩家不放，直到玩家远离怪物一段距离，然后重新恢复巡逻状态。要想实现这个效果，使用有限状态机无疑会十分轻松。但是实际上，有限状态机也可以运用于玩家本身上，理由的话我在上文也提到过：为了防止不同状态过渡时产生的问题。</p><h3 id="2-如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？"><a href="#2-如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？" class="headerlink" title="2.如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？"></a>2.如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？</h3><p>​        答案是把FSM作为父类，然后声明不同怪物的控制器脚本继承这个类。这样的话要注意字典里的键值对，父类只能注册大家都有的状态的键值对，不然就会出错。并且如果不同怪物的相同状态有着不同方法（比如诺斯克和芬达哥都有进场状态，但是芬达哥是啊！！！！！！芬达！！！！！！，诺斯克是给你来个大变活人），那一定要区分这些状态（比如诺斯克进场的状态类叫做NEnterState，芬达哥进场的状态类叫做FEnterState），毕竟类是没有重载这个东西的。</p><p>（寒假来了，开始爆更模式）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>简析Unity射线检测的概念与应用</title>
    <link href="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-09-08T09:50:08.000Z</published>
    <updated>2022-01-07T11:37:58.327Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1840474281&auto=1&height=66"></iframe><p>众所周知，在一款游戏中使用检测手法是十分常见的。比如说玩家自动来到某个地方触发剧情，判断子弹击中玩家的部位并造成相应血量。。。这其实都是碰撞检测的相关体现。但是，虽然碰撞检测在日常使用中相当普遍，但是碰撞检测也有相应的局限性。比如说APEX里恶灵被人拿枪指着时会有相应提示（感觉我的游戏偏好要在博客里面暴露光了），又或者是我们拿鼠标光标指向某些物体时显示出物体的具体信息（就比如像是城市模拟经营，我们想知道这个建筑具体是啥东西；又比如即时战略游戏我们想看一个兵种的具体血量等属性），那碰撞检测就显得见襟捉肘了。我总不能对着光标方向创建一个透明长方体来检测碰撞吧。但这样就显得很繁琐了。这时候我们就可以引入一个全新的检测手法：也就是射线检测了。我们可以像超市自动开关门那样引出一个射线，如果射线指向了某些特定属性的物体就会发出信号。这也是射线检测的基本方法。</p><h2 id="射线是啥"><a href="#射线是啥" class="headerlink" title="射线是啥"></a>射线是啥</h2><p>在进入射线检测的正题前，我们先回顾一下小学的知识：射线是个啥？百度百科上写的是：具有特定能量的粒子束或光子束流。<del>看到这里你肯定十分疑惑，因为我也很疑惑，然后我发现我复制粘贴错了。</del>咳咳，射线实际上是：直线上的一点和它一旁的部分所组成的图形。它由一个起始点开始，向着一个方向放出无限长的线。当线与我们想要检测的物体重合就会发出信号。就实际例子上来说，我们在射击游戏中端着枪，枪口到远处就算是一个射线。虽然我很想把射线一次全部整完，但由于射线检测在2D和3D的区别还是蛮大的，所以还是分成两个部分一起说吧。</p><h2 id="3D世界中的射线检测"><a href="#3D世界中的射线检测" class="headerlink" title="3D世界中的射线检测"></a>3D世界中的射线检测</h2><h3 id="咋检测的捏？"><a href="#咋检测的捏？" class="headerlink" title="咋检测的捏？"></a>咋检测的捏？</h3><p>我们既然讲了射线检测的原理，那就直接上射线检测的代码8：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Physics.Raycast(Vector3 origin,Vector3 direction,out RaycastHit hitinfo,float distance,int LayerMask);</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//direction：射线的方向，因为是方向坐标所以使用Vector3表示</span><br><span class="line">//hitinfo：一个结构体，可以储存碰撞体的所有信息。你可以声明一个空的然后直接代入就可以</span><br><span class="line">//结构体里面很有价值，后面会说</span><br><span class="line">//下面俩参数是可选参数：</span><br><span class="line">//distance:射线检测的距离，虽然说射线的长度是无限长，但是可以设置它的检测距离，只有在这个距离内的物体才可以被检测到</span><br><span class="line">//LayerMask：图层，虽然物体都处在一个3D世界中，但都有着图层之分。如果输入图层的序号就可以只检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用</span><br></pre></td></tr></table></figure><h4 id="1-这个方法返回啥？"><a href="#1-这个方法返回啥？" class="headerlink" title="1.这个方法返回啥？"></a>1.这个方法返回啥？</h4><p>这个方法返回的是布尔类型的值，但是它害可以通过out返回一个RaycastHit结构体。</p><p>**out:**c#中特有的参数，可以不通过return返回变量。out后面的东西不需要赋值甚至实例化。</p><h4 id="2-origin和direction可不可以合二为一？"><a href="#2-origin和direction可不可以合二为一？" class="headerlink" title="2.origin和direction可不可以合二为一？"></a>2.origin和direction可不可以合二为一？</h4><p>其实Unity自身内置一个叫做Ray的类：</p><p><code>Ray ray=new ray(Vector3 origin,Vector3 direction)；</code>这样就可以直接把两个Vector变量直接合成一个射线的Ray变量，代码内容也可以改成：</p><p><code>Physics.Raycast(ray,out RaycastHit hitinfo,float distance,int LayerMask);</code></p><h4 id="3-这样射线检测我看不到，有什么办法显示射线吗？"><a href="#3-这样射线检测我看不到，有什么办法显示射线吗？" class="headerlink" title="3.这样射线检测我看不到，有什么办法显示射线吗？"></a>3.这样射线检测我看不到，有什么办法显示射线吗？</h4><p>如果想拿着这个代码去unity内部尝试的话，可以参考下面这个代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Debug.DrawLine(Vector3 origin,Vector3 destination,Color color);</span><br><span class="line">//功能是在Scene窗口显示一条可见的线段</span><br><span class="line">//origin:线段的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//destination：线段的终点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//color:你想在窗口上看到的线段的颜色</span><br><span class="line">Debug.DrawRay(Vector3 origin,Vector3 direction,Color color)</span><br><span class="line">//功能是在Scene窗口显示一条可见的射线</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//destination：射线的方向，因为是方向所以使用Vector3表示</span><br><span class="line">//color:你想在窗口上看到的射线的颜色</span><br></pre></td></tr></table></figure><p>当然，如果你是想显示特定的射线的样子，就可以改成：</p><p><code>Debug.DrawLine(ray.origin,ray.origin+ray.direction,Color.red);</code></p><p>但是你可能会发现Scene窗口看到的实在是太短了，原因是我们线段终点有点短，所以可以尝试在终点后面乘上个100甚至是1000</p><h4 id="4-RaycastHit感觉不如碰撞检测。。。功能"><a href="#4-RaycastHit感觉不如碰撞检测。。。功能" class="headerlink" title="4.RaycastHit感觉不如碰撞检测。。。功能"></a>4.RaycastHit感觉不如碰撞检测。。。功能</h4><p>RaycastHit很有用，结构体内除了位置坐标以外还有检测到物体的碰撞体。这意味着我们可以获取这个物体的相关组件了：</p><p><code>hit.collider.gameObject.GetComponent&lt;RigidBody&gt;();</code></p><p>或者<code>hit.collider.gameObject.name</code></p><p>是不是很好用。</p><h4 id="5-What’s-up-你这Raycast只能测一个啊？！"><a href="#5-What’s-up-你这Raycast只能测一个啊？！" class="headerlink" title="5.What’s up?你这Raycast只能测一个啊？！"></a>5.What’s up?你这Raycast只能测一个啊？！</h4><p>raycasthit只有一个返回值，那如果我想获得所有在射线上的物体怎么办？</p><p>答案是使用<code>RaycastAll</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits;</span><br><span class="line">hits=Physics.RaycastAll(ray,maxDistance,mask);</span><br><span class="line">/*</span><br><span class="line">1.返回值是RaycastHit数组,所以记得加等号</span><br><span class="line">2.后面俩参数依然是最远距离和图层，前面写了</span><br><span class="line">3.后面可以使用foreach遍历数组里面的</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="6-你这LayerMask有问题啊？怎么是int？"><a href="#6-你这LayerMask有问题啊？怎么是int？" class="headerlink" title="6.你这LayerMask有问题啊？怎么是int？"></a>6.你这LayerMask有问题啊？怎么是int？</h4><p>LayerMask的形式是int，没错，不是字符而是int。它表示的是你涂层的序号的<strong>二次方倍</strong>，没错，<strong>二次方倍</strong>。这意味着你想检测的图层序号是第九层，但你在LayerMask这一变量里要输2的九次方，也就是512……</p><p>这个原因是Unity中以二维矩阵对LayerMask进行存储，所以要进行位运算。</p><p>我也针对这个写两个方法：</p><p>（1）public一个LayerMask然后在Inspector里面给它挂图层</p><p>（2）可以改写成<code>LayerMask.GetMask(&quot;这里写图层名字&quot;);</code></p><h4 id="6-5-你这LayerMask只能测一个图层？"><a href="#6-5-你这LayerMask只能测一个图层？" class="headerlink" title="6.5.你这LayerMask只能测一个图层？"></a>6.5.你这LayerMask只能测一个图层？</h4><p>如果你在<code>LayerMask.GetMask(&quot;&quot;);</code>前加~，这代表除了这个图层以外全部检测。这样射线检测就会绕过你指定的图层检测别的图层。</p><h4 id="7-（因为重中之重一定要写最后）"><a href="#7-（因为重中之重一定要写最后）" class="headerlink" title="7.（因为重中之重一定要写最后）"></a>7.（因为重中之重一定要写最后）</h4><p><strong>一定要加上collider组件！！！</strong></p><p>因为射线检测也是变相的射线和物体进行碰撞<del>（好吧这是我瞎编的）</del>，所以务必加collider组件！</p><p>你可以让射线检测没有trigger的，但是绝不能检测没有加collider组件的。</p><h3 id="咋应用的捏？"><a href="#咋应用的捏？" class="headerlink" title="咋应用的捏？"></a>咋应用的捏？</h3><p>按照上面的说法，我们根本无法实现拿鼠标点击物体看属性的功能。因为射线只能给一个物体，鼠标怎么整呢？</p><p>我们直接整一个复杂的情景：</p><p>假如你是李华，你在某模拟经营类游戏（类似冰汽时代）要在某个崎岖不平的地上造建筑，需要在光标上预览建筑造好后怎么样。所以你光标在哪里建筑要跟到哪里，同时遇到山你的建筑要有些倾斜。</p><p>接下来我们就来解决这个问题（以下脚本要挂载到你要放的物体上）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void FixedUpdate()&#123;</span><br><span class="line">    Ray ray=Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">    /*把鼠标在屏幕坐标上面的位置通过ScreenPointToRay方法转化为Ray射线类型（世界坐标系），因为屏幕坐标并不是世界系的坐标。这样射线从相机为起点向鼠标所在的方向延伸*/</span><br><span class="line">    if(Physics.Raycast(ray,out RaycastHit hitInfo,Mathf.Infinity))&#123;</span><br><span class="line">        //这里直接把检测距离改成无限</span><br><span class="line">        transform.position=hitInfo.point;</span><br><span class="line">       //这样物体会一直跟着射线交界点，也就是我们的鼠标</span><br><span class="line">        transform.rotation=Quaternion.FromToRotation(Vector3.up,hitInfo.normal);</span><br><span class="line">        //让物体的旋转角度迎合地面的角度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么做可能会有一个严重的问题：你的建筑会一直朝镜头飞。</p><p><img src="%E9%A3%9E.gif" alt="飞" loading="lazy"></p><p>原因很简单：你检测的是第一个碰撞体。而如果你的建筑有碰撞体，检测到的碰撞体不是地面而是你的建筑。这样point就一直是你的前面，就会一直朝建筑飞。</p><p>解决的方法有两种：</p><p>1.把建筑的碰撞体关了，然后建好了碰撞体开开</p><p>2.调整图层，把地面放到单独的图层里</p><p>这么做还有个不太严重的问题：建筑一半会陷进地面里。</p><p><img src="%E8%B5%B0.gif" alt="走" loading="lazy"></p><p>因为你的建筑位置坐标是你建筑的中心坐标，也就是point坐标。</p><p>解决方法也很简单，在上面做个空物体，把该物体上移建筑的半格，把它作为空物体的子物体，就可以了。这样它的坐标变成了空物体的中心坐标，也就是建筑的底部。</p><p>后面确认建造可以写：</p><p><code>Instantiate(prefab,transform.position,transform.rotation);</code></p><p>其实射线检测在3D世界上还有很多应用：</p><p>1.就Unity官方给出的例子来看，可以确定空投物资的降落伞什么时候打开：通过在物资下做一条有距离限制的射线检测，一检测到地面就开降落伞。</p><p>。。。<del>（你省略害搁着打个1.干嘛）</del></p><p>3D好像也没啥讲的了，就这么多把</p><h2 id="2D世界中的射线检测"><a href="#2D世界中的射线检测" class="headerlink" title="2D世界中的射线检测"></a>2D世界中的射线检测</h2><h3 id="咋检测的捏？-1"><a href="#咋检测的捏？-1" class="headerlink" title="咋检测的捏？"></a>咋检测的捏？</h3><p>2D和3D的代码是类似的，2D代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Physics2D.Raycast(Vector2 origin,Vector2 direction,float distance,int LayerMask,float minDepth,float maxDepth);</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector2表示</span><br><span class="line">//direction：射线的方向，因为是方向坐标所以使用Vector2表示</span><br><span class="line">//distance:射线检测的距离，虽然说射线的长度是无限长，但是可以设置它的检测距离，只有在这个距离内的物体才可以被检测到</span><br><span class="line">//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用</span><br><span class="line">//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷</span><br></pre></td></tr></table></figure><p>看似只是在Physics后面加了2D，但实际上2D和3D是有很多区别的<del>（不然也不会特地做一个部分了）</del>。</p><h4 id="0-Z轴，寄！"><a href="#0-Z轴，寄！" class="headerlink" title="0.Z轴，寄！"></a>0.Z轴，寄！</h4><p>首先最明显的就是z轴没有用了：<code>transform.forward</code>指向z轴方向，所以在2D的场景里只会指向屏幕内，根本就没有了作用。</p><h4 id="1-Ray，寄！"><a href="#1-Ray，寄！" class="headerlink" title="1.Ray，寄！"></a>1.Ray，寄！</h4><p>上文提到过，Ray这个类是由两个Vector3变量构造而成的，而2D世界都是Vector2，自然Ray这个类就与2D无缘了，只能用俩Vector2变量表示了。</p><h4 id="2-返回类型（作为方法最明显的不同了属于是）"><a href="#2-返回类型（作为方法最明显的不同了属于是）" class="headerlink" title="2.返回类型（作为方法最明显的不同了属于是）"></a>2.返回类型（作为方法最明显的不同了属于是）</h4><p>不像3D的返回类型是一个布尔类型的变量，2D返回的是RaycastHit2D的结构体类型。这个结构体类型和3D的结构体类型相似，也是储存着射线的相关信息以及检测到的碰撞体信息。比如说<code>point</code>就储存射线和碰撞体交汇的坐标，很是方便。</p><h4 id="3-小tips"><a href="#3-小tips" class="headerlink" title="3.小tips"></a>3.小tips</h4><p>在现实的游戏中，发出射线检测的物体基本都是具有碰撞体的（比如怪物或者炮台什么的）。这就引发了一个问题：当从物体中心点发出时，检测到的第一个碰撞体却是自己，射线根本出不去。那我们该怎么解决这个问题呢？答案是<code>Physics2D.queriesStartInColliders=false;</code>queries:询问，start:开始，incolliders:在碰撞体内。这样如果碰撞体是我们射线所在起点的内部时，我们不让它返回该碰撞体。这样就可以完美解决问题了。</p><h4 id="4-还有两种重载。。。"><a href="#4-还有两种重载。。。" class="headerlink" title="4.还有两种重载。。。"></a>4.还有两种重载。。。</h4><p>但用的少而且比较复杂，就不在这里延申了。</p><h4 id="5-（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）"><a href="#5-（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）" class="headerlink" title="5.（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）"></a>5.（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）</h4><p><strong>一定要加上collider组件！！！</strong></p><p>因为射线检测也是变相的射线和物体进行碰撞<del>（好吧这是我瞎编的）</del>，所以务必加collider组件！</p><p>你可以让射线检测没有trigger的，但是绝不能检测没有加collider组件的。</p><p><strong>其它的就没了</strong></p><h3 id="咋应用的捏？-1"><a href="#咋应用的捏？-1" class="headerlink" title="咋应用的捏？"></a>咋应用的捏？</h3><p>还是整一个复杂的例子：</p><p>你想在TopDown游戏（比如元气骑士）中做一个激光束，激光束打到墙面会被墙面阻隔，打到人身上会掉血（为了方便直接写了GameOver）。而我们要从游戏视觉到内部判定上把这个功能实现出来。</p><h4 id="内部判定"><a href="#内部判定" class="headerlink" title="内部判定"></a>内部判定</h4><p>内部判定很简单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void Detect()</span><br><span class="line">&#123;</span><br><span class="line">    //进行射线检测并将结果进行储存</span><br><span class="line">    RaycastHit2D hitInfo=Physics2D.Raycast(transform.position,-transform.right,maxDist,max);</span><br><span class="line">    //如果射线检测检测到了东西（因为检测到了东西有碰撞体就不会是null了）</span><br><span class="line">    if(hitInfo.collider!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Player&quot;)</span><br><span class="line">            //如果检测到的是player（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            GameOver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视觉实现（LineRenderer组件）"><a href="#视觉实现（LineRenderer组件）" class="headerlink" title="视觉实现（LineRenderer组件）"></a>视觉实现（LineRenderer组件）</h4><p>检测方面还是好写的。但如果我们要在实际的游戏画面中也要把这条射线给显示出来，使用DrawLine和DrawRay方法是无法胜任的。因为它们只能在Scene窗口内看到一条辅助线，而不是Game窗口里。</p><p>针对这个方法，我们可以使用Unity自带的LineRenderer来实现：</p><p><img src="Line.png" alt="LineRenderer位置在这里" loading="lazy"></p><p>LineRenderer是用于在游戏场景内对一条线段进行渲染。它的主要参数有很多，我们只讲几个重要的：</p><p><img src="LineRenderer.png" alt="内部格式" loading="lazy"></p><h5 id="（1）Position"><a href="#（1）Position" class="headerlink" title="（1）Position"></a>（1）Position</h5><p>众所周知，两点确定一条线段，而Position里面的两个index就是两个点的位置。index1是线段的起点，而index2则是线段的终点。</p><p>这里有个<code>SetPosition</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LineRenderer.SetPosition(int index,Vector3 position);</span><br><span class="line">//功能是设置LineRenderer的起始点和终点。index为Position里的序列号（如果是1就代表是index1），position为终点。</span><br></pre></td></tr></table></figure><h5 id="（2）-Width"><a href="#（2）-Width" class="headerlink" title="（2） Width"></a>（2） Width</h5><p>对线段的宽度进行设置。因为Width是一条线，所以你可以控制线段上的每一个点的粗细<del>（什么金箍棒）</del></p><h5 id="（3）Color"><a href="#（3）Color" class="headerlink" title="（3）Color"></a>（3）Color</h5><p>对线段的颜色进行设置。但因为是线段，所以你可以设置一个渐变的颜色，甚至是某些位置的透明度<del>（哇哦，好几把炫酷）</del></p><p>而这个颜色的类名也不能是<code>Color</code>了，而是<code>Gradient</code>（渐变色）</p><h5 id="（4）End-CapVertices"><a href="#（4）End-CapVertices" class="headerlink" title="（4）End CapVertices"></a>（4）End CapVertices</h5><p>对线段末端的圆滑度进行设置。如果这个数值是0，那线段末端就是一个正方。如果这个数值越大，末端也会更加圆滑，最后趋近于一个半圆。</p><h5 id="5-Use-World-Space"><a href="#5-Use-World-Space" class="headerlink" title="(5)Use World Space"></a>(5)Use World Space</h5><p>将Position里的坐标转化为世界坐标。不勾选这个的话我们就无法正确的让线段显示出来。</p><p>有了这个，视觉方面就好做了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private LineRenderer lineRenderer;</span><br><span class="line">//声明LineRenderer组件的变量</span><br><span class="line"></span><br><span class="line">private void Awake()&#123;</span><br><span class="line">    lineRenderer=GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">    //如果LineRenderer组件物体是脚本挂载的子物体，那我们可以直接使用GetComponentInChildren方法。但是这个方法只会获取第一个发现的组件而不是所有子物体的组件。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Detect()</span><br><span class="line">&#123;</span><br><span class="line">    //进行射线检测并将结果进行储存</span><br><span class="line">    RaycastHit2D hitInfo=Physics2D.Raycast(transform.position,-transform.right,maxDist,max);</span><br><span class="line">    //如果射线检测检测到了东西（因为检测到了东西有碰撞体就不会是null了）</span><br><span class="line">    if(hitInfo.collider!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Wall&quot;)</span><br><span class="line">            //如果检测到的是Wall（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            lineRenderer.SetPosition(1,hitInfo.point);</span><br><span class="line">        &#125;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Player&quot;)</span><br><span class="line">            //如果检测到的是player（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            lineRenderer.SetPosition(1,hitInfo.point);</span><br><span class="line">            GameOver();</span><br><span class="line">        &#125;</span><br><span class="line">        lineRenderer.SetPosition(0,transform.position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就差不多了。</p><h2 id="射线检测的一些缺点"><a href="#射线检测的一些缺点" class="headerlink" title="射线检测的一些缺点"></a>射线检测的一些缺点</h2><h3 id="射线检测，寄！"><a href="#射线检测，寄！" class="headerlink" title="射线检测，寄！"></a>射线检测，寄！</h3><p>在讲了这么多射线检测后，我还是想要明确一下射线检测的缺陷：在检测的范围不是一根线段而是一个面积的图形时，射线检测就显得有些见襟捉肘。比如说：我想在平台跳跃游戏中使用射线检测检测玩家是否与地面相碰。因为如果我们不这么做玩家就可以无限按跳跃键达到飞天的效果(bushi。在这里使用射线检测就会造成一些问题：</p><p><img src="%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.png" alt="发生肾么事了" loading="lazy"></p><p>如图，玩家依旧在地板上，但是由于中间超过一半部位已经离开了地板，导致在玩家中心点往下的射线检测并没有检测到地板。这样的结果就是玩家在这个地方本来可以跳却跳不起来。我们想要检测一定范围内的碰撞体，而射线检测却无法达到这个效果。</p><p>难道，就没有办法了吗？</p><h3 id="OverLap的妙用"><a href="#OverLap的妙用" class="headerlink" title="OverLap的妙用"></a>OverLap的妙用</h3><p>面对这个问题，Unity自然有解决方法：那就是OverLap方法。它的功能和射线检测大致类似，但是它并不是产生一条射线，而是产生一个形状，比如圆形(<code>OverLapCircle</code>)，方形(<code>OverLapBox</code>)等。这些方法的区别仅仅是形状不一样，而其他都是大致相同的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collider2D collider=Physics2D.OverLapCircle(Vector2 point, float radius, int layerMask, float minDepth, float maxDepth);//point:圆心的点所在坐标，因为是位置坐标所以使用Vector2表示//radius：圆的半径//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷Collider2D OverlapBox=Physics2D.OverLapBox(Vector2 point, Vector2 size, float angle, int layerMask, float minDepth, float maxDepth);//point:长方体中心点所在坐标，因为是位置坐标所以使用Vector2表示//size：长方体的长和宽，因为要有长和宽两个数所以使用Vector2表示//angle:长方体要倾斜的角度//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷</span><br></pre></td></tr></table></figure><p>方法和射线检测类似，但是又有些许的不同，比如：</p><h4 id="1-返回值不一样"><a href="#1-返回值不一样" class="headerlink" title="1.返回值不一样"></a>1.返回值不一样</h4><p>OverLap的返回值是collider2D，也就是碰撞体，不像射线检测是返回hitInfo那种结构体了。</p><h4 id="2-适用范围不一样"><a href="#2-适用范围不一样" class="headerlink" title="2.适用范围不一样"></a>2.适用范围不一样</h4><p>看到Physics2D也知道，OverLap只适用于2D世界，而不是2D、3D全适用了。</p><p>通过这个方法，我们可以在玩家碰撞体的正下面做一个OverLap检测，这样就可以完美解决跳跃检测的问题了。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="如何像DrawLine那样显示出整个检测范围？"><a href="#如何像DrawLine那样显示出整个检测范围？" class="headerlink" title="如何像DrawLine那样显示出整个检测范围？"></a>如何像DrawLine那样显示出整个检测范围？</h4><p>答案是使用gizmos:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void OnDrawGizmos()&#123;    Gizmos.DrawWireSphere(transform.position,radius);    Gizmos.Color=Color.Red;&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么平台跳跃中贴着墙掉不下去？"><a href="#为什么平台跳跃中贴着墙掉不下去？" class="headerlink" title="为什么平台跳跃中贴着墙掉不下去？"></a>为什么平台跳跃中贴着墙掉不下去？</h4><p>答案是所有碰撞体和刚体的材质都默认有摩擦力，只要你新建一个物理材质然后把摩擦力调整为0然后挂载到墙壁的刚体上就不会这样了。</p><h4 id="如何检测该形状范围内的所有碰撞体？"><a href="#如何检测该形状范围内的所有碰撞体？" class="headerlink" title="如何检测该形状范围内的所有碰撞体？"></a>如何检测该形状范围内的所有碰撞体？</h4><p>答案是OverLap***All方法，这个方法和之前射线检测的一样，可以返回所有碰撞体.</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>射线检测在Unity游戏制作中还是十分重要的。但和碰撞检测不同，射线检测在2D和3D的世界使用方面上还是有着不同的。并且，由于射线检测仅仅是一条射线的范围，在某些游戏某些功能的实现上还是有着局限性。为此OverLap这种可以检测一定范围的方法可以更加胜任这些工作。在文中2D中射线检测以及OverLap的介绍并没有3D中的那么详细，这是因为避免文章的重复性。基本上3D部分提到但是2D和OverLap没有提到的功能和注意在2D和OverLap上也是适用的。比如这些检测方法都需要碰撞体，都可以采用在后面加All的方法检测范围内的所有碰撞体的物体，LayerMask是int等等，还望大家谅解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity中如何设置游戏存档方法归纳</title>
    <link href="http://example.com/2021/06/26/Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3/"/>
    <id>http://example.com/2021/06/26/Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3/</id>
    <published>2021-06-26T03:42:20.000Z</published>
    <updated>2022-01-07T10:24:54.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1399789328&auto=1&height=66"></iframe><p>最近属实有点忙（如果打游戏也算忙的话），一直拖到了放假第一个礼拜结束。。。</p><p>所以我决定不咕了！写一篇unity存档的东西出来！<del>（其实是实在没事情干了）</del></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        众所周知，存档在许多游戏中已经成为了不可或缺的一部分，先不论联机的网络游戏，一些长流程游戏，比如黑帝斯，空洞骑士等（让我咕的万恶之源属于是），这样不存档让玩家连续花30+个小时甚至更久属实是让玩家坐牢，变成了班尼特福德之类的阴间游戏。这不仅对玩家是坐牢，对测试游戏的人更是一种全新的坐牢体验：要是要测试后面的关卡有没有bug，那就一定要把前面的打了，然后测出了bug游戏运行不了改了bug要重新来，想想就离谱。但如果拿特定的存档进去测试那肯定少了很多时间和精力。</p><p>综上所述，单机游戏存档的好处如下：</p><p><strong>1.长流程游戏可以让玩家分几次体验，失败了也可以重新读档，减少了玩家的坐牢体验</strong></p><p><strong>2.测试时可以直接进入特定地点进行测试，不需要从头打起不断被自己的粪作ex到</strong></p><p><strong>3.肯定还有但我懒得想了</strong></p><p>对此，Unity有这几种方法进行游戏存档：</p><h2 id="PlayerPrefs的妙用"><a href="#PlayerPrefs的妙用" class="headerlink" title="PlayerPrefs的妙用"></a>PlayerPrefs的妙用</h2><p>对于存档，Unity特别在脚本里提供了PlayerPrefs类的方法。它的方法是提供给玩家int，float，string三个类型进行储存与修改。每一个变量名都对应这一个值，也就是键值对，类似于字典类型。这三个类型的变量名和值都是直接储存在文件里的，所以可以达到储存轻量数据的可能。</p><p>相关代码也很简单，具体是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetString(&quot;Name&quot;,name); //储存string类变量</span><br><span class="line">PlayerPrefs.SetFloat(&quot;Name&quot;,name); //储存float类变量</span><br><span class="line">PlayerPrefs.SetInt(&quot;Name&quot;,name); //储存int类变量</span><br><span class="line">//这三个的意思是：创建名字叫Name的变量在PlayerPrefs里，</span><br><span class="line">//同时他们的值和name相等（当然name也可以直接打float,int,string类型的常量）</span><br><span class="line">Str=PlayerPrefs.GetString(&quot;Name&quot;); //读取string类变量并存在Str里</span><br><span class="line">I=PlayerPrefs.GetInt(&quot;Name&quot;); //读取int类变量并存在I里</span><br><span class="line">F=PlayerPrefs.GetFloat(&quot;Name&quot;); //读取float类变量并存在F里</span><br><span class="line">//如果不存在Name，那么会返回0</span><br><span class="line">PlayerPrefs.DeleteAll(); //删除所有键和值</span><br><span class="line">PlayerPrefs.DeleteKey(&quot;Name&quot;); //删除Name的键和值</span><br><span class="line">PlayerPrefs.HasKey(&quot;Name&quot;); //判断是否存在Name这个键并返回true或者false</span><br></pre></td></tr></table></figure><p>这些代码虽然很简单，但是只能存储三个类型而且不能做成一个类，所以只能用在一些简单的存储，比如简单变量和玩家设置里，比如获得金币钻石数量啊，开不开bgm啊（开了就setint为1，然后每次进游戏getint判断是不是1，是了就开）什么的。当然如果你硬要存储玩家数据也不是不可以，就是有种拿水果刀杀牛的感觉（<del>别问我为什么不是鸡刀，你见过鸡刀吗）</del>，不太值得属于是。</p><p><strong>注意：</strong></p><p><strong>因为是存在文件里，所以你Unity调试也是运行了PlayerPrefs的代码里的，所以在停止调试后PlayerPrefs的改变不会变回来捏</strong></p><p>（通俗一点就是你调试时setint把0改成1，终止调试时那个值还是1而不是0辣，讲那么多干嘛）</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>每个字单独我都认识，咋连起来就不认识了捏？容我细说：</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="序列化-Serialization-和反序列化-Deserialization"><a href="#序列化-Serialization-和反序列化-Deserialization" class="headerlink" title="序列化(Serialization)和反序列化(Deserialization)"></a>序列化(Serialization)和反序列化(Deserialization)</h4><p>在Unity中，序列化的概念为：<strong>将[对象的状态信息]转化为[Unity可以储存的形式]的自动化处理过程</strong></p><p>那反序列化自然是：<strong>将[Unity可以储存的形式]转化为[对象的状态信息]的自动化处理过程</strong></p><p>从广义上来说，[对象的状态信息]可以被说成[对象]，而[Unity可以储存的形式]就是[可传输的字节序列]。说白了，序列化就是将Unity的文件或者脚本（对象的状态信息）转化为二进制的形式（也就是一群读不懂的数字加字母），存储在数据库，内存或者文件中（Unity可以储存的形式），也就是游戏里的“保存游戏”按钮，而反序列化则是“读取游戏”。和其他的方法不同，这些数据会以二进制的形式存储在游戏的data.txt里。</p><p>序列化最简单的使用方式是让脚本内private变量的值在Inspector面板里显示出来。众所周知（？？？），脚本内的public变量都会经过序列化出现在inpector面板上，而private则不会。而要想显示出来，就要在命名上方加上<code>[SerializeField]</code>，表示变量可被序列化（私以为其中原理应该是让Unity的Inspector面板保存数据）。具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SerializedField]</span><br><span class="line">private int i;</span><br></pre></td></tr></table></figure><p>接下来将会介绍Unity为此特制的三个类，它们分别为：</p><h4 id="File类，FileStream类和BinaryFormatter类"><a href="#File类，FileStream类和BinaryFormatter类" class="headerlink" title="File类，FileStream类和BinaryFormatter类"></a>File类，FileStream类和BinaryFormatter类</h4><h5 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h5><p>文件类，即用来对文件进行基本操作，比如说创建、复制、剪切、打开等，可以直接赋值到后面的FileStream类</p><p><strong>太长不看版：操作文件的</strong></p><p><strong>在使用该类前，请注意使用<code>System.IO</code>的命名空间</strong>（IO肯定是input,output辣）,也就是：<code>using System.IO</code></p><h5 id="FileStream类"><a href="#FileStream类" class="headerlink" title="FileStream类"></a>FileStream类</h5><p>文件流类，即用来读取、写入操作系统文件的，可以进行读取、写入、保存、关文件流的功能，可以把文件转化为字节流的形式</p><p><strong>注意：干完活记得把文件流关了，File类可以直接赋值FileStream类</strong></p><p><strong>在使用该类前，请注意使用<code>System.IO</code>的命名空间</strong>（IO肯定是input,output辣）,也就是：<code>using System.IO</code></p><p>综上所述呢，我们可以把文件看成包裹，对包裹本身的操作，比如创建个包裹，移动个包裹什么的就用File类，但是如果要对包裹里面的东西进行操作，那就得使用FileStream了。</p><h5 id="BinaryFormatter类"><a href="#BinaryFormatter类" class="headerlink" title="BinaryFormatter类"></a>BinaryFormatter类</h5><p>Binary的意思是二进制，而Formatter则是格式化程序，那干什么自然不用我说了，就是<strong>以二进制的形式对对象进行序列化和反序列化</strong>。</p><p><strong>在使用该类前，请注意使用<code>System.Runtime.Serialization.Formatters.Binary</code>的命名空间</strong>,也就是：<code>using System.Runtime.Serialization.Formatters.Binary</code></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>首先创建一个c#脚本命名为Save（名字随便啥都可以）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[System.Serializable] //直接告诉Unity这个类可被序列化</span><br><span class="line">public class Save //不要MonoBehaviour，因为直接作为一个类，不需要挂物体上</span><br><span class="line">&#123;</span><br><span class="line">    public int coins;</span><br><span class="line">    public float playerPositionX;</span><br><span class="line">    public float playerPositionY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们可以在另一个脚本里写下这些方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line">using System.IO;</span><br><span class="line">//命名空间肯定不止这么少，就是打出来提醒一下</span><br><span class="line"></span><br><span class="line">public Save CreateSave()&#123; //创建一个Save对象存储当前游戏数据</span><br><span class="line">    Save save=new Save();</span><br><span class="line">    save.Coins=GameManager.Instance.coins;</span><br><span class="line">    save.playerPositionX=player.transform.position.x;</span><br><span class="line">    save.playerPositionY=player.transform.postion.y;</span><br><span class="line">    return Save;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void SaveBySerialization()&#123;</span><br><span class="line">    Save save=CreateSave();</span><br><span class="line">    //获取当前的游戏数据存在Save对象里</span><br><span class="line">    BinaryFormatter bf=new BinaryFormatter();</span><br><span class="line">    //创建一个二进制形式</span><br><span class="line">    FileStream  fs=File.Create(Application.persistentDataPath+&quot;/Data.yj&quot;);</span><br><span class="line">    //这里指使用持久路径创建一个文件流并将其保存在Data.yj里（具体在哪就不打了，反正创建了）</span><br><span class="line">    //由于持久路径在Windows系统是隐藏的，所以无法找到Data.yj本身</span><br><span class="line">    //如果想看到，可以改成dataPath(就像下文json的代码里一样)</span><br><span class="line">    //文件后缀可以随便改，甚至是自定义的（比如我这里用了yj）</span><br><span class="line">    bf.Serialize(fs,save);</span><br><span class="line">    //将Save对象转化为字节</span><br><span class="line">    fs.Close();</span><br><span class="line">    //把文件流关了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了序列化（保存）的全过程：</p><p><strong>创建一个二进制格式化对象-&gt;新建文件流-&gt;序列化Save对象-&gt;关闭文件流</strong></p><p>接下来就是读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void LoadByDeserialization()&#123;</span><br><span class="line">    if(File.Exists(Application.persistentDataPath+&quot;/Data.yj&quot;))</span><br><span class="line">    //判断文件是否创建</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryFormatter bf=new BinaryFormatter();</span><br><span class="line">        FileStream fs=File.Open(Application.persistentDataPath+&quot;/Data.yj&quot;,FileMode.Open);//打开文件</span><br><span class="line">        Save save=bf.Deserialize(fs) as Save;</span><br><span class="line">//反序列化并将数据储存至save（因为返回变量类型不对，所以要强制转换为Save类</span><br><span class="line">        fs.Close();</span><br><span class="line">//关文件流</span><br><span class="line">        GameManager.Instance.coins=save.coins;</span><br><span class="line">        player.transform.position=new Vector2(save.playerPositionX,save.playerPositionY);</span><br><span class="line">//赋值</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Debug.LogError(&quot;Data Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，一个简单的游戏存档就做好了，这些方法可以挂载在按钮或者特定场景上，使得可以正常进行存档读档的操作。如果你想储存场景内的怪物数据的话，建议使用vector类型进行存储呢，比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;save.isDead.Count;i++)&#123;</span><br><span class="line">    if(GameManager.instance.enemies[i]==null)&#123;</span><br><span class="line">        if(!save.isDead[i])//如果敌人在我们保存之后死了</span><br><span class="line">        &#123;</span><br><span class="line">            float enemyPosX=save.enemyPositionX[i];</span><br><span class="line">            float enemyPosY=save.enemyPositionY[i];</span><br><span class="line">            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);</span><br><span class="line">            GameManager.Instance.enemies[i]=newBat;</span><br><span class="line">            //把本该活着的敌人数据进行填充</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            float enemyPosX=save.enemyPositionX[i];</span><br><span class="line">            float enemyPosY=save.enemyPositionY[i];</span><br><span class="line">            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建的类也应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[System.Serializable] //直接告诉Unity这个类可被序列化</span><br><span class="line">public class Save //不要MonoBehaviour，因为直接作为一个类，不需要挂物体上</span><br><span class="line">&#123;</span><br><span class="line">    public int coins;</span><br><span class="line">    public float playerPositionX;</span><br><span class="line">    public float playerPositionY;</span><br><span class="line">    </span><br><span class="line">    public List&lt;float&gt; enemyPositionX=new List&lt;float&gt;();</span><br><span class="line">    public List&lt;float&gt; enemyPositionY=new List&lt;float&gt;();</span><br><span class="line">    public List&lt;bool&gt; isDead=new List&lt;bool&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>序列化和反序列化看似很好解决了大量数据存储的问题，但是你要想啊，序列化以后的文件全是二进制，这鬼也看不懂啊（除了计算机捏），那修改也更是问题。那有没有什么序列化以后属于一个人能看懂的东西捏？这就要看：</p><h2 id="另一种序列化方式——JSON"><a href="#另一种序列化方式——JSON" class="headerlink" title="另一种序列化方式——JSON"></a>另一种序列化方式——JSON</h2><p>{json}，搁着一看还以为是jvavscript(js)，那它如何来实现存档读档呢？还是从概念入手把</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON，全称是JavaScript对象表示法（JavaScript Object Notation），它主要是用来在客户端和服务端进行交互数据的，它属于轻量级语言。它的格式以”键值对“的形式作为展示，而且键的名字可以自己定义，不理解的可以看看下面：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Save=&#123;<span class="comment">//大括号表示对象</span></span><br><span class="line">    <span class="attr">&quot;coins&quot;</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;playerPositionX&quot;</span>:<span class="number">10.866</span>,</span><br><span class="line">    <span class="attr">&quot;playerPositionY&quot;</span>:<span class="number">-21</span>,</span><br><span class="line">    <span class="attr">&quot;isDead&quot;</span>:[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>] <span class="comment">//中括号表示数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json由两部分构成：一个是键名(Key)，也就是变量的名字，是String类型的；另一个就是值(value)，它可以是int,bool,float,数组,甚至是对象类型。它们组合在一起，也就是上文所说的”键值对“(Key Value Pair)，有点字典内味了哈（字典也是键值对啊kora）。而json文件本身也是String类型的文本。</p><p>看到这里也应该明白json和js的区别了<del>（你认真的？？？）</del>：JavaScript是一种程序语言，而json则是一种数据格式，一种语法。因为它没有使用任何函数或者命令，仅仅是以文字为基础，易于阅读和编写，作为数据交换语言显然很适合。虽然JavaScript里自带方法可以让js和json互相转化，但本质上两者还是不属于一个东西。</p><p>虽然可以使用js可以和json互相转化，但是Unity的语言是C#啊。。。不过不用担心，Unity也有相应的方法让json可以和C#相互转化(JsonUtility类)。而下文也是通过这种方式实现的。</p><p><strong>提示：</strong>其实可以通过库进行json数据的解析，比如.Net库的Json.Net和LitJson.dll。之所以使用JsonUtility类是因为它是Unity自带的，而且解析更快，产生的垃圾更少。</p><h4 id="流写入类-StreamWriter类"><a href="#流写入类-StreamWriter类" class="headerlink" title="流写入类(StreamWriter类)"></a>流写入类(StreamWriter类)</h4><p>和FileStream类差不多，也是对系统文件进行写入的（没有读取功能捏），但是FileStream类读取的是字节数组，适用于非文本文件，所以不太适合读取String类型的JSON文件</p><p><strong>注意：写完也记得把流关了</strong></p><h4 id="流读取类-StreamReader类"><a href="#流读取类-StreamReader类" class="headerlink" title="流读取类(StreamReader类)"></a>流读取类(StreamReader类)</h4><p>和FileStream类差不多，也是对系统文件进行读取的（没有写入功能捏），但是FileStream类读取的是字节数组，适用于非文本文件，所以不太适合读取String类型的JSON文件</p><p><strong>注意：写完也记得把流关了</strong></p><p><del><em>就是复制粘贴改了的，略略略</em></del></p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//不需要加别的命名空间，简直爽死(bushiprivate void SaveByJSON()&#123;Save save= CreateSave();    //创建一个Save实例存储游戏数据(CreateSave函数在上面)    String JsonString=JsonUtility.ToJson(save);    //将对象save转化为json字符串    //上面说了Json是string类型，所以命名string    StreamWriter sw=new StreamWriter(Application.dataPath+&quot;/Data.yj&quot;);//persistentDataPath是隐藏文件的，所以你找不到Data.yj的所在地，//而dataPath就不会隐藏，同时文件后缀也可以乱取    sw.Write(JsonString);//将json字符串写入流参数    sw.Close();//把流关了&#125;private void LoadByJSON()&#123;    if(File.Exists(Application.dataPath+&quot;Data.yj&quot;))    //判断文件是否创建    &#123;        StreamReader sr=new StreamReader(Application.dataPath+&quot;/Data.yj&quot;);        //从流中读取字符串        String JsonString=sr.ReadToEnd();//ReadToEnd()方法可以读取从流当前位置到结尾的所有字符//还有Read()方法，但是只读了一个字符，还有更多方法捏懒得打了        sr.Close();//把流关了        Save save=JsonUtility.FromJson&lt;Save&gt;(JsonString);//该方法属于泛型方法T，需要给出明确的类型定义，所以要写&lt;Save&gt;        GameManager.Instance.coins=save.coins;        player.transform.position=new Vector2(save.playerPosition.x,save.playerPositionY);        //属于是常规方式了    &#125;    else&#123;        Debug.LogError(&quot;File Not Found.&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们使用json完成了游戏的存档和读档操作</p><h5 id="小贴士："><a href="#小贴士：" class="headerlink" title="小贴士："></a>小贴士：</h5><p>json方法里的泛型和强制转换属于两码事，前者是一个方法，可以满足多个类型的实现(但是要使用&lt;&gt;标明类型)而后者只能完成一个类型，所以需要在前面加括号，或者使用as对错误的类型进行强制转换</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>json看似完美的解决了文件可读性的问题（如果我们打开文件，看到的便是json本来的文本样式），但是json背后还是有着缺点：当在人机都需要识别数据时（比如说配置文件），json的可读性也会变得差，如果你要储存复杂场景，比如树的坐标，比如草的坐标，那一堆堆的数组表示的坐标肯定看得你想要坐牢。在这里提醒一下，当你打开json文件时，里面可不会有换行符一行行给你打的清楚，而是全部拧成了一团。那么，有没有一种文件保存类型，既可以在Unity里保存和读取数据，也可以具有良好的结构性和描述性呢？那就是最后一个我要介绍的最后一个类型：</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><h4 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h4><p>XML，意思是可扩展标记语言（eXtensible Markup Language）。为什么不叫EML呢？因为这样和eml（发邮件的文件后缀格式）重名了。。。</p><p>咳咳，言归正传，它专门被设计用来结构化“存储”和”传输“数据或者信息。它可以在不兼容的系统之间轻松交换数据，简化数据共享。而且，XML数据以纯文本方式进行存储（本质就是字符串），可以给任何阅读设备使用。</p><p>有些人听着可能觉得：这不就是html🐎？事实上两者确实是有区别的：html主要显示网站上的内容（文字、图片等），事实上，我们文章一开头网易云音乐放的真夜的歌（\真夜/\真夜/\真夜/\真夜/\真夜/\真夜/）<del>（突发恶疾.jpg）</del>就是通过html实现的：</p><p>阿巴<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1399789328&auto=1&height=66"></iframe>阿巴</p><p>在一个网站中，HTML负责网页内容的显示，CSS负责内容的颜色和排版，javascript负责进行一些交互功能的实现。（这些是前端的知识了属于是）</p><p>而XML相比于HTML，XML更在意里面存储的信息。比如说XML里面的标签可以自定义，而HTML都是预先定义好的，所以XML更能胜任这个存档的职能。</p><p><strong>接下来就有点重要了：</strong></p><p>为什么我们说XML相比于json更具有结构性呢？这是因为XML中的每个元素形成了一个文档树。我们可以创建一个玩家的根节点或者敌人的根节点，然后把这些对象应该拥有的变量通过AppendChild的方式附录到根节点上。这样人们想要看玩家的数据，只要找到玩家的节点一个个看就可以了，而不要像json一样挤在一起，难以分辨。下面应用里我手打的XML应该可以体现这一点。</p><h4 id="XmlDocument类"><a href="#XmlDocument类" class="headerlink" title="XmlDocument类"></a>XmlDocument类</h4><p>用来保存，加载和解析XML文件，通过这个类可以对xml文件进行创建、保存、读取、添加以及删除。</p><p>不仅如此，这个类还有一个静态方法：<code>xmlDocument.CreateElement(&quot;node&quot;);</code>它可以在xml文档中创建一个“元素节点”（名字当然是自定义的，也就是标签），</p><p><strong>注意：使用XmlDocument类前需要引入<code>System.Xml</code>命名空间哟~</strong></p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System.Xml; //还是提醒一下private void SaveByXML()&#123;    Save save=CreateSave();    XmlDocument xmlDocument=new XmlDocument();        #region CreateXML elements            XmlElement root=XmlDocument.CreateElement(&quot;Save&quot;);    //创建一个参数名为&quot;Save&quot;的xml元素，这个元素名字叫root    //这么取在脚本里就更好理解了    root.SetAttribute(&quot;FileName&quot;,&quot;File_01&quot;);        XmlElement coinElement=xmlDocument.CreateElement(&quot;Coins&quot;);    coinElement.InnerText=save.coins.ToString();    //创建金币保存的元素，并将金币数以字符串形式导入    root.AppendChild(coinElement);    //将coinElement这一元素附录至根节点root上        XmlElement playerPositionXElement=xmlDocument.CreateElement(&quot;PlayerPositionX&quot;);    playerPositionXElement.InnerText=save.playerPositionX.ToString();    root.AppendChild(playerPositionXElement);    //接下来就是重复步骤：创建节点、储存数据、将节点附录至根节点        XmlElement playerPositionYElement=xmlDocument.CreateElement(&quot;PlayerPositionY&quot;);    playerPositionYElement.InnerText=save.playerPositionY.ToString();    root.AppendChild(playerPositionYElement);        #endregion    xmlDocument.AppendChild(root);    //最后要把根节点附录在文件上，以便于文件可以保存        xmlDocument.Save(Application.dataPath+&quot;DataXML.yj&quot;);    //把数据保存在文件“DataXML.yj”里    if(File.Exists(Application.dataPath+&quot;DataXML.yj&quot;))&#123;        Debug.Log(&quot;XML FILE SAVED&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>接下来，如果你保存了并且打开了DataXML.yj，里面会是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Save</span> <span class="attr">FileName</span>=<span class="string">&quot;File_01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Coins</span>&gt;</span>20<span class="tag">&lt;/<span class="name">Coins</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionX</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">PlayerPositionX</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionY</span>&gt;</span>-6<span class="tag">&lt;/<span class="name">PlayerPositionY</span>&gt;</span><span class="tag">&lt;/<span class="name">Save</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从这里我们就能看得很清楚了：在root节点（名字被我们命名为Save）下有三个子节点：Coins、PlayerPositionX、PlayerPositionY，它们都嵌套在了Save这个根节点下。相信通过这个更能理解XML文件的优越结构性了。</p><p>接下来就是读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void LoadByXML()&#123;    if(File.Exists(Application.dataPath+&quot;/DataXML.yj&quot;))    &#123;        Save save=new Save();                XmlDocument xmlDocument=new XmlDocument();        xmlDocument.Load(Applicatiom.dataPath+&quot;/DataXML.yj&quot;);        //创建并读取保存的XML文件        XmlNodeList coins=xmlDocument.GetElementsByTagName(&quot;Coins&quot;);        //寻找标签名称来找到保存在文件里的金币数        int coincount=int.Parse(coins[0].InnerText);        //MARKER 为什么是[0]呢？因为如果标签名为Coins的有很多的话，就会重复        //所以返回的是List集合类型，第一个为[0]，第二个为[1]        //将String类的金币数通过Parse转化为int并存进变量里        save.coins=coincount;        XmlNodeList positionX=xml.DocumentXGetElementsByTagName(&quot;positionX&quot;);        float positionXcount=float.Parse(positionX[0].InnerText);        save.playerPositionX=positionXcount;                XmlNodeList positionY=xml.Document.GetElementsByTagName(&quot;positionY&quot;);        float positionYcount=float.Parse(positionY[0].InnerText);        save.playerPositionY=positionYcount;                GameManager.instance.coins=save.coins;        player.transform.position=new Vector2(save.playerPositionX,save.playerPositionY);    &#125;    else    &#123;        Debug.LogError(&quot;NOT FOUND FILE&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样看XML可能还不太清楚，所以我打算在把敌人的数据也保存在XML里面，这样就得改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System.Xml; //还是提醒一下private void SaveByXML()&#123;    Save save=CreateSave();    XmlDocument xmlDocument=new XmlDocument();        #region CreateXML elements            XmlElement root=XmlDocument.CreateElement(&quot;Save&quot;);    //创建一个参数名为&quot;Save&quot;的xml元素，这个元素名字叫root    //这么取在脚本里就更好理解了    root.SetAttribute(&quot;FileName&quot;,&quot;File_01&quot;);        XmlElement coinElement=xmlDocument.CreateElement(&quot;Coins&quot;);    coinElement.InnerText=save.coins.ToString();    //创建金币保存的元素，并将金币数以字符串形式导入    root.AppendChild(coinElement);    //将coinElement这一元素附录至根节点root上        XmlElement playerPositionXElement=xmlDocument.CreateElement(&quot;PlayerPositionX&quot;);    playerPositionXElement.InnerText=save.playerPositionX.ToString();    root.AppendChild(playerPositionXElement);    //接下来就是重复步骤：创建节点、储存数据、将节点附录至根节点        XmlElement playerPositionYElement=xmlDocument.CreateElement(&quot;PlayerPositionY&quot;);    playerPositionYElement.InnerText=save.playerPositionY.ToString();    root.AppendChild(playerPositionYElement);        XmlElement enemy,enemyPositionX,enemyPositionY,isDead;    for(int i=0;i&lt;save.enemyPositionX.Count;i++)&#123;        enemy=xmlDocument.CreateElement(&quot;Enemy&quot;);        enemyPositionX=xmlDocument.CreateElement(&quot;EnemyPositionX&quot;);        enemyPositionY=xmlDocument.CreateElement(&quot;EnemyPositionY&quot;);        isDead=xmlDocument.CreateElement(&quot;IsDead&quot;);        enemyPositionX.InnerText=save.enemyPositionX[i].ToString();        enemyPositionY.InnerText=save.enemyPositionY[i].ToString();        isDead.InnerText=save.isDead[i].ToString();        enemy.AppendChild(enemyPositionX);        enemy.AppendChild(enemyPositionY);        enemy.AppendChild(isDead);        root.AppendChild(enemy);    &#125;        #endregion    xmlDocument.AppendChild(root);    //最后要把根节点附录在文件上，以便于文件可以保存        xmlDocument.Save(Application.dataPath+&quot;DataXML.yj&quot;);    //把数据保存在文件“DataXML.yj”里    if(File.Exists(Application.dataPath+&quot;DataXML.yj&quot;))&#123;        Debug.Log(&quot;XML FILE SAVED&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>而XML文档也会变成这个样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Save</span> <span class="attr">FileName</span>=<span class="string">&quot;File_01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Coins</span>&gt;</span>20<span class="tag">&lt;/<span class="name">Coins</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionX</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">PlayerPositionX</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionY</span>&gt;</span>-6<span class="tag">&lt;/<span class="name">PlayerPositionY</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-2.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>2<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>True<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-2.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>2<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>False<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-0.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>5<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>True<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>2<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>False<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-21<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>20<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>False<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span><span class="tag">&lt;/<span class="name">Save</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样看起来确实就很舒适了(相比于json文件)</p><p>在读取环节也要加一点东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void LoadByXML()&#123;    if(File.Exists(Application.dataPath+&quot;/DataXML.yj&quot;))    &#123;        Save save=new Save();                XmlDocument xmlDocument=new XmlDocument();        xmlDocument.Load(Applicatiom.dataPath+&quot;/DataXML.yj&quot;);        //创建并读取保存的XML文件        XmlNodeList coins=xmlDocument.GetElementsByTagName(&quot;Coins&quot;);        //寻找标签名称来找到保存在文件里的金币数        int coincount=int.Parse(coins[0].InnerText);        //MARKER 为什么是[0]呢？因为如果标签名为Coins的有很多的话，就会重复        //所以返回的是List集合类型，第一个为[0]，第二个为[1]        //将String类的金币数通过Parse转化为int并存进变量里        save.coins=coincount;        XmlNodeList positionX=xml.DocumentXGetElementsByTagName(&quot;positionX&quot;);        float positionXcount=float.Parse(positionX[0].InnerText);        save.playerPositionX=positionXcount;                XmlNodeList positionY=xml.Document.GetElementsByTagName(&quot;positionY&quot;);        float positionYcount=float.Parse(positionY[0].InnerText);        save.playerPositionY=positionYcount;        if(enemy.Count!=0)&#123;            for(int i=0;i&lt;enemy.Count;i++)&#123;                XmlNodeList enemyPositionX=xml.Document.GetElementsByTagName(&quot;EnemyPositionX&quot;);                float enemyPosX=float.Parse(enemyPositionX.InnerText);                save.enemyPositionX.Add(enemyPosX);//由于对象save中敌人坐标声明为List集合，所以需要List.Add进行数值的添加                XmlNodeList enemyPositionY=xml.Document.GetElementsByTagName(&quot;EnemyPositionY&quot;);                float enemyPosY=float.Parse(enemyPositionY.InnerText);                save.enemyPositionY。Add(enemyPosY);                XmlNodeList isDead=xml.Document.GetElementsByTagName(&quot;IsDead&quot;);            &#125;        &#125;                GameManager.instance.coins=save.coins;        player.transform.position=new Vector2(save.playerPositionX,save.playerPositionY);                for(int i=0;i&lt;save.isDead.Count;i++)&#123;    if(GameManager.instance.enemies[i]==null)&#123;        if(!save.isDead[i])//如果敌人在我们保存之后死了        &#123;            float enemyPosX=save.enemyPositionX[i];            float enemyPosY=save.enemyPositionY[i];            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);            GameManager.Instance.enemies[i]=newBat;            //把本该活着的敌人数据进行填充        &#125;else&#123;            float enemyPosX=save.enemyPositionX[i];            float enemyPosY=save.enemyPositionY[i];            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);        &#125;    &#125;&#125;    &#125;    else    &#123;        Debug.LogError(&quot;NOT FOUND FILE&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>XML从个人观感上确实好了不少，可是你看着这代码。。。属实让人头皮发麻。毕竟你要在存储内容的基础上还要加上结构层次，多点代码量看上去也是理所应当的。</p><h2 id="All-In-All"><a href="#All-In-All" class="headerlink" title="All In All"></a>All In All</h2><p>其实把对象储存进文件的方式还有很多，只是目前主流方式就是这四种了。PlayerPrefs可以较为简单的进行存档读档，但是却只能进行一些简单的操作（比如玩家设置等轻量数据），存储的数值也只局限于int,float,string三种类型，连List类都无法支持。序列化和反序列化看似可以解决数据的存储和读取，而且存档的内容也不至于让别人那么容易地进行篡改。但是改不了你自己也读不懂啊，而且还要加上很长的命名空间。json相对而言就不用加上一些复杂的命名空间，存储的文档也让人看得懂。但是储存的东西一下多了，你打开文档时，那不带换行的原始json文件又给你带来一个全新的坐牢体验。XML就很好的解决了文档可读性的问题，但是相对的代码量也提高了114514倍，命名空间也加了一个。关于这四种方式的解决问题，建议读者根据自己的实际情况进行选择。不过在我看来，json应该是最佳的选择把。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>关于Unity协程函数的个人理解</title>
    <link href="http://example.com/2021/04/11/%E5%85%B3%E4%BA%8EUnity%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/04/11/%E5%85%B3%E4%BA%8EUnity%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2021-04-11T15:03:06.000Z</published>
    <updated>2022-01-07T11:30:50.085Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=29794281&auto=1&height=66"></iframe><p>Hello,这里是Karmotrine之众所周知，Unity的协程函数一直Unity匪夷所思的难点之一。至少它在一开始就困扰了我很久.但是在现在，我好像悟了（bushi，就把自己的理解打在公屏上，希望dalao轻喷。<del>想不到吧我竟然更了哈哈哈哈哈哈好吧其实我也妹想到</del></p><h2 id="Unity的协程和线程"><a href="#Unity的协程和线程" class="headerlink" title="Unity的协程和线程"></a>Unity的协程和线程</h2><p>​        在谈协程函数之前，我们先了解一下协程和线程的区别。线程相当于Unity中一直在进行的事物，只有在程序或者脚本结束时才能停止。比如说<code>Update</code>函数，它在程序开始时的每一帧都会被调用，而不是<code>Start</code>或者<code>Awake</code>那样只被调用一次。而协程函数就不一样了。它可以随意在某个时间被启用，也可以持续随便一段时间，也可以在任意时间暂停又开始，也可以在任意时间结束。比如说之前文章里的对话框系统。我只想这个脚本在对话框系统启用时才调用它，然后一结束就关闭。这个时候使用线程显然是不太行的，用协程函数写简直无比舒适。demone,协程函数也有所谓的缺点，它的开始，暂停，结束都需要我们手动进行操作，而不像线程那样只要一开程序就不用管了。而且协程改变的参量会被线程改变。比如说我协程写了冲刺给物体的速度赋值，然后它就被线程里的<code>Move</code>函数改回来了，导致根本冲不动<del>(????????)</del>的事情发生。</p><p>​        综上所述，协程和线程的主要区别为：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。而线程就不需要管那么多，写就完事了，但是我们也要做好不能随意让它停止或者不干扰协程运行的准备。</p><h2 id="IEnumerator的神仙妙用"><a href="#IEnumerator的神仙妙用" class="headerlink" title="IEnumerator的神仙妙用"></a><code>IEnumerator</code>的神仙妙用</h2><p>在了解了协程的主要功能后，我们就可以来聊聊协程函数了？然而并不行，我们还要从一个功能开始：</p><h3 id="如何完成cd的冷却-倒计时？"><a href="#如何完成cd的冷却-倒计时？" class="headerlink" title="如何完成cd的冷却/倒计时？"></a>如何完成cd的冷却/倒计时？</h3><p>​        众所周知，一个游戏肯定要有cd：闪现有cd，对话框一个字一个字出来有cd，<del>就连手冲都要有cd（我有个朋友想要这个游戏）</del>，但是如何实现这个功能呢？这显然是easygame：<code>Update</code>函数会每一帧调用，这样就能实现时间的流逝，而不像其他函数就调用一帧，指过一帧的时间就咋瓦鲁多了，这还怎么整嘛。所以，倒计时系统就应该这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;//这里timer要在函数外面赋值，这里就省略了</span><br><span class="line">timer -= Time.deltaTime; //控制cd的变量随时间减小而自减</span><br><span class="line">if(timer &lt;= 0)</span><br><span class="line">Debug.Log(&quot;结束辣！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这搞一个倒计时还好，但如果我要整114514个呢？<del>（怎么臭起来了）</del>这样我们只能多写几个变量一起算？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">shanxianTimer -= Time.deltaTime;</span><br><span class="line">if(shanxianTimer &lt;= 0)</span><br><span class="line">Debug.Log(&quot;交闪现辣！&quot;);</span><br><span class="line">tell -= Time.deltaTime;</span><br><span class="line">if(tell &lt;= 0)</span><br><span class="line">Debug.Log(&quot;讲完辣!&quot;);</span><br><span class="line">kkskkksk -= Time.deltaTime;</span><br><span class="line">if(kkskkksk &lt;= 0)</span><br><span class="line">Debug.Log(&quot;冲完辣！&quot;); //？？？？？？？？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demone,这样做岂不是有亿点繁琐，这样还是3个，如果是114514个<del>（捂鼻）</del>该怎么办？那不如写个循环？？？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(float timer = 114514; timer &gt;= 0; timer -= Time.deltaTime)</span><br><span class="line">&#123;</span><br><span class="line">//交闪现了！blabla</span><br><span class="line">&#125;</span><br><span class="line">Debug.Log(&quot;owari!&quot;);</span><br></pre></td></tr></table></figure><p>欸，你这个写的就正好和协程一样了，因为瓦塔西的协程函数正好可以做到这一点！</p><h3 id="协程函数的主要介绍"><a href="#协程函数的主要介绍" class="headerlink" title="协程函数的主要介绍"></a>协程函数的主要介绍</h3><p>那我们就以协程函数来写一个倒计时系统吧（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">StartCoroutine(Countdown());</span><br><span class="line">&#125;</span><br><span class="line">IEnumerator Countdown()</span><br><span class="line">&#123;</span><br><span class="line">for(float shanxian = 3; shanxian &gt;= 0; shanxian -= Time.deltaTime)</span><br><span class="line">yield return 0;</span><br><span class="line">Debug.Log(&quot;交闪现辣!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这中间：</p><p><code>StartCoroutine(Countdown())</code>就指的是开始协程函数（协程函数这么nb，自然要有特殊的打开方式</p><p><code>IEnumerator</code>是协程函数特有的开头，就类似于<code>void</code>、<code>int</code>之类的</p><p><code>for</code>函数和<code>Debug</code>没什么好说的，也就是倒计时然后提醒而已。</p><p>然后结束协程函数就是<code>StopCoroutine(Countdown())</code>了，然后如果要全部停止就可以打<code>StopAllCoroutine()</code>，但是我们不是经常用，因为协程函数也和其它函数一样，一到末尾就结束了。</p><p><strong>接下来才是我们重中之重的：</strong></p><p><code>yield return 0</code>了。</p><h3 id="wtf-is-yield-return"><a href="#wtf-is-yield-return" class="headerlink" title="wtf is yield return???"></a>wtf is yield return???</h3><p>关于<code>yield return 0</code>真的困扰了我很久，对于它的功能，我只能说是：停止执行方法，并且在下一帧从这里重新开始。这是什么意思呢？我们先看下面一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator SayWDNMD()</span><br><span class="line">&#123;//模仿打csgo的语音对话(bushi</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;W&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;D&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;N&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;M&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;D&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在调用这个方法的结果是什么呢，由于我懒得开Unity截图结果，再加上可能会出现偏差，所以这波直接高中理科实验吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间 内容</span><br><span class="line">0    W</span><br><span class="line">0.02 D</span><br><span class="line">0.04 N</span><br><span class="line">0.06 M</span><br><span class="line">0.08 D</span><br></pre></td></tr></table></figure><p>那么结果就显而易见了，每当<code>yield return 0</code>调用一次就会暂停0.02s（顺便一提，其中的0没有任何作用，改成1也是停一帧，2也是一帧，114514也是一帧）。我们把协程函数比喻你在彩虹六号：围攻作为防守的一次对局的各种动作，那么<code>yield return 0</code>就相当于lion开了技能时你的表现。你想继续行动，但是<code>yield return 0</code>卡着你硬要你等一帧才能继续。</p><h4 id="常见提问："><a href="#常见提问：" class="headerlink" title="常见提问："></a>常见提问：</h4><p><strong>为什么会出现偏差？</strong></p><p>因为Unity每一帧的时间是不一样的，可能这帧时间为0.02s，但下一帧就可能不是。因此Unity提供了<code>Update</code>和<code>FixedUpdate</code>两个函数，其中<code>FixedUpdate</code>函数就是在每个固定一帧的时间内调用。这里为了方便就固定是0.02s<del>（明明就是你想偷懒）</del></p><p><strong>可不可以不停一帧，改成其他时间？</strong></p><p>可以的，但是要改成<code>yield return new WaitForSeconds(Time)</code>，其中Time表示你要暂停的时间，以秒为单位。</p><h3 id="小细节，大作用"><a href="#小细节，大作用" class="headerlink" title="小细节，大作用"></a>小细节，大作用</h3><p>那么我们这样卡一下到底有什么用呢？作用可以说是很大了。因为：</p><p><em><strong>我们可以将需要时间流逝的函数写成了一种单独的方法，不需要一股脑全部丢进<code>Update</code>函数里。并且我们还可以随时停止并规定停止的时间，不像<code>Update</code>函数一开始就停不下来。</strong></em></p><p>协程函数最为简单的应用就是作为倒计时使用，比如进行冲刺后的冷却：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator Recover()</span><br><span class="line">    &#123;</span><br><span class="line">        for(;CoolDownTimer&gt;=0f; CoolDownTimer -= Time.deltaTime)</span><br><span class="line">        &#123;</span><br><span class="line">            yield return 0; </span><br><span class="line">        &#125;</span><br><span class="line">        if (CoolDownTimer &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            canDash = true;</span><br><span class="line">            DashTimer = DashTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>众所周知，我们在游戏时肯定不会一直冲啊，<del>（一直冲现实也受不了吧）</del>放进<code>Update</code>函数里肯定不太合适（但实际上放进去是可以的，写个if放里面就差不多，但是作为方法储存代码肯定更好看一点）。而这时候作为方法写进协程函数简直是再好不过了。</p><h4 id="常见提问：-1"><a href="#常见提问：-1" class="headerlink" title="常见提问："></a>常见提问：</h4><p><strong><code>yield return 0</code>放在循环里是否必要？</strong></p><p>依照我个人理解，其实<code>yield return 0</code>放在哪里都可以。因为它只是借用了协程函数可以按照时间变化而变化的好处来写的，其实并不需要在哪里停一下。但是为什么要写呢，因为<strong>Unity规定协程函数至少要有一个<code>yield</code>进行结束</strong>，所以就随便放呗~~（大概）~~~</p><p><strong>但是要注意一点，在计时的循环里一定要存在<code>yield return 0</code>这个语句</strong>，因为它的功能是在这一帧停止，然后在下一帧开始。如果没有加的话，它就一直继续，然后就能在一帧内处理你设定的几秒的计时，也就不存在你的计时了。。。</p><h2 id="一些其他要注意的"><a href="#一些其他要注意的" class="headerlink" title="一些其他要注意的"></a>一些其他要注意的</h2><h3 id="协程函数可以嵌套🐎？"><a href="#协程函数可以嵌套🐎？" class="headerlink" title="协程函数可以嵌套🐎？"></a>协程函数可以嵌套🐎？</h3><p>可以的，比如在冲刺和冲刺后回复的两个协程函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator CountingDash()</span><br><span class="line">    &#123;</span><br><span class="line">        if (VerticalMove != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Dashing = true;</span><br><span class="line">            PressedDash = false;</span><br><span class="line">            CoolDownTimer = CoolDownTime;</span><br><span class="line">            for (; DashTimer &gt;= 0; DashTimer -= Time.deltaTime)</span><br><span class="line">            &#123;</span><br><span class="line">                rb.velocity = new Vector2(rb.velocity.x, VerticalMove * dashSpeed);</span><br><span class="line">                yield return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (HorizontalMove != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Dashing = true;</span><br><span class="line">            PressedDash = false;</span><br><span class="line">            CoolDownTimer = CoolDownTime;</span><br><span class="line">            for (; DashTimer &gt;= 0; DashTimer -= Time.deltaTime)</span><br><span class="line">            &#123;</span><br><span class="line">                rb.velocity = new Vector2(HorizontalMove * dashSpeed, rb.velocity.y);</span><br><span class="line">                yield return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Dashing = false;</span><br><span class="line">        canDash = false;</span><br><span class="line">        StartCoroutine(Recover()); //看，这里嵌套了</span><br><span class="line">        yield break; //和yield return 0一样的结果</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>虽然协程函数有时候很好用，但是建议没有掌握的人还是全部丢进<code>Update</code>函数里，毕竟我之前因为协程已经卡死114514次，重做了114514次对话框了。。。</p><p><em><strong>其他的以后想到了在更qwq</strong></em></p><p><strong>差不多讲完了，祝民那桑用协程函数“怎么那么熟练啊”，Unity不卡崩~</strong></p><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p>csdn的各种协程函数教程：（自己上官网看吧）<del>这nm是友情链接？？？</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>在Unity中不使用任何插件制作角色对话框系统</title>
    <link href="http://example.com/2021/04/08/%E5%9C%A8Unity%E4%B8%AD%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E8%A7%92%E8%89%B2%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/04/08/%E5%9C%A8Unity%E4%B8%AD%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E8%A7%92%E8%89%B2%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-04-08T13:42:08.000Z</published>
    <updated>2022-01-07T11:42:13.905Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1810759765&auto=1&height=66"></iframe><p>在众多RPG等游戏中，对话框系统显然属于不可或缺的一部分。玩家通过对话了解剧情以及接下来的主线。可以说，<del>对话系统就是RPG游戏的灵魂（bushi</del>,而这个文章介绍的对话系统可以在无需插件并且完成对话系统基本功能的同时完成以下三点内容：</p><p><strong>1.剧情内容只用按照规律写在txt文件里</strong></p><p><strong>2.可以选择跳过，自动播放或者手动播放</strong></p><p><strong>3.文字会一个一个显示，而不是整句话蹦出来</strong></p><p>撒，那我们开始把（</p><h2 id="搭建对话框"><a href="#搭建对话框" class="headerlink" title="搭建对话框"></a>搭建对话框</h2><p>​        按照以往经验，对话框肯定要包括对话信息框，角色的头像和名字。然后我在此基础上还要实现自动播放，跳过，所以加了两个按钮。如果还要其它功能可以自己再加。。。我直接简单搭了一个：</p><p><img src="%E5%AF%B9%E8%AF%9D%E6%A1%86.png" alt="对话框" loading="lazy"></p><p>其中对话框主体直接在canvas的最下面加了panel，角色名称，对话内容分开来各用一个text（因为到时候要随着角色的改变而改变），并且以panel为父物体。（这个没什么难度，直接简写了）</p><p><strong>注意！：</strong></p><p>无论要怎么改，对话框物体一定要设置锚点卡在屏幕的各个角落，否则会因为屏幕尺寸发生变化而偏移！</p><p><img src="%E6%B3%A8%E6%84%8F.png" alt="注意" loading="lazy"></p><p>锚点设置方法：点击红箭头指的按钮，按住alt键，选择要固定在屏幕的哪个地点。</p><h2 id="构建基础功能"><a href="#构建基础功能" class="headerlink" title="构建基础功能"></a>构建基础功能</h2><p>要实现基础功能，就要通过三个流程：</p><p><strong>1.将txt文本文件导入列表</strong></p><p><strong>2.将列表内的台词依次播放，同时根据角色的转变而变换头像</strong></p><p><strong>3.判断结束对话并且把所有对话框组件setactive改为false</strong></p><p>先是声明的各种物体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> [Header(&quot;UI组件&quot;)]</span><br><span class="line">    public Text textLabel;  //对话框的内容text</span><br><span class="line">    public GameObject SkipButton; //跳过按钮</span><br><span class="line">    public GameObject AutoButton; //自动播放按钮</span><br><span class="line">    public GameObject Log; //对话框的panel</span><br><span class="line">    public Text AutoText; //自动播放按钮的“自动播放”文本的text（用于实现自动手动切换的功能）</span><br><span class="line">    public GameObject Warning; //提醒玩家按左键继续，可要可不要</span><br><span class="line">[Header(&quot;文本文件&quot;)]</span><br><span class="line">public TextAsset textfile; //剧情文本的txt文件</span><br><span class="line">public int index; //进行到了第几句话，用于实现基础功能</span><br><span class="line">public float textSpeed = 0.05f; //每个字多久才能出现</span><br><span class="line"></span><br><span class="line">[Header(&quot;头像&quot;)]</span><br><span class="line">public GameObject A; //角色的头像以及名字</span><br><span class="line">public GameObject B; //角色的头像以及名字</span><br><span class="line">//因为我直接把名字和头像绑定为父子物体了，所以只声明了一个GameObect</span><br><span class="line"></span><br><span class="line">bool textFinished; //判断对话是否结束</span><br><span class="line">float i=0f; //判断是否为自动还是手动播放</span><br><span class="line"></span><br><span class="line">List&lt;string&gt; textList = new List&lt;string&gt;(); //将txt文件的对话内容导入列表内</span><br></pre></td></tr></table></figure><p>接着进unity把每个组件都挂载一下（具体是啥我在注释都写了，所以就不贴图了）</p><h3 id="将txt文本文件导入列表"><a href="#将txt文本文件导入列表" class="headerlink" title="将txt文本文件导入列表"></a>将txt文本文件导入列表</h3><p>在说明代码前先把txt的格式说明一下（为什么这样之后再说）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">换一个角色说话之前要把角色的名字单独打一行</span><br><span class="line">就像这样</span><br><span class="line">B</span><br><span class="line">这样就换成了我（</span><br><span class="line">结束的时候不需要标记什么</span><br></pre></td></tr></table></figure><p>先贴上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> void GetTextFromFile(TextAsset file)</span><br><span class="line">&#123;</span><br><span class="line">     textList.Clear(); //如果不是第一次调用对话框，就需要把之前一次所有对话的列表给清空</span><br><span class="line">     index = 0; //并且把显示第几句话的index清零</span><br><span class="line">     var lineData = file.text.Split(&#x27;\n&#x27;); //把文本文件以回车分割一句句台词和角色名称</span><br><span class="line"></span><br><span class="line">     foreach (var line in lineData) </span><br><span class="line">    &#123;</span><br><span class="line">        textList.Add(line); //把一句句台词录入line列表里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之就是：重置之前用过的台词和数据，处理文本文件，用回车键分割一句句台词，然后把台词录入列表以供对话系统使用。</p><p><strong>注意：</strong></p><p>在调用时要放在Awake函数里，因为Awake函数是一启用脚本就开始运行，而这个工序也要一经使用就开始运行。我的脚本调用是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        GetTextFromFile(textfile);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="将列表内台词播放"><a href="#将列表内台词播放" class="headerlink" title="将列表内台词播放"></a>将列表内台词播放</h3><p><em><strong>注意：看懂这段代码需要学习unity协程函数的知识，如果之前没有听过建议百度学习一下或者等我的文章更新<del>（算了我天天鸽还是别等了）</del></strong></em></p><h4 id="单个句子的播放"><a href="#单个句子的播放" class="headerlink" title="单个句子的播放"></a>单个句子的播放</h4><p>还是贴代码（这个代码实现的只是单个句子的播放，而不是整个对话）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator SetTextUI() //协程函数的标准形式</span><br><span class="line">    &#123;</span><br><span class="line">        textFinished = false; //正在播放，所以bool值为false</span><br><span class="line">        textLabel.text = &quot;&quot;; //可能上一个句子使用结束后还在text上，所以要清空</span><br><span class="line">    switch (textList[index]) //index是指播放到了第几句，所以这是来判断当前播放到的台词</span><br><span class="line">        //用来判断是谁说出来的（所以txt要按标准写嘛（叉腰））</span><br><span class="line">    &#123;</span><br><span class="line">        case &quot;A\r&quot;://如果A要说话</span><br><span class="line">            &#123;</span><br><span class="line">                A.SetActive(true); //头像名字显示出来</span><br><span class="line">                index++; //直接跳到下一句，这样就不会直接出现在对话框的对话里面</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">                //如果还要写别人的话，case信息和上面一样</span><br><span class="line">        case &quot;旁白\r&quot;: //与上面同理</span><br><span class="line">            &#123;</span><br><span class="line">                QingShan.SetActive(false);</span><br><span class="line">                index++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; textList[index].Length; i++)</span><br><span class="line">        //按照一句话的一个字慢慢来，如果没有到一句台词最后一个字的话就一直向后</span><br><span class="line">    &#123;</span><br><span class="line">        textLabel.text += textList[index][i]; //往之前已经打出的台词中加进新的文字</span><br><span class="line">        yield return new WaitForSeconds(textSpeed);//等待textSpeed后继续循环</span><br><span class="line">    &#125;</span><br><span class="line">    textFinished = true; //如果跳出循环说明文字已经放完了，所以bool值是true</span><br><span class="line">    index++; //这句话已经放完了，index++跳进下一句话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>yield return</code>的意思就是，在这一帧return，并且在下一帧继续开始。如果看不懂的话还是建议百度一下unity协程函数。<del>这样的话不用放进update函数里面也可以实现延时等效果。(暴论)</del></p><h5 id="常见问答（bushi-："><a href="#常见问答（bushi-：" class="headerlink" title="常见问答（bushi)："></a>常见问答（bushi)：</h5><p><strong>为什么判断是角色名字后不直接跳出函数，而是继续打出呢？</strong></p><p>因为txt里面角色名字后面一定是角色说的话而不是另一个角色的名字，所以可以直接不需要判断而进入循环。<del>同时在写txt剧情时也要注意：哪有一个角色还没讲话就出现另外一个角色的道理哼哼啊啊啊啊啊</del></p><p><strong>为什么角色名字后面要加/r?</strong></p><p>因为在windows的txt文本中，每次回车都会有\r的存在。如果要判断是不是角色名就一定要加上\r，<del>除非你不是拿windows做游戏。</del></p><hr><h4 id="整个对话文本的播放"><a href="#整个对话文本的播放" class="headerlink" title="整个对话文本的播放"></a>整个对话文本的播放</h4><p>还是先贴代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Update()&#123;</span><br><span class="line">AutoText.text = &quot;自动播放&quot;; //切换自动手动播放时要用的</span><br><span class="line">    textSpeed = 0.05f; //每个字出来的间隔时0.05秒</span><br><span class="line">    if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; index == textList.Count)</span><br><span class="line">    &#123;</span><br><span class="line">    EndDialogue();//如果按下鼠标左键并且播放到了最后一句的话就启动结束对话的函数</span><br><span class="line">    &#125;</span><br><span class="line">    if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; textFinished)</span><br><span class="line">    &#123;</span><br><span class="line">    StartCoroutine(SetTextUI());//如果按下鼠标左键的同时一句话已经放完了，就继续启动下一句的播放</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常见问答-bushi-："><a href="#常见问答-bushi-：" class="headerlink" title="常见问答(bushi)："></a>常见问答(bushi)：</h5><p><strong>为什么要设置一个textFinished的布尔值？</strong></p><p>因为如果不设置的话前面一句还没有看完下一句的台词直接来了，这样会严重影响读者的阅读体验，所以我决定直接卡死不让玩家快进。</p><hr><h4 id="结束播放对话文本"><a href="#结束播放对话文本" class="headerlink" title="结束播放对话文本"></a>结束播放对话文本</h4><p>依旧是先贴上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void EndDialogue()</span><br><span class="line">&#123;//把114514个对话框组件全部隐藏，代表对话已经结束了</span><br><span class="line">gameObject.SetActive(false);</span><br><span class="line">QingShan.SetActive(false);</span><br><span class="line">Log.SetActive(false);</span><br><span class="line">SkipButton.SetActive(false);</span><br><span class="line">AutoButton.SetActive(false);</span><br><span class="line">    index = 0; //把目录调整成最开始，这样下一次开始就是从第一句播放</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个完整的对话就结束了。</p><p><em><strong>但是如何实现对话的自动手动播放，以及跳过播放呢？</strong></em></p><h2 id="完成增值功能："><a href="#完成增值功能：" class="headerlink" title="完成增值功能："></a>完成增值功能：</h2><h3 id="实现跳过对话的功能"><a href="#实现跳过对话的功能" class="headerlink" title="实现跳过对话的功能"></a>实现跳过对话的功能</h3><p>这活儿很简单，只要把脚本放进空物体，然后把按钮按下的脚本挂载进并选择EndDailogue函数里就可以了。</p><p><img src="%E6%8C%82%E8%BD%BD.png" alt="挂载" loading="lazy"></p><h3 id="实现自动手动播放的功能"><a href="#实现自动手动播放的功能" class="headerlink" title="实现自动手动播放的功能"></a>实现自动手动播放的功能</h3><p>这个功能其实比较简陋，因为我目前还没有尝试在每句话结束后调节时间的功能，只是把每个字播放的顺序调慢而已。（请大神轻喷）</p><p>还是代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (i % 2 == 0f)//当i是偶数时，说明点了偶数按钮，就是手动播放，奇数同理</span><br><span class="line">        &#123;</span><br><span class="line">            AutoText.text = &quot;自动播放&quot;; //把按钮文本改了，因为现在是手动播放</span><br><span class="line">            textSpeed = 0.05f; </span><br><span class="line">            if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; index == textList.Count)</span><br><span class="line">            &#123;</span><br><span class="line">                EndDialogue();</span><br><span class="line">            &#125;</span><br><span class="line">            if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; textFinished)</span><br><span class="line">            &#123;</span><br><span class="line">                StartCoroutine(SetTextUI());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            AutoText.text = &quot;手动播放&quot;;</span><br><span class="line">            textSpeed = 0.15f; //把每个字出现的时长调整长了</span><br><span class="line">            if (index == textList.Count) //因为是自动播放，所以去掉了按鼠标左键的限制</span><br><span class="line">            &#123;</span><br><span class="line">                EndDialogue();</span><br><span class="line">            &#125;</span><br><span class="line">            if (textFinished) //这里也是</span><br><span class="line">            &#123;</span><br><span class="line">                StartCoroutine(SetTextUI());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> public void AutoPlay() //要把这个函数挂载进自动播放的按钮里</span><br><span class="line">    &#123;</span><br><span class="line">        i = i + 1f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说起来这个功能还是比较简陋，它的是否是自动手动的判定机制仅仅是判断点击按钮的次数是奇数还是偶数，按钮每次点击也只是计算点击次数的变量+1，但是它就是这么实现了？<del>就很怪</del></p><p><em><strong>再次提醒一下，AutoPlay函数要挂载进按钮里面，挂载方式和之前跳过对话的按钮一样，否则无法实现功能。</strong></em></p><hr><p><em><strong>就这样差不多就完成了，虽然小编也很惊奇，但是对话框系统就是这样完成了。有疑惑的小伙伴欢迎在评论区留下点赞评论吧！我们下期再见！<del>（你是营销号吗？？）</del></strong></em></p><h2 id="友情链接："><a href="#友情链接：" class="headerlink" title="友情链接："></a>友情链接：</h2><p><strong>大多数代码以及思想借鉴的视频：</strong><a href="https://www.bilibili.com/video/BV1WJ411Y71J">https://www.bilibili.com/video/BV1WJ411Y71J</a></p><p>(Michael真的很强，建议初学者都去康康他的视频嗷)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
    <category term="教程" scheme="http://example.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
</feed>
