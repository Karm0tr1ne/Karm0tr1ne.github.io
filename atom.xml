<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utopia</title>
  
  <subtitle>Kyrie eleison.</subtitle>
  <link href="https://karmotrine.fun/atom.xml" rel="self"/>
  
  <link href="https://karmotrine.fun/"/>
  <updated>2022-01-18T12:45:07.831Z</updated>
  <id>https://karmotrine.fun/</id>
  
  <author>
    <name>Karmotrine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity Shader05——高级纹理</title>
    <link href="https://karmotrine.fun/2022/01/16/Unity-Shader05%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/"/>
    <id>https://karmotrine.fun/2022/01/16/Unity-Shader05%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/</id>
    <published>2022-01-16T13:06:54.000Z</published>
    <updated>2022-01-18T12:45:07.831Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1873324098&auto=1&height=66"></iframe><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！<del>（虽然溜一遍下来发现好像也能看</del></p><h2 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a>立方体纹理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>立方体纹理和之前的2D纹理不同，一共包含了6张图像对应6个面。而对于三维的立方体纹理，我们也要提供一个三维的纹理坐标<strong>表示在世界空间下的一个3D方向</strong>。这个方向从立方体中心出发，向外部延伸与6个纹理之一相交，从而得出采样结果。</p><p>使用立方体纹理的优点是实现简单快速，得到效果也很好。但是当场景引入新的物体、光源，或者物体移动时，就需要重新生成立方体纹理。除此之外，立方体纹理只可以反射环境，但不能反射使用该立方体纹理的物体本身（立方体纹理无法模拟多次反射的结果）。因此立方体纹理应该尽量对凸面体而不是凹面体使用（凹面体会反射自身）。</p><h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><p>天空盒是游戏中模拟背景的方法（用来模拟天空的一个盒子）。当我们使用天空盒时，整个场景就被包围在一个立方体内，而立方体每个面就是使用了立方体纹理映射技术。</p><p>在创建天空盒时，我们要把新建的Material的Shader改成<strong>Skybox/6 sided</strong>，然后把6个面所需的材质拖入Material里面（<strong>Wrap Mode</strong>设置成<strong>Clamp</strong>），防止接缝处出现不匹配的现象。另外三个参数：</p><p><strong>Tint Color</strong>：控制该材质的整体颜色；</p><p><strong>Exposure</strong>：调整天空盒亮度；</p><p><strong>Rotation</strong>：调整天空盒沿+y轴方向的旋转角度</p><p>设置完后在Window-&gt;Lighting把材料拖进天空盒材质即可。</p><p>如果有摄像机要使用不同的天空盒，就可以向该摄像机添加Skybox组件覆盖掉之前的设置。</p><h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><p>通过环境映射可以模拟出金属质感的材质。</p><p>创建用于环境映射的立方体纹理有三种方法：1.直接由一些特殊布局的纹理创建；2.手动创建Cubemap资源再赋6张图；3.由脚本生成。</p><p>第一种方法只需要提供一张具有特殊布局的纹理，然后把该纹理的Text Type设置为<strong>Cubemap</strong>就行，后面Unity会全部搞定；</p><p>第二种方法是Unity5之前的方法，也需要准备6张纹理；</p><p>前两种方法需要提供图像，而且得到的立方体纹理被场景内所有物体通用，无法随着位置改变而改变。而第三种通过Unity内置的<strong>Camera.RenderToCubemap</strong>函数实现：</p><pre class="language-c#" data-language="c#"><code class="language-c#">using UnityEngine;using UnityEditor;using System.Collections;public class RenderCubemapWizard : ScriptableWizard &#123;public Transform renderFromPosition;public Cubemap cubemap;void OnWizardUpdate () &#123;helpString &#x3D; &quot;Select transform to render from and cubemap to render into&quot;;isValid &#x3D; (renderFromPosition !&#x3D; null) &amp;&amp; (cubemap !&#x3D; null);&#125;void OnWizardCreate () &#123;&#x2F;&#x2F;创建一个摄像机GameObject go &#x3D; new GameObject( &quot;CubemapCamera&quot;);go.AddComponent&lt;Camera&gt;();&#x2F;&#x2F;把它放在用户指定的位置上go.transform.position &#x3D; renderFromPosition.position;&#x2F;&#x2F; 把从该位置观察到的场景图像存储到6张图像，并渲染到用户指定的立方体纹理cubemap里go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);&#x2F;&#x2F;销毁摄像机DestroyImmediate( go );&#125;[MenuItem(&quot;GameObject&#x2F;Render into Cubemap&quot;)]static void RenderCubemap () &#123;ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(&quot;Render cubemap&quot;, &quot;Render!&quot;);&#125;&#125;</code></pre><p>**Camera.RenderToCubemap(Cubemap)**：把从任意位置观察到的场景图像存储到6张图像种，从而创建出该位置上对应的立方体纹理。</p><p>通过这个脚本，我们只需要新建一个空物体和一个立方体纹理（面板勾选<strong>Readable</strong>），在Unity菜单栏里选择GameObject-&gt;Render into Cubemap，把两个拖进去点<strong>Render！</strong>就行了（前提是要创建上面这个脚本）。</p><p><strong>Face size</strong>：设置Cubemap大小，值越大立方体纹理分辨率越大，效果可能更好，但占用内存也越大。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>原理是通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Reflection&quot;&#123;    Properties&#123;        _Color(&quot;Color Tint&quot;,Color)&#x3D;(1,1,1,1)        _ReflectColor(&quot;Reflection Color&quot;,Color)&#x3D;(1,1,1,1)        &#x2F;&#x2F;控制反射颜色        _ReflectAmount(&quot;Reflect Amount&quot;,Range(0,1))&#x3D;1        &#x2F;&#x2F;控制这个材质的反射程度        _Cubemap(&quot;Reflection Cubemap&quot;,Cube)&#x3D;&quot;_Skybox&quot;&#123;&#125;        &#x2F;&#x2F;模拟反射的环境映射纹理（立方体纹理）    &#125;    SubShader&#123;        Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &quot;Queue&quot;&#x3D;&quot;Geometry&quot;&#125;        pass&#123;            Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            fixed4 _Color;            fixed4 _ReflectColor;            float _ReflectAmount;            samplerCUBE _Cubemap;            #include &quot;AutoLight.cginc&quot;            #include &quot;Lighting.cginc&quot;            #pragma multi_compile_fwdbase             #pragma vertex vert            #pragma fragment frag            struct a2v&#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f&#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;                float3 worldViewDir:TEXCOORD2;                float3 worldRefl:TEXCOORD3;                SHADOW_COORDS(4)            &#125;;            v2f vert(a2v v)&#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                o.worldViewDir&#x3D;UnityWorldSpaceViewDir(o.worldPos);                o.worldRefl&#x3D;reflect(-o.worldViewDir,o.worldNormal);                &#x2F;&#x2F;计算反射方向                TRANSFER_SHADOW(o);                return o;            &#125;            fixed4 frag(v2f i):SV_TARGET&#123;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed3 worldViewDir&#x3D;normalize(i.worldViewDir);                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 diffuse&#x3D;_LightColor0.rgb*_Color.rgb*max(0,dot(worldNormal,worldLightDir));                fixed3 reflection&#x3D;texCUBE(_Cubemap,i.worldRefl).rgb*_ReflectColor.rgb;                &#x2F;&#x2F;利用反射方向对立方体纹理进行采样（使用_Cubemap）                UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);                fixed3 color&#x3D;ambient+lerp(diffuse,reflection,_ReflectAmount)*atten;                &#x2F;&#x2F;使用lerp和_ReflectAmount混合漫反射颜色与反射颜色                return fixed4(color,1.0);            &#125;            ENDCG        &#125;    &#125;    Fallback&quot;Reflective&#x2F;VertexLit&quot;&#125;</code></pre><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>折射就是，当光线从一类介质斜射入另一种介质时，传播方向一般会发生改变。而改变的规律可以使用斯涅尔定律：</p><p><img src="Snell.png" alt="Snell" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Shader" scheme="https://karmotrine.fun/categories/Shader/"/>
    
    
    <category term="笔记" scheme="https://karmotrine.fun/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Shader" scheme="https://karmotrine.fun/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity Shader04——复杂光照</title>
    <link href="https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/"/>
    <id>https://karmotrine.fun/2022/01/16/Unity-Shader04%E2%80%94%E2%80%94%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/</id>
    <published>2022-01-16T09:07:41.000Z</published>
    <updated>2022-01-18T04:21:44.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1903397110&auto=1&height=66"></iframe><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！<del>（虽然溜一遍下来发现好像也能看</del></p><h2 id="Unity的渲染路径"><a href="#Unity的渲染路径" class="headerlink" title="Unity的渲染路径"></a>Unity的渲染路径</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>渲染路径</strong>决定光照是如何应用到Unity Shader里的。只有为每个Pass指定正确的渲染路径才能正确执行光照计算。Unity的渲染路径有三种：前向渲染路径、延迟渲染路径和顶点照明渲染路径。每个摄像机可以通过修改Camera组件内的Rendering Path决定该摄像机对光照的渲染路径。如果没有设置，摄像机会遵从Unity设置的渲染路径（即前向渲染路径）。</p><p>Pass内部通过标签（<code>Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</code>）决定使用的渲染路径。（比如“ForwardBase”、“FowardAdd”就是前向渲染路径）所有标签如下：</p><p><img src="%E8%A1%A8%E4%B8%80.png" alt="表一" loading="lazy"></p><h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h3><p>传统、常用的渲染路径。首先利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区的颜色值，然后再遍历该模型的下一个片元。当然计算结果仅仅是一个光源的影响结果，如果有多个光源则要再次重复上述步骤。因此，假设场景有N个物体，每个物体受M个光照影响，渲染整个场景就需要N*M个Pass。（然后每个Pass又要渲染该物体的所有片元）。所以如果有大量逐像素光照，需要执行的数目也会很多。</p><p>对此，Unity中的前向渲染路径有3种：逐顶点处理、逐像素处理、球谐函数。我们可以在Light组件的Render Mode调整处理方式：</p><p>1.设置成Not Important以逐顶点或球谐函数处理；</p><p>2.设置成Important的和场景中最亮的平行光按逐像素处理；</p><p>3.上述规则得到的逐像素光源数量小于Quality Settings的数量，会有更多光源以逐像素的方式渲染。</p><p>前向渲染又有两种Pass：<strong>Base Pass</strong>和<strong>Additional Pass</strong>。</p><p><strong>Base Pass</strong>：计算一个逐像素的平行光以及所有逐顶点和SH光源，可以实现光照纹理、环境光、自发光和平行光的阴影；一个Base Pass只会调用一次。</p><p><strong>Additional Pass</strong>：计算其它影响该物体的逐像素光源（每个光源执行一次Pass），默认情况下不支持阴影；每个逐像素光源会执行一次Additional Pass。</p><p>对于前向渲染来说，一个Unity Shader通常会定义一个Base Pass和一个Additional Pass。</p><p>前向渲染可以使用的内置光照变量为：</p><p><img src="%E8%A1%A8%E4%BA%8C.png" alt="表二" loading="lazy"></p><p>前向渲染可以使用的内置光照函数为：</p><p><img src="%E8%A1%A8%E4%B8%89.png" alt="表三" loading="lazy"></p><h3 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h3><p>以逐顶点的方式来计算光照。因为前面的前向渲染路径也可以计算这个，所以不是很有用。</p><h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h3><p>是一种更为古老的渲染方法。它也是两个Pass。第一个Pass不进行任何光照计算，只是计算那些片元是可见的，如果可见就把相关信息存储到G缓冲区中。在第一个Pass执行完毕后进行第二个Pass，利用G缓冲区的各个片元信息进行真正的光照计算。如果说<strong>前向渲染路径</strong>是一计算可见就进行光照计算，<strong>延迟渲染路径</strong>就是计算可见先存储到缓冲区中，最后统一进行光照计算。</p><p>综上可得，延迟渲染就2个Pass，与场景中包含的光源数目没有关系，可以很好的解决<strong>前向渲染路径</strong>中包含大量实时光源时性能下降的问题。而且延迟渲染路径中每个光源都可以按逐像素的方式处理。但是，它也有着缺点：</p><p>1.不支持真正的抗锯齿功能；</p><p>2.无法处理半透明物体；</p><p>3.显卡要支持MRT等要求。</p><p><strong>延迟渲染路径</strong>可访问的内置变量和函数：</p><p><strong>_LightColor</strong>：光源颜色（float4）</p><p><strong>_LightMatrix0</strong>：从世界空间到光源空间的变换矩阵（float4x4）</p><h2 id="Unity的光源类型与实践"><a href="#Unity的光源类型与实践" class="headerlink" title="Unity的光源类型与实践"></a>Unity的光源类型与实践</h2><p>光源属性有5个：<strong>位置</strong>、<strong>方向</strong>、<strong>颜色</strong>、<strong>强度</strong>和<strong>衰减</strong></p><p>光源类型有四个（面光源暂不介绍）：</p><h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p>作为太阳这种角色在场景中出现，可以照亮的范围没有限制（所以嗯调位置一点用没有），也没有衰减（光照强度不会随距离发生改变）</p><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p>照亮空间时以光源为圆心的一个球体，光向所有方向延伸。球体的半径可以通过Range属性调整，光源颜色和强度可以在Light组件内调整。存在衰减，球心处光照强度最强，边界最弱，值为0.</p><h3 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h3><p>照亮空间时以光源为圆锥体最顶端（即尖端），向下投射出的圆锥体，光向特定方向延伸。锥形区域半径由Range属性决定，张开角度由Spot Angle属性决定。存在衰减，锥形顶点处光照强度最强，边界处强度为0.</p><h3 id="前向渲染路径实践"><a href="#前向渲染路径实践" class="headerlink" title="前向渲染路径实践"></a>前向渲染路径实践</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;ForwardRendering&quot;&#123;    Properties    &#123;        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20        _Atten (&quot;Atten&quot;,Range(0,256))&#x3D;1.0    &#125;    SubShader    &#123;        Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;        &#x2F;&#x2F;Base Pass        Pass&#123;            Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            &#x2F;&#x2F;设置Base Pass            CGPROGRAM            #pragma multi_compile_fwdbase            &#x2F;&#x2F;使用该指令可以保证我们使用光照衰减等光照变量可以被正确赋值（和Tag一样一定要写）。            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            fixed _Atten;            &#x2F;&#x2F;衰减值            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;                &#x2F;&#x2F;如上文，环境光只需计算一次，所以后面的Additional Pass就不会计算                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);                return fixed4(ambient+(diffuse+specular)*_Atten,1.0);            &#125;            ENDCG            &#125;        Pass&#123;            Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardAdd&quot;&#125;            &#x2F;&#x2F;Additional Pass的标签            Blend One One            &#x2F;&#x2F;将该Pass光照计算结果和Base Pass结果混合            &#x2F;&#x2F;如果没有Blend命令，Additional Pass会把Base Pass直接覆盖            CGPROGRAM            #pragma multi_compile_fwdadd            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            fixed _Atten;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                #ifdef USING_DIRECTIONAL_LIGHT                &#x2F;&#x2F;如果处理的光照类型是平行光                    fixed3 worldLightDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);                    &#x2F;&#x2F;就直接是                #else                    fixed3 worldLightDir &#x3D; normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);                    &#x2F;&#x2F;不然就要用这个位置减去世界空间下的顶点位置                #endif                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);                #ifdef USING_DIRECTIONAL_LIGHT                    fixed atten &#x3D; 1.0;                #else                    #if defined (POINT)                        float3 lightCoord &#x3D; mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;                        fixed atten &#x3D; tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;                        &#x2F;&#x2F;采样原因如下                    #elif defined (SPOT)                        float4 lightCoord &#x3D; mul(unity_WorldToLight, float4(i.worldPos, 1));                        fixed atten &#x3D; (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy &#x2F; lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;                    #else                        fixed atten &#x3D; 1.0;                    #endif                #endif                return fixed4((diffuse+specular)*_Atten,1.0);            &#125;            ENDCG            &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><h3 id="光线衰减纹理采样原因"><a href="#光线衰减纹理采样原因" class="headerlink" title="光线衰减纹理采样原因"></a>光线衰减纹理采样原因</h3><p>光线衰减的计算往往涉及开根号、除法等计算量相对较大的操作。因此Unity选择了使用一张纹理作为查找表以在片元着色器中得到光源的衰减。纹理名称为**_LightTexture0**，坐标(0,0)是与光源位置重合的点，(1,1)是和光源距离最远的。</p><p>为了得到纹理定点的相关数值，我们要得到该点在光源空间的位置：</p><p><code>float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</code></p><p>将世界空间的顶点坐标和转换矩阵相乘得到</p><p><code>fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</code></p><p>这里将光源空间的顶点距离的平方进行采样（没有使用距离值是因为可以避免开方操作）。然后使用宏<strong>UNITY_ATTEN_CHANNEL</strong>得到衰减纹理中衰减值所在分量，以得到最终衰减值。</p><p>也可以使用公式自行计算光源衰减，比如（这是线性衰减）：</p><p><code>float distance=length(_WorldSpaceLightPos0.xyz-i.worldPosition.xyz);</code></p><p><code>atten=1.0/distance;</code></p><h2 id="Unity的阴影与实践"><a href="#Unity的阴影与实践" class="headerlink" title="Unity的阴影与实践"></a>Unity的阴影与实践</h2><p>在实时渲染中，会使用<strong>Shadow Map</strong>技术，它会吧摄像头位置放在与光源重合的位置上，这样场景中该光源的阴影区域就是摄像头看不到的地方。</p><p>在前向渲染路径中，如果平行光打开了阴影，Unity会计算该光源的阴影映射纹理。它本身也是一张深度图，记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）。</p><p>计算深度信息的方法可以通过把摄像头挂在光源的位置，然后按正常渲染流程调用Base Pass和Additional Pass进行，但是这样会浪费性能：<strong>我们只要深度信息就行了，而不需要光源的相关计算</strong>。最好的办法是额外使用一个Pass来计算，也就是<code>Tags&#123;&quot;LightMode&quot;=&quot;ShadowCaster&quot;&#125;</code>的Pass。Unity会先把摄像机挂在光源的位置，然后找到LightMode是ShadowCaster的Pass。找不到就去Fallback指定的Shader里继续找（比如“Specular”）。</p><p><strong>传统的阴影映射纹理</strong>的实现中，我们先在正常Pass中把顶点位置变换到光源空间，然后使用xy分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值，就说明该点位于阴影中。但<strong>屏幕空间的阴影映射技术</strong>中，Unity会调用<code>Tags&#123;&quot;LightMode&quot;=&quot;ShadowCaster&quot;&#125;</code>的Pass来得到可投射阴影的光源阴影映射纹理和摄像机的深度纹理。然后根据上述得到屏幕空间的阴影图。如果摄像机的深度图中表面深度大于转换到阴影映射纹理的深度值，说明该表面虽然可见，但是在该光源的阴影中。这样阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接受来自其他物体的阴影，首先需要把表面坐标从模型空间变换到屏幕空间，然后使用该坐标对阴影图进行采样即可。</p><p>综上，一个物体接收其它物体的阴影和一个物体向其它物体投射阴影是两个过程：</p><p><strong>一个物体接受其它物体的阴影</strong>：必须在Shader里对阴影映射纹理进行采样，把采样结果和最后光照结果相乘。</p><p><strong>一个物体向其它物体投射阴影</strong>：把该物体加入到光源的阴影映射纹理计算中，从而让其它物体在对阴影映射纹理采样时得到该物体的相关信息。这个过程由“ShadowCaster”的Pass实现。</p><h3 id="不透明物体的阴影实践"><a href="#不透明物体的阴影实践" class="headerlink" title="不透明物体的阴影实践"></a>不透明物体的阴影实践</h3><h4 id="让物体投射阴影"><a href="#让物体投射阴影" class="headerlink" title="让物体投射阴影"></a>让物体投射阴影</h4><p>在物体的Mesh Render组件内，我们可以通过设置<strong>Cast Shadows</strong>（是否投射）和<strong>Receive Shadows</strong>（是否接收）属性选择让它是否投射或接收阴影。其中<strong>Cast Shadows</strong>默认情况下会剔除物体背面计算光源的阴影映射纹理。但设置为<strong>Two Sided</strong>时可以允许对物体所有面计算阴影信息。</p><p>投射阴影可以直接使用上面的前向渲染路径Shader，接收阴影的代码在FallBack内，所以不需要我们写，Unity会自行在FallBack找到。</p><h4 id="让物体接收阴影"><a href="#让物体接收阴影" class="headerlink" title="让物体接收阴影"></a>让物体接收阴影</h4><p>但是由于上述代码没有对阴影进行任何处理，因此不会显示别的地方投射来的阴影。因此修改上述代码如下：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Shadow&quot;&#123;    Properties    &#123;        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20        _Atten (&quot;Atten&quot;,Range(0,256))&#x3D;1.0    &#125;    SubShader    &#123;        Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125;        &#x2F;&#x2F;Base Pass        Pass&#123;            Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma multi_compile_fwdbase            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            &#x2F;&#x2F;计算阴影的宏在这个文件内            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            fixed _Atten;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;                SHADOW_COORDS(2)                &#x2F;&#x2F;声明一个用于对阴影纹理采样的坐标（括号内时下一个可用的插值寄存器的索引值）            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                TRANSFER_SHADOW(o);                &#x2F;&#x2F;计算上一步声明的阴影纹理坐标                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);                fixed shadow&#x3D;SHADOW_ATTENUATION(i);                &#x2F;&#x2F;计算阴影值                return fixed4(ambient+(diffuse+specular)*_Atten,1.0);            &#125;            ENDCG            &#125;        Pass&#123;            Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardAdd&quot;&#125;            Blend One One            CGPROGRAM            #pragma multi_compile_fwdadd            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            #include &quot;AutoLight.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            fixed _Atten;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                #ifdef USING_DIRECTIONAL_LIGHT                    fixed3 worldLightDir &#x3D; normalize(_WorldSpaceLightPos0.xyz);                #else                    fixed3 worldLightDir &#x3D; normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);                #endif                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);                #ifdef USING_DIRECTIONAL_LIGHT                    fixed atten &#x3D; 1.0;                #else                    #if defined (POINT)                        float3 lightCoord &#x3D; mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;                        fixed atten &#x3D; tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;                    #elif defined (SPOT)                        float4 lightCoord &#x3D; mul(unity_WorldToLight, float4(i.worldPos, 1));                        fixed atten &#x3D; (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy &#x2F; lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;                    #else                        fixed atten &#x3D; 1.0;                    #endif                #endif                return fixed4((diffuse+specular)*_Atten,1.0);            &#125;            ENDCG            &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><p><strong>SHADOW_COORDS()</strong>:声明一个用于对阴影纹理采样的坐标，参数需要是下一个可用的插值寄存器的索引值</p><p>**TRANSFER_SHADOW()**：用于在顶点着色器中计算上一步中声明的阴影纹理坐标</p><p>**SHADOW_ATTENUATION()**：计算阴影值</p><p>以上宏的计算都会使用上下文的变量，（比如v.vertex,a.pos等等）因此我们自定义的变量一定要和这些宏中使用的变量名相匹配（a2v顶点坐标变量一定是vertex，结构体a2v一定是v）</p><p>接下来只需要把shadow和漫反射以及高光反射的颜色相乘。</p><h3 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a>统一管理光照衰减和阴影</h3><p>实际上，光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到的渲染结果。因此，我们可以利用内置的<strong>UNITY_LIGHT_ATTENUATION</strong>来实现。</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;AttenuationAndShadowUseBuildInFunctions&quot; &#123; Properties &#123; _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1) _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1) _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20 &#125; SubShader &#123; Tags &#123; &quot;RenderType&quot;&#x3D;&quot;Opaque&quot; &#125; &#x2F;&#x2F;Base Pass Pass&#123; Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125; CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex:POSITION; float3 normal:NORMAL; &#125;; struct v2f &#123; float4 pos:SV_POSITION; float3 worldNormal:TEXCOORD0; float3 worldPos:TEXCOORD1; SHADOW_COORDS(2) &#125;; v2f vert(a2v v) &#123; v2f o; o.pos&#x3D;UnityObjectToClipPos(v.vertex); o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal); o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz; TRANSFER_SHADOW(o); return o; &#125; fixed4 frag(v2f i):SV_Target&#123; fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal &#x3D; normalize(i.worldNormal); fixed3 worldLightDir &#x3D; normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 diffuse &#x3D; _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir &#x3D; normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir &#x3D; normalize(worldLightDir + viewDir); fixed3 specular &#x3D; _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); return fixed4((diffuse + specular) * atten, 1.0); &#125; ENDCG &#125; Pass&#123; Tags &#123;&quot;LightMode&quot;&#x3D;&quot;ForwardAdd&quot;&#125; Blend One One CGPROGRAM #pragma multi_compile_fwdadd #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; #include &quot;AutoLight.cginc&quot; fixed4 _Diffuse; fixed4 _Specular; float _Gloss; struct a2v &#123; float4 vertex:POSITION; float3 normal:NORMAL; &#125;; struct v2f &#123; float4 pos:SV_POSITION; float3 worldNormal:TEXCOORD0; float3 worldPos:TEXCOORD1; SHADOW_COORDS(2) &#125;; v2f vert(a2v v) &#123; v2f o; o.pos&#x3D;UnityObjectToClipPos(v.vertex); o.worldNormal &#x3D; UnityObjectToWorldNormal(v.normal); o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz; TRANSFER_SHADOW(o); return o; &#125; fixed4 frag(v2f i):SV_Target&#123; fixed3 worldNormal&#x3D;normalize(i.worldNormal); fixed3 worldLightDir &#x3D; normalize(UnityWorldSpaceLightDir(i.worldPos)); fixed3 diffuse &#x3D; _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir)); fixed3 viewDir &#x3D; normalize(UnityWorldSpaceViewDir(i.worldPos)); fixed3 halfDir &#x3D; normalize(worldLightDir + viewDir); fixed3 specular &#x3D; _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss); &#x2F;&#x2F; UNITY_LIGHT_ATTENUATION not only compute attenuation, but also shadow infos UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos); return fixed4((diffuse + specular) * atten, 1.0); &#125; ENDCG &#125; &#125; FallBack &quot;Specular&quot; &#125;</code></pre><p>**UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos)**：声明第一个参数，并将光照衰减和阴影值相乘后的结果存储到第一个参数中。</p><p>其中第二个参数是结构体v2f，这个参数会传递给<strong>SHADOW_ATTENUATION</strong>计算阴影值。</p><p>第三个参数是世界空间的坐标，用于计算光源空间下的坐标，再对光照衰减纹理采样。</p><p><strong>UNITY_LIGHT_ATTENUATION</strong>的使用使得我们不需要在Base Pass里单独处理阴影，也不需要在Additional Pass内单独处理光照衰减。两个Pass的代码得以统一了。</p><h3 id="透明度物体的阴影"><a href="#透明度物体的阴影" class="headerlink" title="透明度物体的阴影"></a>透明度物体的阴影</h3><h4 id="透明度测试实践"><a href="#透明度测试实践" class="headerlink" title="透明度测试实践"></a>透明度测试实践</h4><p>对于不透明物体而言，使用FallBack里的<strong>VertexLit</strong>就可以完美得到正确的阴影，但对于透明物体则不然。之前提到透明物体的方法有透明度测试和透明度混合，这里使用透明度测试，在其基础上完成阴影的实现：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">hader &quot;Unity Shader Book&#x2F;Chapter 9&#x2F;AlphaTestWithShadow&quot;&#123;    Properties&#123;    _Color(&quot;Main Tint&quot;,Color)&#x3D;(1,1,1,1)    _MainTex(&quot;Main Tex&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;    _Cutoff(&quot;Alpha Cutoff&quot;,Range(0,1))&#x3D;0.5&#125;SubShader&#123;    Tags&#123;&quot;Queue&quot;&#x3D;&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;&#x3D;&quot;True&quot; &quot;RenderType&quot;&#x3D;&quot;TransparentCutout&quot;&#125;    Pass&#123;        Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;        Cull Off        CGPROGRAM        #pragma vertex vert        #pragma fragment frag        #include &quot;Lighting.cginc&quot;        #include &quot;AutoLight.cginc&quot;        fixed4 _Color;        sampler2D _MainTex;        float4 _MainTex_ST;        fixed _Cutoff;        struct a2v&#123;            float4 vertex:POSITION;            float3 normal:NORMAL;            float4 texcoord:TEXCOORD0;        &#125;;        struct v2f&#123;            float4 pos:SV_POSITION;            float3 worldNormal:TEXCOORD0;            float3 worldPos:TEXCOORD1;            float2 uv:TEXCOORD2;            SHADOW_COORDS(3)        &#125;;        v2f vert(a2v v)&#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);            o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;            o.uv&#x3D;TRANSFORM_TEX(v.texcoord,_MainTex);            TRANSFER_SHADOW(o);            return o;        &#125;        fixed4 frag(v2f i):SV_TARGET&#123;            fixed3 worldNormal&#x3D;normalize(i.worldNormal);            fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));            fixed4 texColor&#x3D;tex2D(_MainTex,i.uv);            clip(texColor.a-_Cutoff);            fixed3 albedo&#x3D;texColor.rgb*_Color.rgb;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;            fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(worldNormal,worldLightDir));            UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);            return fixed4(ambient+diffuse*atten,1.0);        &#125;        ENDCG    &#125;&#125;        Fallback &quot;Transparent&#x2F;Cutout&#x2F;VertexLit&quot;&#125;</code></pre><p>如果我们在Fallback内直接使用<strong>VertexLit</strong>的话，阴影结果可能不正确（已经被剔除且不会显示的片元依旧出现了阴影），其原因是<strong>VertexLit</strong>内的Pass没有进行任何透明度测试的计算。我们可以自己写一个，也可以把Fallback改成<strong>Transparent/Cutout/VertexLit</strong>。这个Fallback要求我们提供一个名字叫做**_Cutoff**的属性作为透明度测试的阈值。</p><h4 id="透明度混合实践"><a href="#透明度混合实践" class="headerlink" title="透明度混合实践"></a>透明度混合实践</h4><p>相比于透明度测试，透明度混合的阴影实现更为复杂。因为所有内置UnityShader都没有包含阴影投射的Pass。这意味着半透明物体不会对其它物体投射阴影，本身也不会接收阴影。复杂的问题在于透明度混合关闭了深度写入，从而影响了阴影的生成。总体来说，要产生正确的阴影，就要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会使得阴影处理变得很复杂。因此，半透明物体不会有阴影生成。</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;AlphaBlendWithShadow&quot;&#123;    Properties    &#123;        _Color (&quot;Main Tint&quot;, Color) &#x3D; (1,1,1,1)        _MainTex (&quot;Main Tex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;        _AlphaScale(&quot;Alpha Scale&quot;,Range(0,1))&#x3D;1    &#125;    SubShader&#123;    Tags&#123;&quot;Queue&quot;&#x3D;&quot;Transparent&quot; &quot;IgnoreProjector&quot;&#x3D;&quot;True&quot; &quot;RenderType&quot;&#x3D;&quot;Transparent&quot;&#125;    Pass&#123;        Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;        Cull Front        ZWrite Off        Blend SrcAlpha OneMinusSrcAlpha        CGPROGRAM        #pragma vertex vert        #pragma fragment frag        #include &quot;Lighting.cginc&quot;        #include &quot;AutoLight.cginc&quot;        fixed4 _Color;        sampler2D _MainTex;        float4 _MainTex_ST;        fixed _AlphaScale;        struct a2v&#123;            float4 vertex:POSITION;            float3 normal:NORMAL;            float4 texcoord:TEXCOORD0;        &#125;;        struct v2f&#123;            float4 pos:SV_POSITION;            float3 worldNormal:TEXCOORD0;            float3 worldPos:TEXCOORD1;            float2 uv:TEXCOORD2;            SHADOW_COORDS(3)        &#125;;        v2f vert(a2v v)&#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);            o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;            o.uv&#x3D;TRANSFORM_TEX(v.texcoord,_MainTex);            TRANSFER_SHADOW(o);            return o;        &#125;        fixed4 frag(v2f i):SV_TARGET&#123;            fixed3 worldNormal&#x3D;normalize(i.worldNormal);            fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));            fixed4 texColor&#x3D;tex2D(_MainTex,i.uv);            fixed3 albedo&#x3D;texColor.rgb*_Color.rgb;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;            fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(worldNormal,worldLightDir));            UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);            return fixed4(ambient+diffuse,texColor.a*_AlphaScale);        &#125;        ENDCG    &#125;    Pass&#123;        Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;        Cull Back        ZWrite Off        Blend SrcAlpha OneMinusSrcAlpha        CGPROGRAM        #pragma vertex vert        #pragma fragment frag        #include &quot;Lighting.cginc&quot;        #include &quot;AutoLight.cginc&quot;        fixed4 _Color;        sampler2D _MainTex;        float4 _MainTex_ST;        fixed _AlphaScale;        struct a2v&#123;            float4 vertex:POSITION;            float3 normal:NORMAL;            float4 texcoord:TEXCOORD0;        &#125;;        struct v2f&#123;            float4 pos:SV_POSITION;            float3 worldNormal:TEXCOORD0;            float3 worldPos:TEXCOORD1;            float2 uv:TEXCOORD2;            SHADOW_COORDS(3)        &#125;;        v2f vert(a2v v)&#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);            o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;            o.uv&#x3D;TRANSFORM_TEX(v.texcoord,_MainTex);            TRANSFER_SHADOW(o);            return o;        &#125;        fixed4 frag(v2f i):SV_TARGET&#123;            fixed3 worldNormal&#x3D;normalize(i.worldNormal);            fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));            fixed4 texColor&#x3D;tex2D(_MainTex,i.uv);            fixed3 albedo&#x3D;texColor.rgb*_Color.rgb;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;            fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(worldNormal,worldLightDir));            UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);            return fixed4(ambient+diffuse*atten,texColor.a*_AlphaScale);        &#125;        ENDCG    &#125;&#125;        Fallback &quot;VertexLit&quot;&#125;</code></pre><p>然而我们可以通过把Fallback设置为<strong>VertexLit、DIffuse</strong>这些不透明物体使用的Unity Shader，将该物体作为不透明物体生成阴影。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Shader" scheme="https://karmotrine.fun/categories/Shader/"/>
    
    
    <category term="笔记" scheme="https://karmotrine.fun/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Shader" scheme="https://karmotrine.fun/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity Shader03——透明效果</title>
    <link href="https://karmotrine.fun/2022/01/13/Unity-Shader03%E2%80%94%E2%80%94%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/"/>
    <id>https://karmotrine.fun/2022/01/13/Unity-Shader03%E2%80%94%E2%80%94%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</id>
    <published>2022-01-13T03:14:07.000Z</published>
    <updated>2022-01-16T08:21:01.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=858520&auto=1&height=66"></iframe><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！<del>（虽然溜一遍下来发现好像也能看</del></p><h2 id="透明效果概念和其它"><a href="#透明效果概念和其它" class="headerlink" title="透明效果概念和其它"></a>透明效果概念和其它</h2><h3 id="概念与渲染过程"><a href="#概念与渲染过程" class="headerlink" title="概念与渲染过程"></a>概念与渲染过程</h3><p>当一个物体被渲染到屏幕上时，每个片元除了颜色和深度外还有透明度这个属性。透明度为1表示完全不透明，为0表示完全不显示。</p><p><strong>深度缓冲</strong>：根据深度缓存中的值来判断一个片元距离摄像机的距离。当渲染另一片元时，<em>会将它的深度值和意见存在于深度缓冲的值比较</em>（<strong>深度测试</strong>），如果他的值距离摄像机更远，就不会被渲染（因为前面有物体挡住了它）；如果他的值距离摄像机更近，就会覆盖掉此时颜色缓冲中的像素值，<em>并把深度值更新到深度缓冲中</em>（<strong>深度写入</strong>）。</p><p>有两种方法实现透明效果，分别是<strong>透明度测试</strong>和<strong>透明度混合</strong>。</p><h4 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h4><p>采用极端的机制，只要一个片元透明度不满足条件（小于一个阈值）就舍弃不渲染，如果满足就按照普通的不透明物体处理（进行深度测试和写入）。虽然简单但是效果极端（不是完全透明就是完全不透明），做不到半透明的效果。需要打开深度写入。</p><h4 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h4><p>使用当前片元的透明度作为混合因子，与已经储存在颜色缓冲中的颜色缓冲值混合。但是执行该操作需要关闭深度写入，未关闭深度测试（如果不关闭，一个半透明表面背后表面本来可以被我们看到，但是由于深度测试判断结果时半透明表面更近，这样背后表面会被剔除）。对于透明度混合，深度缓冲是可读的。</p><h3 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h3><p>渲染顺序对于透明效果十分重要，特别是关闭了深度写入时。当先渲染近处的片元再渲染远处时，因为深度缓冲区没有任何有效数据，因此直接写入颜色缓冲，但是不会修改深度缓冲（未开启深度写入）。这样当渲染远处的时候进行深度测试，由于深度缓存啥也没有，所以会直接覆盖近处的颜色，从而导致错误。所以无论是半透明还是透明物体之间都需要符合一定渲染顺序。</p><p>目前的常用渲染方法为：</p><p>1.先渲染所有不透明物体并开启它们的深度测试和深度写入；</p><p>2.把半透明物体按距离排序，从后往前渲染透明物体，并开启深度测试，关闭深度写入。</p><p>但是问题依然没有解决，当几个物体交错放时，A物体一半在B物体前，一半在后面，就很难使用”从后往前“这个宽泛的说法。</p><p>针对上面的问题，Unity是这样解决的：</p><h4 id="Unity解决方案"><a href="#Unity解决方案" class="headerlink" title="Unity解决方案"></a>Unity解决方案</h4><p>Unity提供了渲染队列这一说法，采用SubShader中的<strong>Queue</strong>标签决定模型归于哪个渲染队列，队列索引号越小越早被渲染。</p><p><strong>Background</strong>：索引号1000，用来渲染那些需要绘制再背景上的物体</p><p><strong>Geometry</strong>：索引号2000，默认渲染队列，不透明物体使用该序列</p><p><strong>AlphaTest</strong>：索引号2450，需要透明度测试的物体选用该队列</p><p><strong>Transparent</strong>：索引号3000，使用透明度混合的物体选用该队列</p><p><strong>Overlay</strong>：索引号4000，用于实现一些叠加效果，任何需要在最后渲染的物体使用该队列</p><p>标签具体实现方法：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">SubShader&#123;Tags&#123;&quot;Queue&quot;&#x3D;&quot;里面写标签&quot;&#125;Pass&#123;......&#125;&#125;</code></pre><h2 id="透明度测试实践"><a href="#透明度测试实践" class="headerlink" title="透明度测试实践"></a>透明度测试实践</h2><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader&quot;Custom&#x2F;Alpha Test&quot;&#123;Properties&#123;    _Color(&quot;Main Tint&quot;,Color)&#x3D;(1,1,1,1)    _MainTex(&quot;Main Tex&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;    _CutOff(&quot;Alpha Cutoff&quot;,Range(0,1))&#x3D;0.5&#125;SubShader&#123;    Tags&#123;&quot;Queue&quot;&#x3D;&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;&#x3D;&quot;True&quot; &quot;RenderType&quot;&#x3D;&quot;TransparentCutout&quot;&#125;&#x2F;&#x2F;&quot;TransparentCutout&quot;标签指这是个使用了透明度的Shader&#x2F;&#x2F;True表明Shader不会受到投影器(Projector)的影响    Pass&#123;        Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;        CGPROGRAM        #pragma vertex vert        #pragma fragment frag        #include &quot;Lighting.cginc&quot;        fixed4 _Color;        sampler2D _MainTex;        float4 _MainTex_ST;        fixed _CutOff;        &#x2F;&#x2F;进行测试的阈值        struct a2v&#123;            float4 vertex:POSITION;            float3 normal:NORMAL;            float4 texcoord:TEXCOORD0;        &#125;;        struct v2f&#123;            float4 pos:SV_POSITION;            float3 worldNormal:TEXCOORD0;            float3 worldPos:TEXCOORD1;            float2 uv:TEXCOORD2;        &#125;;        v2f vert(a2v v)&#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);            o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;            o.uv&#x3D;TRANSFORM_TEX(v.texcoord,_MainTex);            return o;        &#125;        fixed4 frag(v2f i):SV_TARGET&#123;            fixed3 worldNormal&#x3D;normalize(i.worldNormal);            fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));            fixed4 texColor&#x3D;tex2D(_MainTex,i.uv);            clip(texColor.a-_CutOff);            &#x2F;&#x2F;测试是不是负数来剔除片元            fixed3 albedo&#x3D;texColor.rgb*_Color.rgb;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;            fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(worldNormal,worldLightDir));            return fixed4(ambient+diffuse,1.0);        &#125;        ENDCG    &#125;&#125;        Fallback &quot;Transparent&#x2F;Cutout&#x2F;VertexLit&quot;        &#x2F;&#x2F;换了个回调，保证使用透明度测试的物体可以正确向其它物体投射投影&#125;</code></pre><p>**clip(float4/3/2/1 x)**：如果x内任何一个分量是负数则舍弃当前像素输出颜色</p><p>结果很极端：要么完全透明要么完全不透明，而且边缘处存在锯齿，参差不齐（由于透明度的变化精度问题）</p><p><img src="%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95.png" alt="透明度测试" loading="lazy"></p><h2 id="透明度混合实践"><a href="#透明度混合实践" class="headerlink" title="透明度混合实践"></a>透明度混合实践</h2><p>Unity提供混合命令Blend：</p><p><strong>Blend Off</strong>：关闭混合</p><p><strong>Blend SrcFactor DstFactor</strong>：开启混合并设置混合因子，计算公式如下：</p><p>$$DstColor_{new}=SrcAlpha*SrcColor+(1-SrcAlpha)*DstColor_{old}$$</p><p><strong>Blend SrcFactor DstFactor,SrcFactorA DstFactorA</strong>：和上面一样，但计算公式变成：</p><p>$$ O_{rgb}=SrcFactor<em>S_{rgb}+DstFactor</em>D_{rgb} $$</p><p>$$ O_a=SrcFactorA<em>S_a+DstFactorA</em>D_a $$</p><p>通过两个公式分别计算新颜色的rgb和a值</p><p><strong>BlendOp BlendOperation</strong>：使用BlendOperation对它们进行其它操作</p><p>（还有很多ShaderLab混合命令，这里就不说了）</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;AlphaBlend&quot;&#123;    Properties    &#123;        _Color (&quot;Main Tint&quot;, Color) &#x3D; (1,1,1,1)        _MainTex (&quot;Main Tex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;        _AlphaScale(&quot;Alpha Scale&quot;,Range(0,1))&#x3D;1        &#x2F;&#x2F;控制物体的整体透明度    &#125;    SubShader&#123;    Tags&#123;&quot;Queue&quot;&#x3D;&quot;Transparent&quot; &quot;IgnoreProjector&quot;&#x3D;&quot;True&quot; &quot;RenderType&quot;&#x3D;&quot;Transparent&quot;&#125;&#x2F;&#x2F;因为是透明度混合，所以是Transparent    Pass&#123;        Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;        ZWrite Off        &#x2F;&#x2F;关闭深度写入        Blend SrcAlpha OneMinusSrcAlpha        &#x2F;&#x2F;原颜色和1-原颜色        CGPROGRAM        #pragma vertex vert        #pragma fragment frag        #include &quot;Lighting.cginc&quot;        fixed4 _Color;        sampler2D _MainTex;        float4 _MainTex_ST;        fixed _AlphaScale;        struct a2v&#123;            float4 vertex:POSITION;            float3 normal:NORMAL;            float4 texcoord:TEXCOORD0;        &#125;;        struct v2f&#123;            float4 pos:SV_POSITION;            float3 worldNormal:TEXCOORD0;            float3 worldPos:TEXCOORD1;            float2 uv:TEXCOORD2;        &#125;;        v2f vert(a2v v)&#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);            o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;            o.uv&#x3D;TRANSFORM_TEX(v.texcoord,_MainTex);            return o;        &#125;        fixed4 frag(v2f i):SV_TARGET&#123;            fixed3 worldNormal&#x3D;normalize(i.worldNormal);            fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));            fixed4 texColor&#x3D;tex2D(_MainTex,i.uv);            fixed3 albedo&#x3D;texColor.rgb*_Color.rgb;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;            fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(worldNormal,worldLightDir));            return fixed4(ambient+diffuse,texColor.a*_AlphaScale);            &#x2F;&#x2F;返回的不是1，而是透明通道乘以材质参数        &#125;        ENDCG    &#125;&#125;        Fallback &quot;Transparent&#x2F;VertexLit&quot;&#125;</code></pre><p><img src="%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88.png" alt="透明度混合" loading="lazy"></p><p>但由于关闭了深度写入，在相互交叉时往往会得到错误的效果（后面的部分也能看见）</p><h3 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h3><p>为了针对上述错误，我们可以使用<strong>两个Pass</strong>：第一个开启深度写入而不输出颜色，目的是将该模型的深度值写入深度缓冲；第二个才是正常透明度融合。</p><p>只要在上面代码加上：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Pass&#123;ZWrite OnColorMask 0&#x2F;&#x2F;用于设置颜色通道的写掩码，0代表不输出任何颜色&#x2F;&#x2F;这样就只需写入深度缓存即可&#125;</code></pre><h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>可以通过<strong>Cull</strong>指令控制剔除哪个面的渲染图元：</p><p><strong>Cull Back</strong>：剔除背对摄像机的图元</p><p><strong>Cull Front</strong>：剔除正对摄像机的图元</p><p><strong>Cull Off</strong>：关闭剔除功能，全会被渲染</p><h3 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h3><p>因为图元被直接舍弃，所以最好的方法就是关闭剔除：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Pass&#123;Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;Cull Off&#x2F;&#x2F;后面一样&#125;</code></pre><p><img src="%E5%8F%8C%E9%9D%A2%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95.png" alt="双面透明度测试" loading="lazy"></p><h3 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h3><p>因为透明度混合方法注重渲染的顺序，直接关闭剔除功能又不打开深度写入就会无法保证正面和背面的渲染顺序。所以最好的办法是分成两个Pass，第一个剔除正面，第二个剔除背面。由于Unity顺序执行，所以先渲染背面再渲染正面，这就保证了渲染顺序的正确性。</p><p>代码如下：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Pass&#123;Tags&#x3D;&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;Cull Front......&#x2F;&#x2F;和之前一样的代码&#125;Pass&#123;Tags&#x3D;&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;Cull Back......&#x2F;&#x2F;和之前一样的代码&#125;&#x2F;&#x2F;其它都一样</code></pre><p><img src="%E5%8F%8C%E5%90%91%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88.png" alt="双向透明度混合" loading="lazy"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Shader" scheme="https://karmotrine.fun/categories/Shader/"/>
    
    
    <category term="笔记" scheme="https://karmotrine.fun/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Shader" scheme="https://karmotrine.fun/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity Shader02——纹理</title>
    <link href="https://karmotrine.fun/2022/01/11/Unity-Shader02%E2%80%94%E2%80%94%E7%BA%B9%E7%90%86/"/>
    <id>https://karmotrine.fun/2022/01/11/Unity-Shader02%E2%80%94%E2%80%94%E7%BA%B9%E7%90%86/</id>
    <published>2022-01-11T14:30:37.000Z</published>
    <updated>2022-01-12T09:35:24.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=541480240&auto=1&height=66"></iframe><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！<del>（虽然溜一遍下来发现好像也能看</del></p><h2 id="纹理概念"><a href="#纹理概念" class="headerlink" title="纹理概念"></a>纹理概念</h2><h3 id="纹理简介"><a href="#纹理简介" class="headerlink" title="纹理简介"></a>纹理简介</h3><p>纹理最初目的是使用一张图片控制模型的外观。在美术人员建模时会利用纹理展开技术把纹理映射坐标存储在每个顶点上。这意味着二位纹理坐标都代表着3D建模中的一个顶点。而这个坐标采用的是UV坐标（U为横轴V为纵轴）。纹理大小虽然多种多样，但是坐标都归一化到[0,1]范围内。但也有在这个范围外的，它们决定渲染引擎在超出这个范围时如何进行纹理采样。</p><h3 id="纹理窗口简介"><a href="#纹理窗口简介" class="headerlink" title="纹理窗口简介"></a>纹理窗口简介</h3><p><img src="%E7%BA%B9%E7%90%86%E7%AA%97%E5%8F%A3.png" alt="纹理窗口" loading="lazy"></p><p><strong>Texure Type</strong>:纹理的类型，选择合适的类型可以让Unity为Shader传递正确的纹理，并对纹理进行优化；</p><p><strong>Wrap Mode</strong>:范围超过[0,1]会如何处理（被平铺）：</p><p><em>Repeat</em>：重复之前的纹理（舍去整数部分继续采样，所以相当于重复来了一遍）；</p><p><em>Clamp</em>：超过1就按1来算，超过0就按0来算（这样就一直是1或者0的颜色了）</p><p><strong>Filter Mode</strong>：当纹理因变化产生拉伸时会采用什么滤波模式。（滤波效果：Point&lt;Bilinear&lt;Trilinear，但是耗费性能也依次增大）</p><h2 id="单张纹理实践"><a href="#单张纹理实践" class="headerlink" title="单张纹理实践"></a>单张纹理实践</h2><p>我们在光照时提到了物体的漫反射颜色。而我们通常会使用一张纹理来代替漫反射颜色。以下就是运用Blinn-Phong模型来计算光照的单张纹理：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Single Texture&quot;&#123;    Properties    &#123;        _Color (&quot;Color&quot;, Color) &#x3D; (1,1,1,1)        &#x2F;&#x2F;控制物体渲染的整体色调        _MainTex (&quot;Main Tex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;        &#x2F;&#x2F;一个2D纹理，赋值为白色，从而它一开始就是个全白的纹理        _Specular(&quot;Specular&quot;, Color)&#x3D;(1,1,1,1)        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20    &#125;    SubShader    &#123;        pass&#123;            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            &#x2F;&#x2F;在声明纹理变量的同时，需要声明 纹理名称_ST 这一float4变量            &#x2F;&#x2F;作用是存储该纹理的缩放和平移值            &#x2F;&#x2F;xy值为缩放值，zw为平移值，可以在纹理属性窗口中调节            fixed4 _Specular;            float _Gloss;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;                float4 texcoord:TEXCOORD0;                &#x2F;&#x2F;将模型的第一组纹理坐标存储到该变量中            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;                float2 uv:TEXCOORD2;                &#x2F;&#x2F;使用该坐标进行纹理采样            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                o.uv&#x3D;v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw;                &#x2F;&#x2F;由于纹理属性存在缩放和偏移值，所以让纹理坐标先乘以缩放值，再加上偏移值。这才是真正的纹理采样uv坐标                &#x2F;&#x2F;Unity对上述操作有个专门的宏：                &#x2F;&#x2F;o.uv&#x3D;TRANSFORM_TEX(v.texcoord,_MainTex);                return o;            &#125;            fixed4 frag(v2f i):SV_Target            &#123;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed3 albedo&#x3D;tex2D(_MainTex,i.uv).rgb*_Color.rgb;                &#x2F;&#x2F;对纹理进行采样，将返回的纹素值乘以物体的整体色调                &#x2F;&#x2F;albedo为材质的反射率                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;                fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(worldNormal,worldLightDir));                &#x2F;&#x2F;通过反射率计算得到漫反射                fixed3 viewDir&#x3D;normalize(UnityWorldSpaceViewDir(i.worldPos));                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,worldLightDir)),_Gloss);                &#x2F;&#x2F;常规方法拿下高光反射                return fixed4(ambient+diffuse+specular,1.0);            &#125;            ENDCG            &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><p>**o.uv=TRANSFORM_TEX(_MainTex,i.uv)**：将纹理坐标进行缩放和偏移</p><p>**tex2D(_MainTex,i.uv)**：根据uv内的坐标进行纹理采样，并返回纹素值</p><h2 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>指使用一张纹理修改模型表面法线，让模型看起来“凹凸不平”但是并没有改变模型的顶点位置。实现这个方法的原理有两个：</p><h3 id="高度纹理"><a href="#高度纹理" class="headerlink" title="高度纹理"></a>高度纹理</h3><p>在基础纹理上加了一张高度纹理。在高度图里存储强度值，颜色越浅月向外凸起。它可以非常直观地知道一个模型表面的凹凸情况，但计算很复杂，需要通过像素灰度值计算表面法线，因此需要消耗更多的性能。</p><h3 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>在基础纹理上加了一张法线纹理。法线纹理存储着表面的法线方向，而法线方向范围是[-1,1]，像素范围是[0,1]，所以需要做一个映射：</p><p>$$pixel=\frac {nromal+1}{2}$$</p><p>而反过来就是：</p><p>$$normal=pixel*2-1$$</p><p>那么问题来了，切线方向应该在哪个空间呢？下面有几个解决方案：</p><h4 id="模型空间法线纹理"><a href="#模型空间法线纹理" class="headerlink" title="模型空间法线纹理"></a>模型空间法线纹理</h4><p>在模型空间下存储法线方向。法线纹理应该是五颜六色的，因为每个点存储的法线方向是各异的，经过映射后作为RGB颜色存储到纹理内也就是五颜六色的。使用模型空间实现简单，更加直观，不需要原始的法线切线等信息就可以计算。同时在纹理坐标的缝合处和尖锐的边角部分可见突变较少，可以提供平滑的边界。</p><h4 id="切线空间的法线纹理"><a href="#切线空间的法线纹理" class="headerlink" title="切线空间的法线纹理"></a>切线空间的法线纹理</h4><p>在切线空间下存储法线方向。在切线空间下，原点是该顶点本身，z轴是法线方向，x轴是切线方向，y轴通过法线和切线叉积而来，被称为副切线或副法线。切线空间下的法线纹理几乎全是浅蓝色，因为实际上大多数法线都与原模型的法线一致（即没有凹凸），也就是模型切线的垂直，即值为(0,0,1)，经过映射后对应了RGB(0.5,0.5,1)浅蓝色。其它需要调整凹凸的只是对原法线作出略微修改（扰动），所以看起来也是蓝色。</p><p>切线空间看似复杂，但优点更多：它自由度高，模型空间下的法线纹理只能运用到该模型上，而切线空间下就可以运用到一个完全不同的网格上；它可以进行UV动画，可以移动一个纹理的UV坐标来实现凹凸移动的效果（如火山岩浆）；它可以重用法线纹理，使用一张法线纹理就可以用到所有6个面；可以压缩，因为Z方向永远是正方向，所以可以通过XY直接推导，不需要多存储一个值。</p><h2 id="凹凸映射的实践"><a href="#凹凸映射的实践" class="headerlink" title="凹凸映射的实践"></a>凹凸映射的实践</h2><h3 id="切线空间下的计算"><a href="#切线空间下的计算" class="headerlink" title="切线空间下的计算"></a>切线空间下的计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Normal Map In Tangent Space&quot;&#123;Properties&#123;    _Color(&quot;Color Tint&quot;,Color)&#x3D;(1,1,1,1)    _MainTex(&quot;Main Tex&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;    _BumpMap(&quot;Normal Map&quot;,2D)&#x3D;&quot;bump&quot;&#123;&#125;    &#x2F;&#x2F;bump是Unity内置的法线纹理，提供模型自带的法线信息    _BumpScale(&quot;Bump Scale&quot;,float)&#x3D;1.0    &#x2F;&#x2F;控制凹凸程度，为0时说明不会对光照产生任何影响    _Specular(&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)    _Gloss(&quot;Gloss&quot;,Range(8.0,256))&#x3D;20    &#125;SubShader&#123;        pass&#123;            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            sampler2D _BumpMap;            float4 _BumpMap_ST;            float _BumpScale;            fixed4 _Specular;            float _Gloss;                        struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;                float4 tangent:TANGENT;                &#x2F;&#x2F;将顶点的切线方向存储进tangent变量内，w分量用来存储副切线的方向性                float4 texcoord:TEXCOORD0;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float4 uv:TEXCOORD0;                &#x2F;&#x2F;因为有两个纹理，所以该变量中xy存储_MainTex纹理坐标，zw存储_BumpMap纹理坐标                float3 lightDir:TEXCOORD1;                float3 viewDir:TEXCOORD2;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.uv.xy&#x3D;v.texcoord.xy*_MainTex_ST.xy+_BumpMap_ST.zw;                o.uv.zw&#x3D;v.texcoord.xy*_MainTex_ST.xy+_BumpMap_ST.zw;                TANGENT_SPACE_ROTATION;                &#x2F;&#x2F;内置宏，得到从模型空间到切线空间的变换矩阵rotation                o.lightDir&#x3D;mul(rotation,ObjSpaceLightDir(v.vertex)).xyz;                 &#x2F;&#x2F;先拿模型空间下的光照方向，然后通过变换矩阵转到切线空间                o.viewDir&#x3D;mul(rotation,ObjSpaceViewDir(v.vertex)).xyz;                &#x2F;&#x2F;先拿模型空间下的视角方向，然后通过变换矩阵转到切线空间                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 tangentLightDir&#x3D;normalize(i.lightDir);                fixed3 tangentViewDir&#x3D;normalize(i.viewDir);                fixed4 packedNormal&#x3D;tex2D(_BumpMap,i.uv.zw);                &#x2F;&#x2F;对法线纹理进行纹理采样，此时返回的时经过映射后得到的像素值                fixed3 tangentNormal;                tangentNormal&#x3D;UnpackNormal(packedNormal);                &#x2F;&#x2F;所以通过UnpackNormal映射回法线方向                tangentNormal.xy*&#x3D;_BumpScale;                &#x2F;&#x2F;通过乘以凹凸程度获取真实法线方向                tangentNormal.z&#x3D;sqrt(1.0-saturate(dot(tangentNormal.xy,tangentNormal.xy)));                &#x2F;&#x2F;通过切线空间xy值获得z值                fixed3 albedo&#x3D;tex2D(_MainTex,i.uv).rgb*_Color.rgb;                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;                fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir));                fixed3 halfDir&#x3D;normalize(tangentLightDir+tangentViewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss);                return fixed4(ambient+diffuse+specular,1.0);            &#125;            ENDCG            &#125;        &#125;    FallBack &quot;Specular&quot;    &#125;</code></pre><p><strong>UnpackNormal</strong>：将像素值映射回法线<strong>（只有把法线纹理类型设置成Normal Map才能用）</strong></p><p><strong>TANGENT_SPACE_ROTATION</strong>：得到从模型空间到切线空间的变换矩阵rotation</p><p>这样就变成了凹凸不平的样子：</p><p><img src="%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4.png" alt="切线空间" loading="lazy"></p><h3 id="世界空间计算"><a href="#世界空间计算" class="headerlink" title="世界空间计算"></a>世界空间计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader&quot;Custom&#x2F;Normal Map In World Space&quot;&#123;    Properties&#123;    _Color(&quot;Color Tint&quot;,Color)&#x3D;(1,1,1,1)    _MainTex(&quot;Main Tex&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;    _BumpMap(&quot;Normal Map&quot;,2D)&#x3D;&quot;bump&quot;&#123;&#125;    _BumpScale(&quot;Bump Scale&quot;,float)&#x3D;1.0    _Specular(&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)    _Gloss(&quot;Gloss&quot;,Range(8.0,256))&#x3D;20    &#125;SubShader&#123;        pass&#123;            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _MainTex;            float4 _MainTex_ST;            sampler2D _BumpMap;            float4 _BumpMap_ST;            float _BumpScale;            fixed4 _Specular;            float _Gloss;                        struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;                float4 tangent:TANGENT;                float4 texcoord:TEXCOORD0;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float4 uv:TEXCOORD0;                float4 TtoW0:TEXCOORD1;                float4 TtoW1:TEXCOORD2;                float4 TtoW2:TEXCOORD3;                &#x2F;&#x2F;这一坨是切线空间转化到世界空间的变换矩阵，由于寄存器存不了3x3大小的，所以只能这样                &#x2F;&#x2F;w用来存储世界空间下的顶点位置            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.uv.xy&#x3D;v.texcoord.xy*_MainTex_ST.xy+_BumpMap_ST.zw;                o.uv.zw&#x3D;v.texcoord.xy*_MainTex_ST.xy+_BumpMap_ST.zw;                                float3 worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                &#x2F;&#x2F;世界空间下顶点位置                fixed3 worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);                &#x2F;&#x2F;世界空间下法线                fixed3 worldTangent&#x3D;UnityObjectToWorldDir(v.tangent.xyz);                &#x2F;&#x2F;世界空间下切线                fixed3 worldBinormal&#x3D;cross(worldNormal,worldTangent)*v.tangent.w;&#x2F;&#x2F;世界空间下副切线                o.TtoW0&#x3D;float4(worldTangent.x,worldBinormal.x,worldNormal.x,worldPos.x);                o.TtoW1&#x3D;float4(worldTangent.y,worldBinormal.y,worldNormal.y,worldPos.y);                o.TtoW2&#x3D;float4(worldTangent.z,worldBinormal.z,worldNormal.z,worldPos.z);                &#x2F;&#x2F;按列拜访得到切线空间到世界空间的变换矩阵                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                float3 worldPos&#x3D;float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);                &#x2F;&#x2F;构建世界空间下坐标                fixed3 lightDir&#x3D;normalize(UnityWorldSpaceLightDir(worldPos));                fixed3 viewDir&#x3D;normalize(UnityWorldSpaceViewDir(worldPos));                fixed3 bump&#x3D;UnpackNormal(tex2D(_BumpMap,i.uv.zw));                &#x2F;&#x2F;法线方向（但是这里是切线空间下的）                bump.xy*&#x3D;_BumpScale;                bump.z&#x3D;sqrt(1.0-saturate(dot(bump.xy,bump.xy)));                bump&#x3D;normalize(half3(dot(i.TtoW0.xyz,bump),dot(i.TtoW1.xyz,bump),dot(i.TtoW2.xyz,bump)));                &#x2F;&#x2F;将法线变换到世界空间下                fixed3 albedo&#x3D;tex2D(_MainTex,i.uv).rgb*_Color.rgb;                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;                fixed3 diffuse&#x3D;_LightColor0.rgb*albedo*max(0,dot(bump,lightDir));                fixed3 halfDir&#x3D;normalize(lightDir+viewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(bump,halfDir)),_Gloss);                return fixed4(ambient+diffuse+specular,1.0);            &#125;            ENDCG            &#125;        &#125;    FallBack &quot;Specular&quot;    &#125;</code></pre><p>效果与使用切线空间大致相同。</p><h2 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>运用一个存储表面属性的纹理，进行控制漫反射光照的方法。这种方法相比使用兰伯特模型，可以更加灵活地控制光照结果。由万能的V社在《军团要塞2》中首次应用并提出。</p><h3 id="渐变纹理实践"><a href="#渐变纹理实践" class="headerlink" title="渐变纹理实践"></a>渐变纹理实践</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader&quot;Custom&#x2F;Ramp Texture&quot;&#123;    Properties    &#123;        _Color(&quot;Color Tint&quot;,Color)&#x3D;(1,1,1,1)        _RampTex(&quot;Ramp Tex&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;        _Specular(&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)        _Gloss(&quot;Gloss&quot;,Range(8.0,256))&#x3D;20        &#125;    SubShader&#123;        pass&#123;            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Color;            sampler2D _RampTex;            float4 _RampTex_ST;            fixed4 _Specular;            float _Gloss;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;                float4 texcoord:TEXCOORD0;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;                float2 uv:TEXCOORD2;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal&#x3D;UnityObjectToWorldNormal(v.normal);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                o.uv&#x3D;TRANSFORM_TEX(v.texcoord,_RampTex);                return o;            &#125;            fixed4 frag(v2f i):SV_Target            &#123;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                fixed3 worldLightDir&#x3D;normalize(UnityWorldSpaceLightDir(i.worldPos));                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed halfLambert&#x3D;0.5*dot(worldNormal,worldLightDir)+0.5;                &#x2F;&#x2F;计算半兰伯特模型，因为此时半兰伯特范围也是[0,1]，正好拿来做纹理采样                &#x2F;&#x2F;由于渐变纹理只有一个坐标（纵轴颜色不变），所以拿fixed采样                fixed3 diffuseColor&#x3D;tex2D(_RampTex,fixed2(halfLambert,halfLambert)).rgb*_Color.rgb;                fixed3 diffuse&#x3D;_LightColor0.rgb*diffuseColor;                &#x2F;&#x2F;将纹理采样的颜色和材质颜色相乘，得到最终漫反射颜色                fixed3 viewDir&#x3D;normalize(UnityWorldSpaceViewDir(i.worldPos));                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);                return fixed4(ambient+specular+diffuse,1.0);            &#125;            ENDCG        &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><p><strong>此时需要把Wrap Mode设置成Clamp模式</strong>，防止纹理采样因为浮点数精度产生的问题。（虽然半兰伯特范围是[0,1]，但也会存在1.000001的情况，此时如果是repeat直接舍弃整数部分变成0.000001，就是黑色了。</p><h2 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>运用遮罩纹理保护某些区域免于修改，比如希望模型表面一些区域更亮，一些区域更暗，就可以使用一张遮罩纹理控制光照。</p><p>具体流程是：通过采样得到遮罩纹理的纹素值，使用某个通道的值（比如rgb中的r）与表面属性相乘。当通道值为0说明不受属性保护。</p><h3 id="遮罩纹理实践"><a href="#遮罩纹理实践" class="headerlink" title="遮罩纹理实践"></a>遮罩纹理实践</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Chapter7-MaskTexture&quot;&#123;    Properties    &#123;        _Color (&quot;Color Tint&quot;, Color) &#x3D; (1,1,1,1)        _MainTex (&quot;Main Tex&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125;        _BumpMap(&quot;Normal Map&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;        _BumpScale(&quot;Bump Scale&quot;,Float)&#x3D;1.0        _SpecularMask(&quot;Specular Mask&quot;,2D)&#x3D;&quot;white&quot;&#123;&#125;        &#x2F;&#x2F;高光反射的遮罩纹理        _SpecularScale(&quot;Specular Scale&quot;,Float)&#x3D;1.0        &#x2F;&#x2F;遮罩影响度的系数        _Specular(&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)        _Gloss(&quot;Gloss&quot;,Range(8.0,256))&#x3D;20    &#125;    SubShader    &#123;        pass&#123;        Tags &#123; &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot; &#125;        CGPROGRAM        #pragma vertex vert        #pragma fragment frag        #include &quot;Lighting.cginc&quot;        fixed4 _Color;        sampler2D _MainTex;        float4 _MainTex_ST;        &#x2F;&#x2F;三个纹理共同使用一个纹理属性        sampler2D _BumpMap;        float _BumpScale;        sampler2D _SpecularMask;        float _SpecularScale;        fixed4 _Specular;        float _Gloss;        struct a2v        &#123;            float4 vertex:POSITION;            float3 normal:NORMAL;            float4 tangent:TANGENT;            float4 texcoord:TEXCOORD0;        &#125;;        struct v2f        &#123;            float4 pos:SV_POSITION;            float2 uv:TEXCOORD0;            float3 lightDir:TEXCOORD1;            float3 viewDir:TEXCOORD2;        &#125;;        v2f vert(a2v v)        &#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            o.uv.xy&#x3D;v.texcoord.xy*_MainTex_ST.xy+_MainTex_ST.zw;                        TANGENT_SPACE_ROTATION;            o.lightDir&#x3D;mul(rotation,ObjSpaceLightDir(v.vertex)).xyz;            o.viewDir&#x3D;mul(rotation,ObjSpaceViewDir(v.vertex)).xyz;            return o;        &#125;        fixed4 frag(v2f i):SV_Target        &#123;            fixed3 tangentLightDir&#x3D;normalize(i.lightDir);            fixed3 tangentViewDir&#x3D;normalize(i.viewDir);            fixed3 tangentNormal&#x3D;UnpackNormal(tex2D(_BumpMap,i.uv));            tangentNormal.xy*&#x3D;_BumpScale;            tangentNormal.z&#x3D;sqrt(1.0-saturate(dot(tangentNormal.xy,tangentNormal.xy)));            fixed3 albedo&#x3D;tex2D(_MainTex,i.uv).rgb*_Color.rgb;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz*albedo;            fixed3 diffuse&#x3D;unity_LightColor0.rgb*albedo*max(0,dot(tangentNormal,tangentLightDir));            fixed3 halfDir&#x3D;normalize(tangentLightDir+tangentViewDir);            fixed specularMask&#x3D;tex2D(_SpecularMask,i.uv).r*_SpecularScale;            &#x2F;&#x2F;对遮罩纹理进行采样，将得到的掩码值乘上影响度            fixed3 specular&#x3D;unity_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(tangentNormal,halfDir)),_Gloss)*specularMask;            return fixed4(ambient+diffuse+specular,1.0);        &#125;        ENDCG    &#125;        &#125;    FallBack &quot;Specular&quot;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Shader" scheme="https://karmotrine.fun/categories/Shader/"/>
    
    
    <category term="笔记" scheme="https://karmotrine.fun/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Shader" scheme="https://karmotrine.fun/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity Shader01——光照</title>
    <link href="https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/"/>
    <id>https://karmotrine.fun/2022/01/11/Unity-Shader01%E2%80%94%E2%80%94%E5%85%89%E7%85%A7/</id>
    <published>2022-01-11T06:20:49.000Z</published>
    <updated>2022-01-15T07:03:23.007Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27876224&auto=1&height=66"></iframe><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个并不是技术分享的教程类博客，只是我记录的笔记而已。不，不要误会了！<del>（虽然溜一遍下来法线好像也能看</del></p><h2 id="Shader基础"><a href="#Shader基础" class="headerlink" title="Shader基础"></a>Shader基础</h2><h3 id="顶点着色器和片元着色器"><a href="#顶点着色器和片元着色器" class="headerlink" title="顶点着色器和片元着色器"></a>顶点着色器和片元着色器</h3><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>顶点着色器是流水线的第一个阶段。它负责坐标变换以及逐顶点光照。比如把顶点坐标从模型空间转换到齐次裁剪空间，逐顶点光照在后面会说。</p><h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><p>片元着色器又称为像素着色器，它的输入是上一个阶段对定点信息插值得到的结果，输出是一个或者多个颜色值。在这个阶段可以完成很多重要渲染技术（纹理采样）。但是它只能影响单个片元，无法将任何结果发给其他人。</p><h3 id="Shader的结构"><a href="#Shader的结构" class="headerlink" title="Shader的结构"></a>Shader的结构</h3><pre class="language-ShaderLab" data-language="ShaderLab"><code class="language-ShaderLab">Shader&quot;MyShaderName&quot; &#x2F;&#x2F;Shader的名字，里面添加&#x2F;可以创建文件夹&#123;Properties&#123;&#x2F;&#x2F;属性，声明一些着色需要的变量_Color(&quot;Color Tint&quot;,Color)&#x3D;(1,1,1,1)&#x2F;&#x2F;代码内叫啥(&quot;窗口里叫啥&quot;,啥类型)&#x3D;赋值&#125;SubShader&#123;&#x2F;&#x2F;针对显卡A的SubShaderPass&#123;&#x2F;&#x2F;设置渲染状态和标签，此时声明Properties的变量Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;CGPROGRAM &#x2F;&#x2F;开始CG代码的片段&#x2F;&#x2F;该代码片段的编译指令：#pragma vertex vert &#x2F;&#x2F;vert函数为顶点着色方式#pragma fragment frag &#x2F;&#x2F;frag函数为片元着色方式#include &quot;Lighting.cginc&quot; &#x2F;&#x2F;声明引用的头文件struct a2v&#123;&#x2F;&#x2F;可以在这里声明结构体&#125;;struct v2f&#123;&#125;;v2f vert(a2v v)&#123;&#x2F;&#x2F;进行顶点着色器的相关操作&#125;fixed4 frag(v2f i):SV_Target&#123;&#x2F;&#x2F;进行片元着色器的相关操作&#125;ENDCG &#x2F;&#x2F;结束CG代码的片段&#125;&#x2F;&#x2F;其它需要的Pass&#125;FallBack &quot;Diffuse&quot;&#x2F;&#x2F;如果上面SubShader全寄了，就回调双引号内的Unity Shader&#125;</code></pre><h3 id="变量声明形式"><a href="#变量声明形式" class="headerlink" title="变量声明形式"></a>变量声明形式</h3><p>fixed4 :什么精度的数字+多少个连一起</p><p>精度： fixed&lt;half&lt;float</p><h2 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h2><p>在标准光照模型中，把进入摄像机的模型分成四部分，每个部分分别计算贡献度。四个部分分别为<strong>自发光、高光反射、漫反射、环境光</strong>。</p><h3 id="环境光-ambient"><a href="#环境光-ambient" class="headerlink" title="环境光(ambient)"></a>环境光(ambient)</h3><p>用来模拟间接光照。简介光照指在多个物体反射后进入摄像机的光线。环境光为一个全局变量，计算等式为：</p><p>$$ c_{ambient}=g_{ambient} $$</p><p>在Shader中，我们通过Unity内置变量UNITY_LIGHTMODEL_AMBIENT直接获得环境光颜色和强度信息。</p><h3 id="自发光-emissive"><a href="#自发光-emissive" class="headerlink" title="自发光(emissive)"></a>自发光(emissive)</h3><p>直接从光源进入摄像机的光线，计算等式为：</p><p>$$ c_{emissive}=m_{emissive} $$</p><p>由于大部分物体没有自发光特性，所以不存在Unity变量。对于存在自发光特性的物体，我们要先把材质的自发光颜色添加到输出颜色上再输出就行了。</p><h3 id="漫反射-diffuse"><a href="#漫反射-diffuse" class="headerlink" title="漫反射(diffuse)"></a>漫反射(diffuse)</h3><p>用于对那些被物体表面随机散射到各个方向的辐射度进行建模。该光照符合<strong>兰伯特定律</strong>:</p><p>$$ c_{diffuse}=(c_{light}*m_{diffuse})max(0,\hat{n}*\hat{l}) $$</p><p>其中<em><strong>c</strong></em>light是光源颜色，<em><strong>m</strong></em>diffuse是材质的漫反射颜色，<em><strong>n</strong></em>为表面法线，<em><strong>l</strong></em>为指向光源的单位矢量。当两者夹角为0时，说明光源直射，为最大值1.当两者垂直时值为0，说明光源射不到该表面。而大于90度已经是负值（没有光线反射），所以也算作是0.</p><h3 id="高光反射-specular"><a href="#高光反射-specular" class="headerlink" title="高光反射(specular)"></a>高光反射(specular)</h3><p>指完全沿着镜面反射方向被反射的光线，让物体看起来是有光泽的。</p><h4 id="Phong模型"><a href="#Phong模型" class="headerlink" title="Phong模型"></a>Phong模型</h4><p>计算高光反射所需信息有表面法线，视角方向，光源方向和反射方向等。其中反射方向可以通过前两个计算而得出：</p><p>$$ \hat{r}=2*(\hat(n)*\hat(l))*\hat(n)-\hat(l)$$</p><p>（知道法线方向和入射方向求反射方向属于是初中知识了。。。）</p><p>这样可以通过上述信息，使用Phong模型计算高光反射的部分：</p><p>$$ c_{specular}=（c_{light}*m_{specular})max(0,\hat{v}*\hat{r})^m_{gloss}$$</p><p>其中<strong>m</strong>gloss为光泽度，用于控制高光区域“亮点”的宽度。光泽度越大亮点越小。（毕竟下面范围是[0,1]，肯定越大是越小的）<strong>m</strong>specular是材料的高光反射，控制强度和颜色。<strong>c</strong>light是光源颜色和强度。</p><h4 id="Blinn模型"><a href="#Blinn模型" class="headerlink" title="Blinn模型"></a>Blinn模型</h4><p>另一种高光反射模型为Blinn模型。它与Phong模型的区别在于避免计算反射方向，而是在对光源方向和视角方向取平均后再归一化后，引入新的矢量得到的。即</p><p>$$\hat(h)={\frac {\hat(v)+\hat(l)}{\lvert \hat(v)+\hat(l) \rvert}}$$</p><p>后面就和Phong模型差不多，但是是拿n和h之间的夹角计算：</p><p>$$ c_{specular}=（c_{light}*m_{specular})max(0,\hat{n}*\hat{h})^m_{gloss}$$</p><h3 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h3><p>计算光照可以在两个着色器中计算。其中在片元着色器计算叫做<strong>逐像素光照</strong>（Phong着色），在顶点着色器中计算叫做<strong>逐顶点光照</strong>（高洛德着色）。</p><p>由于逐顶点光照只需在每个顶点上计算光照，然后再渲染图元内部线性插值，所以计算量小于逐像素光照。但由于存在非线性计算时，过度依赖线性插值的逐顶点光照就会产生问题。（特别是在高光反射上）</p><h2 id="漫反射光照模型实践"><a href="#漫反射光照模型实践" class="headerlink" title="漫反射光照模型实践"></a>漫反射光照模型实践</h2><h3 id="逐顶点光照计算"><a href="#逐顶点光照计算" class="headerlink" title="逐顶点光照计算"></a>逐顶点光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Diffuse Vertex-Level&quot;&#123;    Properties    &#123;        _Diffuse(&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)        &#x2F;&#x2F;控制材质的漫反射颜色，可以在hierachy窗口调整    &#125;    SubShader    &#123;        pass&#123;        &#x2F;&#x2F;定义正确的LightMode才能得到Unity的内置光照变量（如_LightColor0）        Tags &#123; &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot; &#125;        CGPROGRAM        #pragma vertex vert        #pragma fragment frag                &#x2F;&#x2F;需要使用下面的内置文件        #include &quot;Lighting.cginc&quot;&#x2F;&#x2F;只有定义一个和Properties类型匹配的变量才能使用Properties内变量        fixed4 _Diffuse;        struct a2v&#123;            float4 vertex:POSITION;            float3 normal:NORMAL; &#x2F;&#x2F;告诉Unity将模型顶点法线信息存储到normal变量内        &#125;;        struct v2f&#123;            float4 pos:SV_POSITION;            fixed3 color:COLOR;        &#125;;        v2f vert(a2v v)&#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            &#x2F;&#x2F;将顶点位置从模型空间转换到裁剪空间            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;            &#x2F;&#x2F;获取环境光部分            fixed3 worldNormal&#x3D;normalize(mul(v.normal,(float3x3)unity_WorldToObject));            &#x2F;&#x2F;我们选用世界坐标下计算，而v.normal为模型空间下的，所以需要转化为世界坐标            &#x2F;&#x2F;转化流程为得到两空间的变换矩阵的逆矩阵unity_WorldToObject，然后和法线相乘            &#x2F;&#x2F;由于法线为一个三维向量，所以只需要截取前三行前三列            fixed3 worldLight&#x3D;normalize(_WorldSpaceLightPos0.xyz);            &#x2F;&#x2F;将光源方向归一化处理            fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLight));            &#x2F;&#x2F;计算漫反射光照            o.color&#x3D;ambient+diffuse;            &#x2F;&#x2F;将漫反射光和环境光部分相加，得到最终光照结果。            return o;        &#125;        fixed4 frag(v2f i):SV_TARGET&#123;            return fixed4(i.color,1.0);            &#x2F;&#x2F;由于所有计算在顶点着色器完成了，所以这里直接摸大鱼（        &#125;        ENDCG        &#125;    &#125;    FallBack &quot;Diffuse&quot;&#125;</code></pre><p><strong>saturate(x)</strong>:把x锁定在[0,1]范围内；</p><p><strong>normalize(x)</strong>:将x归一化，只留下方向；</p><p>**UnityObjectToClipPos(v)**：将顶点位置从模型空间转换到裁剪空间；</p><p><strong>mul(x,y)</strong>:计算两向量/一向量一矩阵/两矩阵相乘;</p><p><strong>dot(x,y)</strong>:计算x,y的点积。</p><h3 id="逐像素光照计算"><a href="#逐像素光照计算" class="headerlink" title="逐像素光照计算"></a>逐像素光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader&quot;Custom&#x2F;Diffuse Pixel-Level&#123;Properties    &#123;        _Diffuse(&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)    &#125;    SubShader    &#123;        pass&#123;        Tags &#123; &quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot; &#125;        CGPROGRAM        #pragma vertex vert        #pragma fragment frag                #include &quot;Lighting.cginc&quot;        fixed4 _Diffuse;        struct a2v&#123;            float4 vertex:POSITION;            float3 normal:NORMAL;        &#125;;        struct v2f&#123;            float4 pos:SV_POSITION;            float3 worldNormal:TEXTCOORD0;        &#125;;        v2f vert(a2v v)&#123;            v2f o;            o.pos&#x3D;UnityObjectToClipPos(v.vertex);            o.worldNormal&#x3D;mul(v.normal,(float3x3)unity_WorldToObject);            &#x2F;&#x2F;将法线从世界空间转换为模型空间            &#x2F;&#x2F;由于计算全给了片元着色器，所以这里摸大鱼(            return o;        &#125;        fixed4 frag(v2f i):SV_TARGET&#123;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT;            fixed3 worldNormal&#x3D;normalize(i.worldNormal);            fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);            fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));            fixed3 color&#x3D;ambient+diffuse;            return fixed4(color,1.0);        &#125;        ENDCG        &#125;    &#125;    FallBack &quot;Diffuse&quot;    &#125;</code></pre><p>完 全 相 同</p><h3 id="半兰伯特模型"><a href="#半兰伯特模型" class="headerlink" title="半兰伯特模型"></a>半兰伯特模型</h3><p>由于兰伯特光照模型没照到的地方全是0，莫得光暗变化，所以万能的v社在开发《半条命》的时候整了个半兰伯特光照模型，公式如下：</p><p>$$c_{diffuse}=(c_{light}*m_{diffuse})(0.5(\hat(n)*\hat(l))+0.5)$$</p><p>这样背光面也有明暗变化，视觉上加强了不少。</p><p><img src="%E5%AF%B9%E6%AF%94.png" alt="也亮堂了（" loading="lazy"></p><p>代码方面和逐像素计算差不多，但是修改的地方有：</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">fixed4 frag(v2f i):SV_TARGET&#123;            fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT;            fixed3 worldNormal&#x3D;normalize(i.worldNormal);            fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);            fixed halfLambert&#x3D;saturate(dot(worldNormal,worldLightDir))*0.5+0.5;            &#x2F;&#x2F;这里单独拎出来算了            fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*halfLambert;            fixed3 color&#x3D;ambient+diffuse;            return fixed4(color,1.0);        &#125;</code></pre><h2 id="高光反射光照模型实践"><a href="#高光反射光照模型实践" class="headerlink" title="高光反射光照模型实践"></a>高光反射光照模型实践</h2><p>之前提到过反射方向的计算公式：</p><p>$$ \hat{r}=2*(\hat(n)*\hat(l))*\hat(n)-\hat(l)$$</p><p>在Unity里，你只需要**reflect(i,n)**就可以（i入射方向，n法线方向）</p><h3 id="逐顶点光照计算-1"><a href="#逐顶点光照计算-1" class="headerlink" title="逐顶点光照计算"></a>逐顶点光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;Specular Vertex-Level&quot;&#123;    Properties    &#123;        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)        &#x2F;&#x2F;控制高光反射的颜色        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20        &#x2F;&#x2F;控制高光反射区域大小    &#125;    SubShader    &#123;        pass&#123;            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 color:COLOR;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                &#x2F;&#x2F;将顶点位置从模型空间转换到裁剪空间                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;                &#x2F;&#x2F;拿环境光                fixed3 worldNormal&#x3D;normalize(mul(v.normal,(float3x3)unity_WorldToObject));                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));                &#x2F;&#x2F;算漫反射光照                fixed3 reflectDir&#x3D;normalize(reflect(-worldLightDir,worldNormal));                &#x2F;&#x2F;计算反射方向，由于reflect函数入射方向要求从光源指向交点，所以worldLightDir要取反                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-mul(unity_ObjectToWorld,v.vertex).xyz);                &#x2F;&#x2F;_WorldSpaceCameraPos为摄像机位置，将顶点位置先转换为世界空间，然后与摄像机相减就是视角位置                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(reflectDir,viewDir)),_Gloss);                &#x2F;&#x2F;最后进行Phong模型的计算，得出高光反射的贡献度                o.color&#x3D;ambient+diffuse+specular;                &#x2F;&#x2F;与环境光、漫反射光相加，存储到最后的颜色里                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;            &#x2F;&#x2F;由于在顶点着色器都算完了，所以这里摸大鱼                return fixed4(i.color,1.0);            &#125;            ENDCG            &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><p>这时逐顶点计算高光反射的弊端就出现了：阴处都是一片片的。</p><p><img src="%E9%80%90%E9%A1%B6%E7%82%B9.png" alt="逐顶点" loading="lazy"></p><p>这是因为高光反射的计算是非线性的，而在顶点着色器里计算光照再插值是线性的。这样破坏了原来计算的非线性关系。</p><h3 id="逐像素光照计算-1"><a href="#逐像素光照计算-1" class="headerlink" title="逐像素光照计算"></a>逐像素光照计算</h3><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Unity Shader Book&#x2F;Chapter 6&#x2F;Specular Pixel-Level&quot;&#123;    Properties    &#123;        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20    &#125;    SubShader    &#123;        pass&#123;            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal&#x3D;mul(v.normal,(float3x3)unity_WorldToObject);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));                fixed3 reflectDir&#x3D;normalize(reflect(-worldLightDir,worldNormal));                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(saturate(dot(reflectDir,viewDir)),_Gloss);                return fixed4(ambient+diffuse+specular,1.0);            &#125;            ENDCG            &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><p>虽然计算过程基本相同，但是得出的效果更令人满意：</p><p><img src="%E9%80%90%E5%83%8F%E7%B4%A0.png" alt="逐像素" loading="lazy"></p><h3 id="Blinn-Phong模型计算"><a href="#Blinn-Phong模型计算" class="headerlink" title="Blinn-Phong模型计算"></a>Blinn-Phong模型计算</h3><p>由于逐顶点计算高光反射的拉跨程度，所以我们只用逐像素的方法来实践</p><pre class="language-Shader" data-language="Shader"><code class="language-Shader">Shader &quot;Custom&#x2F;BlinnPhong&quot;&#123;    Properties    &#123;        _Diffuse (&quot;Diffuse&quot;,Color)&#x3D;(1,1,1,1)        _Specular (&quot;Specular&quot;,Color)&#x3D;(1,1,1,1)        _Gloss (&quot;Gloss&quot;, Range(8.0,256))&#x3D;20    &#125;    SubShader    &#123;        pass&#123;            Tags&#123;&quot;LightMode&quot;&#x3D;&quot;ForwardBase&quot;&#125;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;Lighting.cginc&quot;            fixed4 _Diffuse;            fixed4 _Specular;            float _Gloss;            struct a2v            &#123;                float4 vertex:POSITION;                float3 normal:NORMAL;            &#125;;            struct v2f            &#123;                float4 pos:SV_POSITION;                float3 worldNormal:TEXCOORD0;                float3 worldPos:TEXCOORD1;            &#125;;            v2f vert(a2v v)            &#123;                v2f o;                o.pos&#x3D;UnityObjectToClipPos(v.vertex);                o.worldNormal&#x3D;mul(v.normal,(float3x3)unity_WorldToObject);                o.worldPos&#x3D;mul(unity_ObjectToWorld,v.vertex).xyz;                return o;            &#125;            fixed4 frag(v2f i):SV_Target&#123;                fixed3 ambient&#x3D;UNITY_LIGHTMODEL_AMBIENT.xyz;                fixed3 worldNormal&#x3D;normalize(i.worldNormal);                fixed3 worldLightDir&#x3D;normalize(_WorldSpaceLightPos0.xyz);                fixed3 diffuse&#x3D;_LightColor0.rgb*_Diffuse.rgb*saturate(dot(worldNormal,worldLightDir));                fixed3 reflectDir&#x3D;normalize(reflect(-worldLightDir,worldNormal));                fixed3 viewDir&#x3D;normalize(_WorldSpaceCameraPos.xyz-i.worldPos.xyz);                fixed3 halfDir&#x3D;normalize(worldLightDir+viewDir);                &#x2F;&#x2F;扣扣大，计算新矢量h                fixed3 specular&#x3D;_LightColor0.rgb*_Specular.rgb*pow(max(0,dot(worldNormal,halfDir)),_Gloss);                &#x2F;&#x2F;然后改成h和n点乘                return fixed4(ambient+diffuse+specular,1.0);            &#125;            ENDCG            &#125;    &#125;    FallBack &quot;Specular&quot;&#125;</code></pre><p>使用Blinn模型的高光反射部分看起来更大、更亮一些，所以大多数情况都会采用Blinn模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Shader" scheme="https://karmotrine.fun/categories/Shader/"/>
    
    
    <category term="笔记" scheme="https://karmotrine.fun/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Shader" scheme="https://karmotrine.fun/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>胡言乱语录的Unity一轮教程</title>
    <link href="https://karmotrine.fun/2022/01/10/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E5%BD%95%E7%9A%84Unity%E4%B8%80%E8%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://karmotrine.fun/2022/01/10/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD%E5%BD%95%E7%9A%84Unity%E4%B8%80%E8%BD%AE%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-10T14:55:28.000Z</published>
    <updated>2022-01-10T14:56:40.383Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简析Unity有限状态机的实现方法与使用</title>
    <link href="https://karmotrine.fun/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://karmotrine.fun/2022/01/09/%E7%AE%80%E6%9E%90Unity%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-09T14:58:15.000Z</published>
    <updated>2022-01-09T17:30:42.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1382359170&auto=1&height=66"></iframe><p>（冰海战记真好看，大家快点都去看）</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        寒假终于来力，有时间摸一摸博客了。今天就来介绍一下我一直很想写的有限状态机（FSM）。它虽然起步比较难，但是对于代码结构的优化和游戏人物的控制真的非常的舒适（起码不用声明114514个布尔值来控制角色的动作了）。如果有学弟看到我的这篇拙作也可以挑战一下使用有限状态机来做三轮捏（bushi</p><h2 id="为什么要使用FSM"><a href="#为什么要使用FSM" class="headerlink" title="为什么要使用FSM"></a>为什么要使用FSM</h2><h3 id="一个哈人的bug"><a href="#一个哈人的bug" class="headerlink" title="一个哈人的bug"></a>一个哈人的bug</h3><p>在解答这个问题之前，我想问问读者一个问题：</p><p>​        假如你是李华，你想通过一个程序来控制游戏内一个怪物的各种状态（比如走路，静止，攻击，跳跃，冲刺等等），让这个怪物血量每减少三分之一的时候会跳在中间捶地板，在平常的时候可以抡大锤砸玩家，在被逼到死角的时候使用锤子砸地形成一个冲击波，在把玩家逼到死角的时候会自动往后跳不至于逼死玩家。。。<del>（假骑士是什么，我不知道）</del>这样应该怎么写呢？我想大多数人会在控制怪物的脚本里先洋洋洒洒声明一堆布尔值（至少以前我是这样的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private bool isLuning; //正在抡大锤</span><br><span class="line">private bool isZaDaChui; //正在砸地形成冲击波</span><br><span class="line">private bool isHouTiao; //正在后跳</span><br><span class="line">private bool isChui; //正在捶地板</span><br></pre></td></tr></table></figure><p>​        我不能说这样做不对，因为事实上这样做是可以实现功能的。但是这样做却有一个隐患，就是切换不同状态时会发生问题。举个例子，当假骑士<del>（你刚刚说了假骑士对吧，对吧？！）</del>抡锤子时正好把玩家逼入了死角，同时血量掉了三分之一时，它应该被切换成什么状态呢？这个时候三个控制状态的布尔值都是真的，那假骑士这个时候要干什么，我是想都不敢想（</p><p>​        当一个角色的状态有很多时，如何顺利进行不同状态之间的过渡就成了我们头疼的事情。如果是怪物状态的控制那还好，因为怪物后面都是有着固定的逻辑的。但如果是玩家状态的控制呢？要知道，玩家背后的逻辑可是敢在酒吧里点炒饭，吃程序员不吐骨头的广大游戏玩家啊。当游戏玩家在奔跑时按下飞行键，或者在怕爬梯子时按下跳跃键，产生的后果肯定是让人啼笑皆非的。</p><p>​        而在上述的问题中，眼尖的读者就能看出真正的问题所在：这些问题的产生都是由于两个不同状态的同时进行导致的。也就是在跳跃时又进行了飞行的功能，在走路时又进行了奔跑的功能。那这样的话，我们只要用枚举的方式把所有状态囊括在一起不就好了嘛。因为枚举只能有一个状态，恰好可以完美解决上面的状态并发问题。而这个思想，也就是我今天想要写的有限状态机（FSM）。</p><h3 id="一个有限的状态机"><a href="#一个有限的状态机" class="headerlink" title="一个有限的状态机"></a>一个有限的状态机</h3><p>​        FSM，又称为有限状态机。它的意思就是我们列举出一系列有限的状态（以玩家本身为例，状态就有奔跑，静止，攻击，跳跃等等），以及这个状态应该运行的代码，其中包括状态开始，状态进行和状态结束的方法（比如跳跃的时候角色要先起跳，然后一直在半空什么的）。接着，我们编写一个程序来控制状态的切换以及进入一个状态在什么阶段应该运行的相关代码。由于这个状态是枚举的，而且有关动作只有在玩家当前为这个状态时才可以执行，所以理论上可以完美解决上面的问题。</p><p>​        这个结构其实在Unity内部就有了实践，那就是animator组件：</p><p><img src="animator.png" alt="animator" loading="lazy"></p><p>每个动画都被框在了一个状态里，只有当控制器运行到了这个状态时才会播放里面的动画，根本不会出现两个动画并发的现象，而我们的有限状态机也会沿用这个思想，只不过每个状态里存储的不是动画，而是一串串代码。</p><h2 id="如何构建有限状态机"><a href="#如何构建有限状态机" class="headerlink" title="如何构建有限状态机"></a>如何构建有限状态机</h2><p>​        有限状态机的图解如下：</p><h3 id="状态继承的接口IState"><a href="#状态继承的接口IState" class="headerlink" title="状态继承的接口IState"></a>状态继承的接口IState</h3><p>​        正如上文所说，状态机应该拥有进入这个状态，维持这个状态，以及退出这个状态的相应动作（就像碰撞检测中OnColliderEnter,OnColliderStay,OnColliderExit这仨一样）。所以作为每个状态都应该继承的接口应该有这三个对应的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IState</span><br><span class="line">&#123;</span><br><span class="line">    void OnEnter(); //进入状态的方法</span><br><span class="line">    void OnUpdate(); //维持状态的方法</span><br><span class="line">    void OnExit(); //退出状态的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="角色所有状态的枚举"><a href="#角色所有状态的枚举" class="headerlink" title="角色所有状态的枚举"></a>角色所有状态的枚举</h3><p>上文也提到了有限状态机的枚举思想，所以我们也需要一个枚举来囊括角色的所有状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum StateType</span><br><span class="line">&#123;</span><br><span class="line">    Enter,//入场</span><br><span class="line">    Defense,//防御</span><br><span class="line">    Die,//死亡</span><br><span class="line">    Attack,//攻击</span><br><span class="line">    RecoverHP,//回血</span><br><span class="line">    Dodge,//闪避</span><br><span class="line">    Idle //站着不动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这些状态都是你自己定的，上面这个例子的状态仅作为参考。</p><h3 id="每个相关状态的类"><a href="#每个相关状态的类" class="headerlink" title="每个相关状态的类"></a>每个相关状态的类</h3><p>接着就是每个状态独占的一个类了。通过继承IState接口，控制器脚本可以直接调用相关状态类的方法来控制角色的动作（这里以角色进场的状态为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class EnterState : IState //继承Istate接口</span><br><span class="line">&#123;</span><br><span class="line">    private FSM manager; //控制角色的控制器脚本，通过这个脚本来控制角色的状态（脚本在后文会说）</span><br><span class="line">    public EnterState(FSM manager) //每个状态类的构造方法</span><br><span class="line">    &#123;</span><br><span class="line">        this.manager = manager; //绑定控制器脚本，这样可以更方便调用状态类内部方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnEnter() //进入这个状态应该进行的方法</span><br><span class="line">    &#123;</span><br><span class="line">        manager.currentStateType = StateType.Enter;  </span><br><span class="line">        //让控制器脚本的当前状态改成该状态（你都进入这个状态了，当前状态也肯定是这个）</span><br><span class="line">        manager.PlayAnimation(manager.animationNames.Anim_Enter);</span><br><span class="line">        //让控制器脚本播放这个状态的相关动画</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnUpdate() //维持这个状态的方法</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public void OnExit() //退出这个状态应该执行的方法</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架仅仅是最简单的状态。如果你的状态还需要更多的动作的话还要进行更多的操作（这里以角色的攻击为例，代码我不想细说，只是体现你可以在上面框架的基础上随便添加别的东西而已）<del>（一个猜想，你是不是想水字数）</del>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public class PAttackState : IState</span><br><span class="line">&#123;</span><br><span class="line">    private PlayerFSM manager;</span><br><span class="line">    private PAttackSkill currentEnemySkill;</span><br><span class="line"></span><br><span class="line">    public PAttackState(PlayerFSM manager)</span><br><span class="line">    &#123;</span><br><span class="line">        this.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnEnter()</span><br><span class="line">    &#123;</span><br><span class="line">        manager.currentStateType = StateType.Attack;</span><br><span class="line">        manager.PlayAnimation(currentEnemySkill.anim);</span><br><span class="line">        #region 判断在不在行为树上</span><br><span class="line">        if (currentEnemySkill.attackType == BehaviourClass.HeavyHit)</span><br><span class="line">        &#123;</span><br><span class="line">            manager.currentAct *= 2;</span><br><span class="line">            if (manager.currentAct &gt; 256)</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (manager.actTree[manager.currentAct].BehaviourClass == BehaviourClass.HeavyHit)</span><br><span class="line">            &#123;</span><br><span class="line">                SetAffect(manager.actTree[manager.currentAct].AffectClass);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (currentEnemySkill.attackType == BehaviourClass.LightHit)</span><br><span class="line">        &#123;</span><br><span class="line">            manager.currentAct *= 2;</span><br><span class="line">            manager.currentAct++;</span><br><span class="line">            if (manager.currentAct &gt; 256)</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (manager.actTree[manager.currentAct].BehaviourClass == BehaviourClass.LightHit)</span><br><span class="line">            &#123;</span><br><span class="line">                SetAffect(manager.actTree[manager.currentAct].AffectClass);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                manager.currentAct = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SetAffect(AffectClass affectClass)</span><br><span class="line">    &#123;</span><br><span class="line">        switch (affectClass)</span><br><span class="line">        &#123;</span><br><span class="line">            case AffectClass.AddDamage:</span><br><span class="line">                currentEnemySkill.damage = (int)(currentEnemySkill.damage * 1.5f);</span><br><span class="line">                break;</span><br><span class="line">            case AffectClass.BreakDefense:</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case AffectClass.LongDizzy:</span><br><span class="line">                &#123;</span><br><span class="line">                    currentEnemySkill.dizzy += 2;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            case AffectClass.ShortDizzy:</span><br><span class="line">                &#123;</span><br><span class="line">                    currentEnemySkill.dizzy++;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        if (manager.IsAnimationEnd())</span><br><span class="line">        &#123;</span><br><span class="line">            manager.TransitionState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ReSharper disable Unity.PerformanceAnalysis</span><br><span class="line">    public void OnExit()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 返回当前招式</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public PAttackSkill GetCurrentSkill()</span><br><span class="line">    &#123;</span><br><span class="line">        return currentEnemySkill;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 设置当前连招</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void SetCurrentSkill(PAttackSkill attack)</span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemySkill = attack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重头戏：控制器脚本"><a href="#重头戏：控制器脚本" class="headerlink" title="重头戏：控制器脚本"></a>重头戏：控制器脚本</h3><p>控制器脚本是十分重要的脚本，可以说是有限状态机的核心所在。它的任务是记录当前的状态，根据不同条件切换状态，以及执行相关状态的代码。这也是有限状态机的难点所在。</p><p>下面贴出的代码只是针对之前项目特化的控制器脚本，大家扫一眼就好。接着我会分模块讲解控制器脚本应该有什么。<del>（你是不是又在水字数）</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 有限状态机</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">[RequireComponent(typeof(Feedback))]//需要反馈类</span><br><span class="line">public class FSM : MonoBehaviour</span><br><span class="line">&#123;   </span><br><span class="line">    public GameObject character;</span><br><span class="line">    public FSM_Parameter parameter;//声明参数类，在编辑面板编辑其参数</span><br><span class="line">    public FSM_AnimationNames animationNames;//声明动画类</span><br><span class="line">    public FSM_SoundEffects soundEffects;//声明音效类</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public int hp;//实时血量</span><br><span class="line">    [HideInInspector] public bool isDefense;//是否处于防御状态</span><br><span class="line"></span><br><span class="line">    private Animator animator;//动画组件</span><br><span class="line">    protected SoundManager soundManager;</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public IState currentState;//当前状态</span><br><span class="line">    [HideInInspector] public Dictionary&lt;StateType, IState&gt; states = new Dictionary&lt;StateType, IState&gt;();//创建字典，以枚举类型StateType作为Key</span><br><span class="line">    public StateType currentStateType;//当前状态类型</span><br><span class="line"></span><br><span class="line">    //敌人需要</span><br><span class="line">    [HideInInspector] public int index1;//当前连招数指示器</span><br><span class="line"></span><br><span class="line">    protected virtual void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        character = transform.GetChild(0).gameObject;</span><br><span class="line">        #region 注册状态</span><br><span class="line">        //添加键值对</span><br><span class="line">        states.Add(StateType.Enter, new EnterState(this));</span><br><span class="line">        states.Add(StateType.Defense, new DefenseState(this));</span><br><span class="line">        states.Add(StateType.Die, new DieState(this));</span><br><span class="line">        states.Add(StateType.RecoverHP, new RecoverHPState(this));</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        hp = parameter.HP;//血量初始为最大值</span><br><span class="line"></span><br><span class="line">        animator = character.GetComponent&lt;Animator&gt;();//获取动画器组件</span><br><span class="line">        soundManager = GameObject.FindGameObjectWithTag(&quot;SoundManager&quot;).GetComponent&lt;SoundManager&gt;();//获取声音管理器</span><br><span class="line">        TransitionState(StateType.Enter);//设置初始状态为入场状态</span><br><span class="line">    &#125;</span><br><span class="line">    protected virtual void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnUpdate();//在Update中进行当前状态的OnUpdate方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #region FSM为状态类及反馈类等提供的方法</span><br><span class="line"></span><br><span class="line">    #region 转换状态方法及重载</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 状态结束后默认调用此方法，进行状态间的过渡</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void TransitionState()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为指定状态</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;type&quot;&gt;指定状态&lt;/param&gt;</span><br><span class="line">    public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;攻击状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;攻击类型&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState,AttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((AttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 主角转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState, PAttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((PAttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为回血状态，并提供回血量</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;RecoverHPState&quot;&gt;回血状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType RecoverHPState, int health)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.RecoverHP];//切换当前状态</span><br><span class="line">        ((RecoverHPState)states[StateType.RecoverHP]).health = health;</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为防御状态，并提供防御时间</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;DefenseState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;defenseTime&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected virtual void TransitionState(StateType DefenseState, float defenseTime)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DefenseState==StateType.Defense)</span><br><span class="line">        &#123;</span><br><span class="line">                //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">                if (currentState != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentState.OnExit();</span><br><span class="line">                &#125;</span><br><span class="line">                ((DefenseState)states[StateType.Defense]).defenseTime = defenseTime;</span><br><span class="line">            currentState = states[StateType.Defense];//切换当前状态</span><br><span class="line">                </span><br><span class="line">                currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">        else if(DefenseState==StateType.Dodge)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">            if (currentState != null)</span><br><span class="line">            &#123;</span><br><span class="line">                currentState.OnExit();</span><br><span class="line">            &#125;</span><br><span class="line">            currentState = states[StateType.Dodge];//切换当前状态</span><br><span class="line">            ((DodgeState)states[StateType.Dodge]).dodgeTime = defenseTime;</span><br><span class="line">            currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #endregion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void GetDizzy(float time)</span><br><span class="line">    &#123;</span><br><span class="line">        TransitionState(StateType.Idle,time);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 回血方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    public void Recover(int health)</span><br><span class="line">    &#123;</span><br><span class="line">        PlaySoundEffect(soundEffects.recoverAudioClip);</span><br><span class="line">        hp = hp + health &gt; parameter.HP ? parameter.HP : hp + health;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 受击方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;damage&quot;&gt;伤害值&lt;/param&gt;</span><br><span class="line">    public virtual void GetInjured(int damage)</span><br><span class="line">    &#123;</span><br><span class="line">        #region 防御判定</span><br><span class="line">        if (isDefense)</span><br><span class="line">        &#123;</span><br><span class="line">            PlaySoundEffect(soundEffects.defenseAudioClip);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        PlayAnimation(animationNames.Anim_Injured);//播放受伤动画</span><br><span class="line">        PlaySoundEffect(soundEffects.injuredAudioClip);//播放受伤音效</span><br><span class="line"></span><br><span class="line">        hp -= damage;//减血</span><br><span class="line"></span><br><span class="line">        #region 死亡判定</span><br><span class="line">        if (hp &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            hp = 0;</span><br><span class="line">            TransitionState(StateType.Die);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 死亡方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void Die()</span><br><span class="line">    &#123;</span><br><span class="line">        PlaySoundEffect(soundManager.end);</span><br><span class="line">        #region 测试用，播完动画后销毁物体什么的</span><br><span class="line">        Debug.Log(&quot;死啦&quot;);</span><br><span class="line">        #endregion</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 被破防方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public void GetDefenseBroken()</span><br><span class="line">    &#123;</span><br><span class="line">        if (currentState == states[StateType.Defense])</span><br><span class="line">        &#123;</span><br><span class="line">            PlayAnimation(animationNames.Anim_Idle);</span><br><span class="line">            isDefense = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 播放动画方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;anim&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public virtual void PlayAnimation(string anim)</span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(anim,-1,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 判断动画是否播放完毕的方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">    public bool IsAnimationEnd()</span><br><span class="line">    &#123; </span><br><span class="line">        AnimatorStateInfo info =animator.GetCurrentAnimatorStateInfo(0);</span><br><span class="line">        if (info.normalizedTime &gt;= 1.0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 播放音效方法</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    protected virtual void PlaySoundEffect(AudioClip soundEffect)</span><br><span class="line">    &#123;</span><br><span class="line">        if (soundEffect == null) return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #endregion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明部分"><a href="#声明部分" class="headerlink" title="声明部分"></a>声明部分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public GameObject character;</span><br><span class="line">    public FSM_Parameter parameter;//声明参数类，在编辑面板编辑其参数</span><br><span class="line">    public FSM_AnimationNames animationNames;//声明动画类</span><br><span class="line">    public FSM_SoundEffects soundEffects;//声明音效类</span><br><span class="line"></span><br><span class="line">    private Animator animator;//动画组件</span><br><span class="line">    protected SoundManager soundManager;</span><br><span class="line"></span><br><span class="line">    [HideInInspector] public IState currentState;//当前状态</span><br><span class="line">    [HideInInspector] public Dictionary&lt;StateType, IState&gt; states = new Dictionary&lt;StateType, IState&gt;();//创建字典，以枚举类型StateType作为Key</span><br><span class="line">    public StateType currentStateType;//当前状态类型</span><br><span class="line"></span><br><span class="line">    //敌人需要</span><br><span class="line">    [HideInInspector] public int index1;//当前连招数指示器</span><br></pre></td></tr></table></figure><p>声明的变量主要包括两个部分：</p><h5 id="1-杂七杂八部分"><a href="#1-杂七杂八部分" class="headerlink" title="1.杂七杂八部分"></a>1.杂七杂八部分</h5><p>这个部分主要是玩家控制角色的音效、动画、血量属性方面的变量。当然这也是每个角色脚本必须的东西。（上面自定义的FSM_blabla类也是这个里面的，不用在意）。</p><h5 id="2-状态控制相关"><a href="#2-状态控制相关" class="headerlink" title="2.状态控制相关"></a>2.状态控制相关</h5><p>（1)字典states：它主要用来绑定每个枚举类型（状态名）和状态类（这个状态应该进行的方法）。通过这个字典我们可以直接通过当前角色的状态来找到这个状态应该执行的代码</p><p>（2）当前状态的类：虽然有字典，但是通过字典找到方法的过程未免还是太慢了。所以还是要个状态类存储当前状态</p><p>（3）当前状态的枚举：存储当前状态的相关枚举。没有这个，有限状态机的实现可以说是不可能。</p><h4 id="Start方法"><a href="#Start方法" class="headerlink" title="Start方法"></a>Start方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        character = transform.GetChild(0).gameObject;</span><br><span class="line">        #region 注册状态</span><br><span class="line">        //添加键值对</span><br><span class="line">        states.Add(StateType.Enter, new EnterState(this));</span><br><span class="line">        states.Add(StateType.Defense, new DefenseState(this));</span><br><span class="line">        states.Add(StateType.Die, new DieState(this));</span><br><span class="line">        states.Add(StateType.RecoverHP, new RecoverHPState(this));</span><br><span class="line">        #endregion</span><br><span class="line"></span><br><span class="line">        hp = parameter.HP;//血量初始为最大值</span><br><span class="line"></span><br><span class="line">        animator = character.GetComponent&lt;Animator&gt;();//获取动画器组件</span><br><span class="line">        soundManager = GameObject.FindGameObjectWithTag(&quot;SoundManager&quot;).GetComponent&lt;SoundManager&gt;();//获取声音管理器</span><br><span class="line">        TransitionState(StateType.Enter);//设置初始状态为入场状态</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还是三类：</p><h5 id="1-杂七杂八部分-1"><a href="#1-杂七杂八部分-1" class="headerlink" title="1.杂七杂八部分"></a>1.杂七杂八部分</h5><p>也就是获取相关组件，把角色基础属性确定好。</p><h5 id="2-注册键值对"><a href="#2-注册键值对" class="headerlink" title="2.注册键值对"></a>2.注册键值对</h5><p>往声明的字典里狂暴注入该角色应该有的所有状态的键值对，其中键值对里<code>new EnterState(this)</code>里面的this指的是控制器脚本（别忘了状态类构造方法里的变量:<code>FSM manager</code>）</p><h5 id="3-设置入场状态"><a href="#3-设置入场状态" class="headerlink" title="3.设置入场状态"></a>3.设置入场状态</h5><p>如果你的角色有什么入场状态（比如芬达哥开场要来一句战吼：“啊！！！！！芬达！！！！！！”什么的），最好在这里就可以转换状态了。</p><h4 id="Update方法"><a href="#Update方法" class="headerlink" title="Update方法"></a>Update方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnUpdate();//在Update中进行当前状态的OnUpdate方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这就很简单了。如何让维持这个状态的方法一直运行？直接把它丢进Update里就行了！</p><h4 id="状态转换方法和重载"><a href="#状态转换方法和重载" class="headerlink" title="状态转换方法和重载"></a>状态转换方法和重载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#region 转换状态方法及重载</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 状态结束后默认调用此方法，进行状态间的过渡</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public virtual void TransitionState()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为指定状态</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;type&quot;&gt;指定状态&lt;/param&gt;</span><br><span class="line">    public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为攻击状态，并指定攻击类型</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;AttackState&quot;&gt;攻击状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;attackType&quot;&gt;攻击类型&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType AttackState,AttackSkill attackType)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.Attack];//切换当前状态</span><br><span class="line">        ((AttackState)states[StateType.Attack]).SetCurrentSkill(attackType);</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为回血状态，并提供回血量</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;RecoverHPState&quot;&gt;回血状态&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;health&quot;&gt;回血量&lt;/param&gt;</span><br><span class="line">    protected void TransitionState(StateType RecoverHPState, int health)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[StateType.RecoverHP];//切换当前状态</span><br><span class="line">        ((RecoverHPState)states[StateType.RecoverHP]).health = health;</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 转换为防御状态，并提供防御时间</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;DefenseState&quot;&gt;&lt;/param&gt;</span><br><span class="line">    /// &lt;param name=&quot;defenseTime&quot;&gt;&lt;/param&gt;</span><br><span class="line">    protected virtual void TransitionState(StateType DefenseState, float defenseTime)</span><br><span class="line">    &#123;</span><br><span class="line">        if (DefenseState==StateType.Defense)</span><br><span class="line">        &#123;</span><br><span class="line">                //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">                if (currentState != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentState.OnExit();</span><br><span class="line">                &#125;</span><br><span class="line">                ((DefenseState)states[StateType.Defense]).defenseTime = defenseTime;</span><br><span class="line">            currentState = states[StateType.Defense];//切换当前状态</span><br><span class="line">                </span><br><span class="line">                currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">        else if(DefenseState==StateType.Dodge)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">            if (currentState != null)</span><br><span class="line">            &#123;</span><br><span class="line">                currentState.OnExit();</span><br><span class="line">            &#125;</span><br><span class="line">            currentState = states[StateType.Dodge];//切换当前状态</span><br><span class="line">            ((DodgeState)states[StateType.Dodge]).dodgeTime = defenseTime;</span><br><span class="line">            currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br></pre></td></tr></table></figure><p>看起来重载方法实在是pang多，但实际上只是针对某些状态特化的方法而已（比如对造成伤害的重载加了伤害量，防御的重载加了防御），真正的切换状态方法是这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public virtual void TransitionState(StateType type)</span><br><span class="line">    &#123;</span><br><span class="line">        //如果当前存在状态，则进入当前状态的OnExit方法</span><br><span class="line">        if (currentState != null)</span><br><span class="line">        &#123;</span><br><span class="line">            currentState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentState = states[type];//切换当前状态</span><br><span class="line">        currentState.OnEnter();//执行切换后状态的OnEnter方法</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先，执行上一个状态的OnExit方法，然后切换当前的状态（这里可以看到是通过字典进行的搜索），最后执行切换后的OnEnter方法。</p><p>当然，这个还是太粗糙了。如果有些状态需要调整角色本身的属性数据该怎么办呢？所以就有了后面的重载方法。在重载方法中有很多需要添加的操作，但上面这三个是万万不能少的。</p><p>然而这个重载方法是为了什么存在的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public virtual void TransitionState()</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><del>答案是水行数</del> 答案是为了子类对切换状态的重写啊。一个游戏里不同角色都可以使用有限状态机，而上面的代码正好可以作为所有有限状态机的父类。写这么一个空方法就是为了后续的扩展操作。说不定有些角色不需要声明当前状态就能切换状态呢？</p><h2 id="总结与Q-amp-A"><a href="#总结与Q-amp-A" class="headerlink" title="总结与Q&amp;A"></a>总结与Q&amp;A</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        综上，有限状态机的优点就是可以在拥有很多状态的角色时，可以完美实现不同状态的过渡和存储。但是它也有着明显的缺点：代码量的指数级提升和更高编程技巧的掌握。所以当一个角色的状态不是很多的话，有限状态机可能并不是一个很好的选择。同时，我在上面讲的仅仅是一个有限状态机最最基础的框架，在正常的游戏开发中还需要加入这个角色特化的相关变量和方法。最后是一些可能存在的问题，我先写上了：</p><h3 id="1-有限状态机是只能用在怪物逻辑上吗？"><a href="#1-有限状态机是只能用在怪物逻辑上吗？" class="headerlink" title="1.有限状态机是只能用在怪物逻辑上吗？"></a>1.有限状态机是只能用在怪物逻辑上吗？</h3><p>​        在目前的教程中，有限状态机很多都用在怪物的逻辑上面。比如怪物一开始的状态是巡逻，但是一旦玩家接近怪物，怪物的状态就会切换成追逐状态，也就是追着玩家不放，直到玩家远离怪物一段距离，然后重新恢复巡逻状态。要想实现这个效果，使用有限状态机无疑会十分轻松。但是实际上，有限状态机也可以运用于玩家本身上，理由的话我在上文也提到过：为了防止不同状态过渡时产生的问题。</p><h3 id="2-如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？"><a href="#2-如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？" class="headerlink" title="2.如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？"></a>2.如果我要对多种怪物和玩家的逻辑运用有限状态机应该怎么操作？</h3><p>​        答案是把FSM作为父类，然后声明不同怪物的控制器脚本继承这个类。这样的话要注意字典里的键值对，父类只能注册大家都有的状态的键值对，不然就会出错。并且如果不同怪物的相同状态有着不同方法（比如诺斯克和芬达哥都有进场状态，但是芬达哥是啊！！！！！！芬达！！！！！！，诺斯克是给你来个大变活人），那一定要区分这些状态（比如诺斯克进场的状态类叫做NEnterState，芬达哥进场的状态类叫做FEnterState），毕竟类是没有重载这个东西的。</p><p>（寒假来了，开始爆更模式）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="https://karmotrine.fun/categories/Unity/"/>
    
    
    <category term="教程" scheme="https://karmotrine.fun/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://karmotrine.fun/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>简析Unity射线检测的概念与应用</title>
    <link href="https://karmotrine.fun/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://karmotrine.fun/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-09-08T09:50:08.000Z</published>
    <updated>2022-01-07T11:37:58.327Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1840474281&auto=1&height=66"></iframe><p>众所周知，在一款游戏中使用检测手法是十分常见的。比如说玩家自动来到某个地方触发剧情，判断子弹击中玩家的部位并造成相应血量。。。这其实都是碰撞检测的相关体现。但是，虽然碰撞检测在日常使用中相当普遍，但是碰撞检测也有相应的局限性。比如说APEX里恶灵被人拿枪指着时会有相应提示（感觉我的游戏偏好要在博客里面暴露光了），又或者是我们拿鼠标光标指向某些物体时显示出物体的具体信息（就比如像是城市模拟经营，我们想知道这个建筑具体是啥东西；又比如即时战略游戏我们想看一个兵种的具体血量等属性），那碰撞检测就显得见襟捉肘了。我总不能对着光标方向创建一个透明长方体来检测碰撞吧。但这样就显得很繁琐了。这时候我们就可以引入一个全新的检测手法：也就是射线检测了。我们可以像超市自动开关门那样引出一个射线，如果射线指向了某些特定属性的物体就会发出信号。这也是射线检测的基本方法。</p><h2 id="射线是啥"><a href="#射线是啥" class="headerlink" title="射线是啥"></a>射线是啥</h2><p>在进入射线检测的正题前，我们先回顾一下小学的知识：射线是个啥？百度百科上写的是：具有特定能量的粒子束或光子束流。<del>看到这里你肯定十分疑惑，因为我也很疑惑，然后我发现我复制粘贴错了。</del>咳咳，射线实际上是：直线上的一点和它一旁的部分所组成的图形。它由一个起始点开始，向着一个方向放出无限长的线。当线与我们想要检测的物体重合就会发出信号。就实际例子上来说，我们在射击游戏中端着枪，枪口到远处就算是一个射线。虽然我很想把射线一次全部整完，但由于射线检测在2D和3D的区别还是蛮大的，所以还是分成两个部分一起说吧。</p><h2 id="3D世界中的射线检测"><a href="#3D世界中的射线检测" class="headerlink" title="3D世界中的射线检测"></a>3D世界中的射线检测</h2><h3 id="咋检测的捏？"><a href="#咋检测的捏？" class="headerlink" title="咋检测的捏？"></a>咋检测的捏？</h3><p>我们既然讲了射线检测的原理，那就直接上射线检测的代码8：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Physics.Raycast(Vector3 origin,Vector3 direction,out RaycastHit hitinfo,float distance,int LayerMask);</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//direction：射线的方向，因为是方向坐标所以使用Vector3表示</span><br><span class="line">//hitinfo：一个结构体，可以储存碰撞体的所有信息。你可以声明一个空的然后直接代入就可以</span><br><span class="line">//结构体里面很有价值，后面会说</span><br><span class="line">//下面俩参数是可选参数：</span><br><span class="line">//distance:射线检测的距离，虽然说射线的长度是无限长，但是可以设置它的检测距离，只有在这个距离内的物体才可以被检测到</span><br><span class="line">//LayerMask：图层，虽然物体都处在一个3D世界中，但都有着图层之分。如果输入图层的序号就可以只检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用</span><br></pre></td></tr></table></figure><h4 id="1-这个方法返回啥？"><a href="#1-这个方法返回啥？" class="headerlink" title="1.这个方法返回啥？"></a>1.这个方法返回啥？</h4><p>这个方法返回的是布尔类型的值，但是它害可以通过out返回一个RaycastHit结构体。</p><p>**out:**c#中特有的参数，可以不通过return返回变量。out后面的东西不需要赋值甚至实例化。</p><h4 id="2-origin和direction可不可以合二为一？"><a href="#2-origin和direction可不可以合二为一？" class="headerlink" title="2.origin和direction可不可以合二为一？"></a>2.origin和direction可不可以合二为一？</h4><p>其实Unity自身内置一个叫做Ray的类：</p><p><code>Ray ray=new ray(Vector3 origin,Vector3 direction)；</code>这样就可以直接把两个Vector变量直接合成一个射线的Ray变量，代码内容也可以改成：</p><p><code>Physics.Raycast(ray,out RaycastHit hitinfo,float distance,int LayerMask);</code></p><h4 id="3-这样射线检测我看不到，有什么办法显示射线吗？"><a href="#3-这样射线检测我看不到，有什么办法显示射线吗？" class="headerlink" title="3.这样射线检测我看不到，有什么办法显示射线吗？"></a>3.这样射线检测我看不到，有什么办法显示射线吗？</h4><p>如果想拿着这个代码去unity内部尝试的话，可以参考下面这个代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Debug.DrawLine(Vector3 origin,Vector3 destination,Color color);</span><br><span class="line">//功能是在Scene窗口显示一条可见的线段</span><br><span class="line">//origin:线段的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//destination：线段的终点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//color:你想在窗口上看到的线段的颜色</span><br><span class="line">Debug.DrawRay(Vector3 origin,Vector3 direction,Color color)</span><br><span class="line">//功能是在Scene窗口显示一条可见的射线</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//destination：射线的方向，因为是方向所以使用Vector3表示</span><br><span class="line">//color:你想在窗口上看到的射线的颜色</span><br></pre></td></tr></table></figure><p>当然，如果你是想显示特定的射线的样子，就可以改成：</p><p><code>Debug.DrawLine(ray.origin,ray.origin+ray.direction,Color.red);</code></p><p>但是你可能会发现Scene窗口看到的实在是太短了，原因是我们线段终点有点短，所以可以尝试在终点后面乘上个100甚至是1000</p><h4 id="4-RaycastHit感觉不如碰撞检测。。。功能"><a href="#4-RaycastHit感觉不如碰撞检测。。。功能" class="headerlink" title="4.RaycastHit感觉不如碰撞检测。。。功能"></a>4.RaycastHit感觉不如碰撞检测。。。功能</h4><p>RaycastHit很有用，结构体内除了位置坐标以外还有检测到物体的碰撞体。这意味着我们可以获取这个物体的相关组件了：</p><p><code>hit.collider.gameObject.GetComponent&lt;RigidBody&gt;();</code></p><p>或者<code>hit.collider.gameObject.name</code></p><p>是不是很好用。</p><h4 id="5-What’s-up-你这Raycast只能测一个啊？！"><a href="#5-What’s-up-你这Raycast只能测一个啊？！" class="headerlink" title="5.What’s up?你这Raycast只能测一个啊？！"></a>5.What’s up?你这Raycast只能测一个啊？！</h4><p>raycasthit只有一个返回值，那如果我想获得所有在射线上的物体怎么办？</p><p>答案是使用<code>RaycastAll</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits;</span><br><span class="line">hits=Physics.RaycastAll(ray,maxDistance,mask);</span><br><span class="line">/*</span><br><span class="line">1.返回值是RaycastHit数组,所以记得加等号</span><br><span class="line">2.后面俩参数依然是最远距离和图层，前面写了</span><br><span class="line">3.后面可以使用foreach遍历数组里面的</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="6-你这LayerMask有问题啊？怎么是int？"><a href="#6-你这LayerMask有问题啊？怎么是int？" class="headerlink" title="6.你这LayerMask有问题啊？怎么是int？"></a>6.你这LayerMask有问题啊？怎么是int？</h4><p>LayerMask的形式是int，没错，不是字符而是int。它表示的是你涂层的序号的<strong>二次方倍</strong>，没错，<strong>二次方倍</strong>。这意味着你想检测的图层序号是第九层，但你在LayerMask这一变量里要输2的九次方，也就是512……</p><p>这个原因是Unity中以二维矩阵对LayerMask进行存储，所以要进行位运算。</p><p>我也针对这个写两个方法：</p><p>（1）public一个LayerMask然后在Inspector里面给它挂图层</p><p>（2）可以改写成<code>LayerMask.GetMask(&quot;这里写图层名字&quot;);</code></p><h4 id="6-5-你这LayerMask只能测一个图层？"><a href="#6-5-你这LayerMask只能测一个图层？" class="headerlink" title="6.5.你这LayerMask只能测一个图层？"></a>6.5.你这LayerMask只能测一个图层？</h4><p>如果你在<code>LayerMask.GetMask(&quot;&quot;);</code>前加~，这代表除了这个图层以外全部检测。这样射线检测就会绕过你指定的图层检测别的图层。</p><h4 id="7-（因为重中之重一定要写最后）"><a href="#7-（因为重中之重一定要写最后）" class="headerlink" title="7.（因为重中之重一定要写最后）"></a>7.（因为重中之重一定要写最后）</h4><p><strong>一定要加上collider组件！！！</strong></p><p>因为射线检测也是变相的射线和物体进行碰撞<del>（好吧这是我瞎编的）</del>，所以务必加collider组件！</p><p>你可以让射线检测没有trigger的，但是绝不能检测没有加collider组件的。</p><h3 id="咋应用的捏？"><a href="#咋应用的捏？" class="headerlink" title="咋应用的捏？"></a>咋应用的捏？</h3><p>按照上面的说法，我们根本无法实现拿鼠标点击物体看属性的功能。因为射线只能给一个物体，鼠标怎么整呢？</p><p>我们直接整一个复杂的情景：</p><p>假如你是李华，你在某模拟经营类游戏（类似冰汽时代）要在某个崎岖不平的地上造建筑，需要在光标上预览建筑造好后怎么样。所以你光标在哪里建筑要跟到哪里，同时遇到山你的建筑要有些倾斜。</p><p>接下来我们就来解决这个问题（以下脚本要挂载到你要放的物体上）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void FixedUpdate()&#123;</span><br><span class="line">    Ray ray=Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">    /*把鼠标在屏幕坐标上面的位置通过ScreenPointToRay方法转化为Ray射线类型（世界坐标系），因为屏幕坐标并不是世界系的坐标。这样射线从相机为起点向鼠标所在的方向延伸*/</span><br><span class="line">    if(Physics.Raycast(ray,out RaycastHit hitInfo,Mathf.Infinity))&#123;</span><br><span class="line">        //这里直接把检测距离改成无限</span><br><span class="line">        transform.position=hitInfo.point;</span><br><span class="line">       //这样物体会一直跟着射线交界点，也就是我们的鼠标</span><br><span class="line">        transform.rotation=Quaternion.FromToRotation(Vector3.up,hitInfo.normal);</span><br><span class="line">        //让物体的旋转角度迎合地面的角度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么做可能会有一个严重的问题：你的建筑会一直朝镜头飞。</p><p><img src="%E9%A3%9E.gif" alt="飞" loading="lazy"></p><p>原因很简单：你检测的是第一个碰撞体。而如果你的建筑有碰撞体，检测到的碰撞体不是地面而是你的建筑。这样point就一直是你的前面，就会一直朝建筑飞。</p><p>解决的方法有两种：</p><p>1.把建筑的碰撞体关了，然后建好了碰撞体开开</p><p>2.调整图层，把地面放到单独的图层里</p><p>这么做还有个不太严重的问题：建筑一半会陷进地面里。</p><p><img src="%E8%B5%B0.gif" alt="走" loading="lazy"></p><p>因为你的建筑位置坐标是你建筑的中心坐标，也就是point坐标。</p><p>解决方法也很简单，在上面做个空物体，把该物体上移建筑的半格，把它作为空物体的子物体，就可以了。这样它的坐标变成了空物体的中心坐标，也就是建筑的底部。</p><p>后面确认建造可以写：</p><p><code>Instantiate(prefab,transform.position,transform.rotation);</code></p><p>其实射线检测在3D世界上还有很多应用：</p><p>1.就Unity官方给出的例子来看，可以确定空投物资的降落伞什么时候打开：通过在物资下做一条有距离限制的射线检测，一检测到地面就开降落伞。</p><p>。。。<del>（你省略害搁着打个1.干嘛）</del></p><p>3D好像也没啥讲的了，就这么多把</p><h2 id="2D世界中的射线检测"><a href="#2D世界中的射线检测" class="headerlink" title="2D世界中的射线检测"></a>2D世界中的射线检测</h2><h3 id="咋检测的捏？-1"><a href="#咋检测的捏？-1" class="headerlink" title="咋检测的捏？"></a>咋检测的捏？</h3><p>2D和3D的代码是类似的，2D代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Physics2D.Raycast(Vector2 origin,Vector2 direction,float distance,int LayerMask,float minDepth,float maxDepth);</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector2表示</span><br><span class="line">//direction：射线的方向，因为是方向坐标所以使用Vector2表示</span><br><span class="line">//distance:射线检测的距离，虽然说射线的长度是无限长，但是可以设置它的检测距离，只有在这个距离内的物体才可以被检测到</span><br><span class="line">//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用</span><br><span class="line">//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷</span><br></pre></td></tr></table></figure><p>看似只是在Physics后面加了2D，但实际上2D和3D是有很多区别的<del>（不然也不会特地做一个部分了）</del>。</p><h4 id="0-Z轴，寄！"><a href="#0-Z轴，寄！" class="headerlink" title="0.Z轴，寄！"></a>0.Z轴，寄！</h4><p>首先最明显的就是z轴没有用了：<code>transform.forward</code>指向z轴方向，所以在2D的场景里只会指向屏幕内，根本就没有了作用。</p><h4 id="1-Ray，寄！"><a href="#1-Ray，寄！" class="headerlink" title="1.Ray，寄！"></a>1.Ray，寄！</h4><p>上文提到过，Ray这个类是由两个Vector3变量构造而成的，而2D世界都是Vector2，自然Ray这个类就与2D无缘了，只能用俩Vector2变量表示了。</p><h4 id="2-返回类型（作为方法最明显的不同了属于是）"><a href="#2-返回类型（作为方法最明显的不同了属于是）" class="headerlink" title="2.返回类型（作为方法最明显的不同了属于是）"></a>2.返回类型（作为方法最明显的不同了属于是）</h4><p>不像3D的返回类型是一个布尔类型的变量，2D返回的是RaycastHit2D的结构体类型。这个结构体类型和3D的结构体类型相似，也是储存着射线的相关信息以及检测到的碰撞体信息。比如说<code>point</code>就储存射线和碰撞体交汇的坐标，很是方便。</p><h4 id="3-小tips"><a href="#3-小tips" class="headerlink" title="3.小tips"></a>3.小tips</h4><p>在现实的游戏中，发出射线检测的物体基本都是具有碰撞体的（比如怪物或者炮台什么的）。这就引发了一个问题：当从物体中心点发出时，检测到的第一个碰撞体却是自己，射线根本出不去。那我们该怎么解决这个问题呢？答案是<code>Physics2D.queriesStartInColliders=false;</code>queries:询问，start:开始，incolliders:在碰撞体内。这样如果碰撞体是我们射线所在起点的内部时，我们不让它返回该碰撞体。这样就可以完美解决问题了。</p><h4 id="4-还有两种重载。。。"><a href="#4-还有两种重载。。。" class="headerlink" title="4.还有两种重载。。。"></a>4.还有两种重载。。。</h4><p>但用的少而且比较复杂，就不在这里延申了。</p><h4 id="5-（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）"><a href="#5-（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）" class="headerlink" title="5.（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）"></a>5.（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）</h4><p><strong>一定要加上collider组件！！！</strong></p><p>因为射线检测也是变相的射线和物体进行碰撞<del>（好吧这是我瞎编的）</del>，所以务必加collider组件！</p><p>你可以让射线检测没有trigger的，但是绝不能检测没有加collider组件的。</p><p><strong>其它的就没了</strong></p><h3 id="咋应用的捏？-1"><a href="#咋应用的捏？-1" class="headerlink" title="咋应用的捏？"></a>咋应用的捏？</h3><p>还是整一个复杂的例子：</p><p>你想在TopDown游戏（比如元气骑士）中做一个激光束，激光束打到墙面会被墙面阻隔，打到人身上会掉血（为了方便直接写了GameOver）。而我们要从游戏视觉到内部判定上把这个功能实现出来。</p><h4 id="内部判定"><a href="#内部判定" class="headerlink" title="内部判定"></a>内部判定</h4><p>内部判定很简单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void Detect()</span><br><span class="line">&#123;</span><br><span class="line">    //进行射线检测并将结果进行储存</span><br><span class="line">    RaycastHit2D hitInfo=Physics2D.Raycast(transform.position,-transform.right,maxDist,max);</span><br><span class="line">    //如果射线检测检测到了东西（因为检测到了东西有碰撞体就不会是null了）</span><br><span class="line">    if(hitInfo.collider!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Player&quot;)</span><br><span class="line">            //如果检测到的是player（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            GameOver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视觉实现（LineRenderer组件）"><a href="#视觉实现（LineRenderer组件）" class="headerlink" title="视觉实现（LineRenderer组件）"></a>视觉实现（LineRenderer组件）</h4><p>检测方面还是好写的。但如果我们要在实际的游戏画面中也要把这条射线给显示出来，使用DrawLine和DrawRay方法是无法胜任的。因为它们只能在Scene窗口内看到一条辅助线，而不是Game窗口里。</p><p>针对这个方法，我们可以使用Unity自带的LineRenderer来实现：</p><p><img src="Line.png" alt="LineRenderer位置在这里" loading="lazy"></p><p>LineRenderer是用于在游戏场景内对一条线段进行渲染。它的主要参数有很多，我们只讲几个重要的：</p><p><img src="LineRenderer.png" alt="内部格式" loading="lazy"></p><h5 id="（1）Position"><a href="#（1）Position" class="headerlink" title="（1）Position"></a>（1）Position</h5><p>众所周知，两点确定一条线段，而Position里面的两个index就是两个点的位置。index1是线段的起点，而index2则是线段的终点。</p><p>这里有个<code>SetPosition</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LineRenderer.SetPosition(int index,Vector3 position);</span><br><span class="line">//功能是设置LineRenderer的起始点和终点。index为Position里的序列号（如果是1就代表是index1），position为终点。</span><br></pre></td></tr></table></figure><h5 id="（2）-Width"><a href="#（2）-Width" class="headerlink" title="（2） Width"></a>（2） Width</h5><p>对线段的宽度进行设置。因为Width是一条线，所以你可以控制线段上的每一个点的粗细<del>（什么金箍棒）</del></p><h5 id="（3）Color"><a href="#（3）Color" class="headerlink" title="（3）Color"></a>（3）Color</h5><p>对线段的颜色进行设置。但因为是线段，所以你可以设置一个渐变的颜色，甚至是某些位置的透明度<del>（哇哦，好几把炫酷）</del></p><p>而这个颜色的类名也不能是<code>Color</code>了，而是<code>Gradient</code>（渐变色）</p><h5 id="（4）End-CapVertices"><a href="#（4）End-CapVertices" class="headerlink" title="（4）End CapVertices"></a>（4）End CapVertices</h5><p>对线段末端的圆滑度进行设置。如果这个数值是0，那线段末端就是一个正方。如果这个数值越大，末端也会更加圆滑，最后趋近于一个半圆。</p><h5 id="5-Use-World-Space"><a href="#5-Use-World-Space" class="headerlink" title="(5)Use World Space"></a>(5)Use World Space</h5><p>将Position里的坐标转化为世界坐标。不勾选这个的话我们就无法正确的让线段显示出来。</p><p>有了这个，视觉方面就好做了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private LineRenderer lineRenderer;</span><br><span class="line">//声明LineRenderer组件的变量</span><br><span class="line"></span><br><span class="line">private void Awake()&#123;</span><br><span class="line">    lineRenderer=GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">    //如果LineRenderer组件物体是脚本挂载的子物体，那我们可以直接使用GetComponentInChildren方法。但是这个方法只会获取第一个发现的组件而不是所有子物体的组件。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Detect()</span><br><span class="line">&#123;</span><br><span class="line">    //进行射线检测并将结果进行储存</span><br><span class="line">    RaycastHit2D hitInfo=Physics2D.Raycast(transform.position,-transform.right,maxDist,max);</span><br><span class="line">    //如果射线检测检测到了东西（因为检测到了东西有碰撞体就不会是null了）</span><br><span class="line">    if(hitInfo.collider!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Wall&quot;)</span><br><span class="line">            //如果检测到的是Wall（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            lineRenderer.SetPosition(1,hitInfo.point);</span><br><span class="line">        &#125;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Player&quot;)</span><br><span class="line">            //如果检测到的是player（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            lineRenderer.SetPosition(1,hitInfo.point);</span><br><span class="line">            GameOver();</span><br><span class="line">        &#125;</span><br><span class="line">        lineRenderer.SetPosition(0,transform.position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就差不多了。</p><h2 id="射线检测的一些缺点"><a href="#射线检测的一些缺点" class="headerlink" title="射线检测的一些缺点"></a>射线检测的一些缺点</h2><h3 id="射线检测，寄！"><a href="#射线检测，寄！" class="headerlink" title="射线检测，寄！"></a>射线检测，寄！</h3><p>在讲了这么多射线检测后，我还是想要明确一下射线检测的缺陷：在检测的范围不是一根线段而是一个面积的图形时，射线检测就显得有些见襟捉肘。比如说：我想在平台跳跃游戏中使用射线检测检测玩家是否与地面相碰。因为如果我们不这么做玩家就可以无限按跳跃键达到飞天的效果(bushi。在这里使用射线检测就会造成一些问题：</p><p><img src="%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.png" alt="发生肾么事了" loading="lazy"></p><p>如图，玩家依旧在地板上，但是由于中间超过一半部位已经离开了地板，导致在玩家中心点往下的射线检测并没有检测到地板。这样的结果就是玩家在这个地方本来可以跳却跳不起来。我们想要检测一定范围内的碰撞体，而射线检测却无法达到这个效果。</p><p>难道，就没有办法了吗？</p><h3 id="OverLap的妙用"><a href="#OverLap的妙用" class="headerlink" title="OverLap的妙用"></a>OverLap的妙用</h3><p>面对这个问题，Unity自然有解决方法：那就是OverLap方法。它的功能和射线检测大致类似，但是它并不是产生一条射线，而是产生一个形状，比如圆形(<code>OverLapCircle</code>)，方形(<code>OverLapBox</code>)等。这些方法的区别仅仅是形状不一样，而其他都是大致相同的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collider2D collider=Physics2D.OverLapCircle(Vector2 point, float radius, int layerMask, float minDepth, float maxDepth);//point:圆心的点所在坐标，因为是位置坐标所以使用Vector2表示//radius：圆的半径//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷Collider2D OverlapBox=Physics2D.OverLapBox(Vector2 point, Vector2 size, float angle, int layerMask, float minDepth, float maxDepth);//point:长方体中心点所在坐标，因为是位置坐标所以使用Vector2表示//size：长方体的长和宽，因为要有长和宽两个数所以使用Vector2表示//angle:长方体要倾斜的角度//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷</span><br></pre></td></tr></table></figure><p>方法和射线检测类似，但是又有些许的不同，比如：</p><h4 id="1-返回值不一样"><a href="#1-返回值不一样" class="headerlink" title="1.返回值不一样"></a>1.返回值不一样</h4><p>OverLap的返回值是collider2D，也就是碰撞体，不像射线检测是返回hitInfo那种结构体了。</p><h4 id="2-适用范围不一样"><a href="#2-适用范围不一样" class="headerlink" title="2.适用范围不一样"></a>2.适用范围不一样</h4><p>看到Physics2D也知道，OverLap只适用于2D世界，而不是2D、3D全适用了。</p><p>通过这个方法，我们可以在玩家碰撞体的正下面做一个OverLap检测，这样就可以完美解决跳跃检测的问题了。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="如何像DrawLine那样显示出整个检测范围？"><a href="#如何像DrawLine那样显示出整个检测范围？" class="headerlink" title="如何像DrawLine那样显示出整个检测范围？"></a>如何像DrawLine那样显示出整个检测范围？</h4><p>答案是使用gizmos:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void OnDrawGizmos()&#123;    Gizmos.DrawWireSphere(transform.position,radius);    Gizmos.Color=Color.Red;&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么平台跳跃中贴着墙掉不下去？"><a href="#为什么平台跳跃中贴着墙掉不下去？" class="headerlink" title="为什么平台跳跃中贴着墙掉不下去？"></a>为什么平台跳跃中贴着墙掉不下去？</h4><p>答案是所有碰撞体和刚体的材质都默认有摩擦力，只要你新建一个物理材质然后把摩擦力调整为0然后挂载到墙壁的刚体上就不会这样了。</p><h4 id="如何检测该形状范围内的所有碰撞体？"><a href="#如何检测该形状范围内的所有碰撞体？" class="headerlink" title="如何检测该形状范围内的所有碰撞体？"></a>如何检测该形状范围内的所有碰撞体？</h4><p>答案是OverLap***All方法，这个方法和之前射线检测的一样，可以返回所有碰撞体.</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>射线检测在Unity游戏制作中还是十分重要的。但和碰撞检测不同，射线检测在2D和3D的世界使用方面上还是有着不同的。并且，由于射线检测仅仅是一条射线的范围，在某些游戏某些功能的实现上还是有着局限性。为此OverLap这种可以检测一定范围的方法可以更加胜任这些工作。在文中2D中射线检测以及OverLap的介绍并没有3D中的那么详细，这是因为避免文章的重复性。基本上3D部分提到但是2D和OverLap没有提到的功能和注意在2D和OverLap上也是适用的。比如这些检测方法都需要碰撞体，都可以采用在后面加All的方法检测范围内的所有碰撞体的物体，LayerMask是int等等，还望大家谅解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="https://karmotrine.fun/categories/Unity/"/>
    
    
    <category term="教程" scheme="https://karmotrine.fun/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://karmotrine.fun/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity中如何设置游戏存档方法归纳</title>
    <link href="https://karmotrine.fun/2021/06/26/Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3/"/>
    <id>https://karmotrine.fun/2021/06/26/Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3/</id>
    <published>2021-06-26T03:42:20.000Z</published>
    <updated>2022-01-07T10:24:54.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1399789328&auto=1&height=66"></iframe><p>最近属实有点忙（如果打游戏也算忙的话），一直拖到了放假第一个礼拜结束。。。</p><p>所以我决定不咕了！写一篇unity存档的东西出来！<del>（其实是实在没事情干了）</del></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        众所周知，存档在许多游戏中已经成为了不可或缺的一部分，先不论联机的网络游戏，一些长流程游戏，比如黑帝斯，空洞骑士等（让我咕的万恶之源属于是），这样不存档让玩家连续花30+个小时甚至更久属实是让玩家坐牢，变成了班尼特福德之类的阴间游戏。这不仅对玩家是坐牢，对测试游戏的人更是一种全新的坐牢体验：要是要测试后面的关卡有没有bug，那就一定要把前面的打了，然后测出了bug游戏运行不了改了bug要重新来，想想就离谱。但如果拿特定的存档进去测试那肯定少了很多时间和精力。</p><p>综上所述，单机游戏存档的好处如下：</p><p><strong>1.长流程游戏可以让玩家分几次体验，失败了也可以重新读档，减少了玩家的坐牢体验</strong></p><p><strong>2.测试时可以直接进入特定地点进行测试，不需要从头打起不断被自己的粪作ex到</strong></p><p><strong>3.肯定还有但我懒得想了</strong></p><p>对此，Unity有这几种方法进行游戏存档：</p><h2 id="PlayerPrefs的妙用"><a href="#PlayerPrefs的妙用" class="headerlink" title="PlayerPrefs的妙用"></a>PlayerPrefs的妙用</h2><p>对于存档，Unity特别在脚本里提供了PlayerPrefs类的方法。它的方法是提供给玩家int，float，string三个类型进行储存与修改。每一个变量名都对应这一个值，也就是键值对，类似于字典类型。这三个类型的变量名和值都是直接储存在文件里的，所以可以达到储存轻量数据的可能。</p><p>相关代码也很简单，具体是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PlayerPrefs.SetString(&quot;Name&quot;,name); //储存string类变量</span><br><span class="line">PlayerPrefs.SetFloat(&quot;Name&quot;,name); //储存float类变量</span><br><span class="line">PlayerPrefs.SetInt(&quot;Name&quot;,name); //储存int类变量</span><br><span class="line">//这三个的意思是：创建名字叫Name的变量在PlayerPrefs里，</span><br><span class="line">//同时他们的值和name相等（当然name也可以直接打float,int,string类型的常量）</span><br><span class="line">Str=PlayerPrefs.GetString(&quot;Name&quot;); //读取string类变量并存在Str里</span><br><span class="line">I=PlayerPrefs.GetInt(&quot;Name&quot;); //读取int类变量并存在I里</span><br><span class="line">F=PlayerPrefs.GetFloat(&quot;Name&quot;); //读取float类变量并存在F里</span><br><span class="line">//如果不存在Name，那么会返回0</span><br><span class="line">PlayerPrefs.DeleteAll(); //删除所有键和值</span><br><span class="line">PlayerPrefs.DeleteKey(&quot;Name&quot;); //删除Name的键和值</span><br><span class="line">PlayerPrefs.HasKey(&quot;Name&quot;); //判断是否存在Name这个键并返回true或者false</span><br></pre></td></tr></table></figure><p>这些代码虽然很简单，但是只能存储三个类型而且不能做成一个类，所以只能用在一些简单的存储，比如简单变量和玩家设置里，比如获得金币钻石数量啊，开不开bgm啊（开了就setint为1，然后每次进游戏getint判断是不是1，是了就开）什么的。当然如果你硬要存储玩家数据也不是不可以，就是有种拿水果刀杀牛的感觉（<del>别问我为什么不是鸡刀，你见过鸡刀吗）</del>，不太值得属于是。</p><p><strong>注意：</strong></p><p><strong>因为是存在文件里，所以你Unity调试也是运行了PlayerPrefs的代码里的，所以在停止调试后PlayerPrefs的改变不会变回来捏</strong></p><p>（通俗一点就是你调试时setint把0改成1，终止调试时那个值还是1而不是0辣，讲那么多干嘛）</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>每个字单独我都认识，咋连起来就不认识了捏？容我细说：</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="序列化-Serialization-和反序列化-Deserialization"><a href="#序列化-Serialization-和反序列化-Deserialization" class="headerlink" title="序列化(Serialization)和反序列化(Deserialization)"></a>序列化(Serialization)和反序列化(Deserialization)</h4><p>在Unity中，序列化的概念为：<strong>将[对象的状态信息]转化为[Unity可以储存的形式]的自动化处理过程</strong></p><p>那反序列化自然是：<strong>将[Unity可以储存的形式]转化为[对象的状态信息]的自动化处理过程</strong></p><p>从广义上来说，[对象的状态信息]可以被说成[对象]，而[Unity可以储存的形式]就是[可传输的字节序列]。说白了，序列化就是将Unity的文件或者脚本（对象的状态信息）转化为二进制的形式（也就是一群读不懂的数字加字母），存储在数据库，内存或者文件中（Unity可以储存的形式），也就是游戏里的“保存游戏”按钮，而反序列化则是“读取游戏”。和其他的方法不同，这些数据会以二进制的形式存储在游戏的data.txt里。</p><p>序列化最简单的使用方式是让脚本内private变量的值在Inspector面板里显示出来。众所周知（？？？），脚本内的public变量都会经过序列化出现在inpector面板上，而private则不会。而要想显示出来，就要在命名上方加上<code>[SerializeField]</code>，表示变量可被序列化（私以为其中原理应该是让Unity的Inspector面板保存数据）。具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SerializedField]</span><br><span class="line">private int i;</span><br></pre></td></tr></table></figure><p>接下来将会介绍Unity为此特制的三个类，它们分别为：</p><h4 id="File类，FileStream类和BinaryFormatter类"><a href="#File类，FileStream类和BinaryFormatter类" class="headerlink" title="File类，FileStream类和BinaryFormatter类"></a>File类，FileStream类和BinaryFormatter类</h4><h5 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h5><p>文件类，即用来对文件进行基本操作，比如说创建、复制、剪切、打开等，可以直接赋值到后面的FileStream类</p><p><strong>太长不看版：操作文件的</strong></p><p><strong>在使用该类前，请注意使用<code>System.IO</code>的命名空间</strong>（IO肯定是input,output辣）,也就是：<code>using System.IO</code></p><h5 id="FileStream类"><a href="#FileStream类" class="headerlink" title="FileStream类"></a>FileStream类</h5><p>文件流类，即用来读取、写入操作系统文件的，可以进行读取、写入、保存、关文件流的功能，可以把文件转化为字节流的形式</p><p><strong>注意：干完活记得把文件流关了，File类可以直接赋值FileStream类</strong></p><p><strong>在使用该类前，请注意使用<code>System.IO</code>的命名空间</strong>（IO肯定是input,output辣）,也就是：<code>using System.IO</code></p><p>综上所述呢，我们可以把文件看成包裹，对包裹本身的操作，比如创建个包裹，移动个包裹什么的就用File类，但是如果要对包裹里面的东西进行操作，那就得使用FileStream了。</p><h5 id="BinaryFormatter类"><a href="#BinaryFormatter类" class="headerlink" title="BinaryFormatter类"></a>BinaryFormatter类</h5><p>Binary的意思是二进制，而Formatter则是格式化程序，那干什么自然不用我说了，就是<strong>以二进制的形式对对象进行序列化和反序列化</strong>。</p><p><strong>在使用该类前，请注意使用<code>System.Runtime.Serialization.Formatters.Binary</code>的命名空间</strong>,也就是：<code>using System.Runtime.Serialization.Formatters.Binary</code></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>首先创建一个c#脚本命名为Save（名字随便啥都可以）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[System.Serializable] //直接告诉Unity这个类可被序列化</span><br><span class="line">public class Save //不要MonoBehaviour，因为直接作为一个类，不需要挂物体上</span><br><span class="line">&#123;</span><br><span class="line">    public int coins;</span><br><span class="line">    public float playerPositionX;</span><br><span class="line">    public float playerPositionY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们可以在另一个脚本里写下这些方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line">using System.IO;</span><br><span class="line">//命名空间肯定不止这么少，就是打出来提醒一下</span><br><span class="line"></span><br><span class="line">public Save CreateSave()&#123; //创建一个Save对象存储当前游戏数据</span><br><span class="line">    Save save=new Save();</span><br><span class="line">    save.Coins=GameManager.Instance.coins;</span><br><span class="line">    save.playerPositionX=player.transform.position.x;</span><br><span class="line">    save.playerPositionY=player.transform.postion.y;</span><br><span class="line">    return Save;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void SaveBySerialization()&#123;</span><br><span class="line">    Save save=CreateSave();</span><br><span class="line">    //获取当前的游戏数据存在Save对象里</span><br><span class="line">    BinaryFormatter bf=new BinaryFormatter();</span><br><span class="line">    //创建一个二进制形式</span><br><span class="line">    FileStream  fs=File.Create(Application.persistentDataPath+&quot;/Data.yj&quot;);</span><br><span class="line">    //这里指使用持久路径创建一个文件流并将其保存在Data.yj里（具体在哪就不打了，反正创建了）</span><br><span class="line">    //由于持久路径在Windows系统是隐藏的，所以无法找到Data.yj本身</span><br><span class="line">    //如果想看到，可以改成dataPath(就像下文json的代码里一样)</span><br><span class="line">    //文件后缀可以随便改，甚至是自定义的（比如我这里用了yj）</span><br><span class="line">    bf.Serialize(fs,save);</span><br><span class="line">    //将Save对象转化为字节</span><br><span class="line">    fs.Close();</span><br><span class="line">    //把文件流关了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了序列化（保存）的全过程：</p><p><strong>创建一个二进制格式化对象-&gt;新建文件流-&gt;序列化Save对象-&gt;关闭文件流</strong></p><p>接下来就是读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void LoadByDeserialization()&#123;</span><br><span class="line">    if(File.Exists(Application.persistentDataPath+&quot;/Data.yj&quot;))</span><br><span class="line">    //判断文件是否创建</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryFormatter bf=new BinaryFormatter();</span><br><span class="line">        FileStream fs=File.Open(Application.persistentDataPath+&quot;/Data.yj&quot;,FileMode.Open);//打开文件</span><br><span class="line">        Save save=bf.Deserialize(fs) as Save;</span><br><span class="line">//反序列化并将数据储存至save（因为返回变量类型不对，所以要强制转换为Save类</span><br><span class="line">        fs.Close();</span><br><span class="line">//关文件流</span><br><span class="line">        GameManager.Instance.coins=save.coins;</span><br><span class="line">        player.transform.position=new Vector2(save.playerPositionX,save.playerPositionY);</span><br><span class="line">//赋值</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        Debug.LogError(&quot;Data Not Found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，一个简单的游戏存档就做好了，这些方法可以挂载在按钮或者特定场景上，使得可以正常进行存档读档的操作。如果你想储存场景内的怪物数据的话，建议使用vector类型进行存储呢，比如说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;save.isDead.Count;i++)&#123;</span><br><span class="line">    if(GameManager.instance.enemies[i]==null)&#123;</span><br><span class="line">        if(!save.isDead[i])//如果敌人在我们保存之后死了</span><br><span class="line">        &#123;</span><br><span class="line">            float enemyPosX=save.enemyPositionX[i];</span><br><span class="line">            float enemyPosY=save.enemyPositionY[i];</span><br><span class="line">            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);</span><br><span class="line">            GameManager.Instance.enemies[i]=newBat;</span><br><span class="line">            //把本该活着的敌人数据进行填充</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            float enemyPosX=save.enemyPositionX[i];</span><br><span class="line">            float enemyPosY=save.enemyPositionY[i];</span><br><span class="line">            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建的类也应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[System.Serializable] //直接告诉Unity这个类可被序列化</span><br><span class="line">public class Save //不要MonoBehaviour，因为直接作为一个类，不需要挂物体上</span><br><span class="line">&#123;</span><br><span class="line">    public int coins;</span><br><span class="line">    public float playerPositionX;</span><br><span class="line">    public float playerPositionY;</span><br><span class="line">    </span><br><span class="line">    public List&lt;float&gt; enemyPositionX=new List&lt;float&gt;();</span><br><span class="line">    public List&lt;float&gt; enemyPositionY=new List&lt;float&gt;();</span><br><span class="line">    public List&lt;bool&gt; isDead=new List&lt;bool&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>序列化和反序列化看似很好解决了大量数据存储的问题，但是你要想啊，序列化以后的文件全是二进制，这鬼也看不懂啊（除了计算机捏），那修改也更是问题。那有没有什么序列化以后属于一个人能看懂的东西捏？这就要看：</p><h2 id="另一种序列化方式——JSON"><a href="#另一种序列化方式——JSON" class="headerlink" title="另一种序列化方式——JSON"></a>另一种序列化方式——JSON</h2><p>{json}，搁着一看还以为是jvavscript(js)，那它如何来实现存档读档呢？还是从概念入手把</p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON，全称是JavaScript对象表示法（JavaScript Object Notation），它主要是用来在客户端和服务端进行交互数据的，它属于轻量级语言。它的格式以”键值对“的形式作为展示，而且键的名字可以自己定义，不理解的可以看看下面：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Save=&#123;<span class="comment">//大括号表示对象</span></span><br><span class="line">    <span class="attr">&quot;coins&quot;</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;playerPositionX&quot;</span>:<span class="number">10.866</span>,</span><br><span class="line">    <span class="attr">&quot;playerPositionY&quot;</span>:<span class="number">-21</span>,</span><br><span class="line">    <span class="attr">&quot;isDead&quot;</span>:[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>] <span class="comment">//中括号表示数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json由两部分构成：一个是键名(Key)，也就是变量的名字，是String类型的；另一个就是值(value)，它可以是int,bool,float,数组,甚至是对象类型。它们组合在一起，也就是上文所说的”键值对“(Key Value Pair)，有点字典内味了哈（字典也是键值对啊kora）。而json文件本身也是String类型的文本。</p><p>看到这里也应该明白json和js的区别了<del>（你认真的？？？）</del>：JavaScript是一种程序语言，而json则是一种数据格式，一种语法。因为它没有使用任何函数或者命令，仅仅是以文字为基础，易于阅读和编写，作为数据交换语言显然很适合。虽然JavaScript里自带方法可以让js和json互相转化，但本质上两者还是不属于一个东西。</p><p>虽然可以使用js可以和json互相转化，但是Unity的语言是C#啊。。。不过不用担心，Unity也有相应的方法让json可以和C#相互转化(JsonUtility类)。而下文也是通过这种方式实现的。</p><p><strong>提示：</strong>其实可以通过库进行json数据的解析，比如.Net库的Json.Net和LitJson.dll。之所以使用JsonUtility类是因为它是Unity自带的，而且解析更快，产生的垃圾更少。</p><h4 id="流写入类-StreamWriter类"><a href="#流写入类-StreamWriter类" class="headerlink" title="流写入类(StreamWriter类)"></a>流写入类(StreamWriter类)</h4><p>和FileStream类差不多，也是对系统文件进行写入的（没有读取功能捏），但是FileStream类读取的是字节数组，适用于非文本文件，所以不太适合读取String类型的JSON文件</p><p><strong>注意：写完也记得把流关了</strong></p><h4 id="流读取类-StreamReader类"><a href="#流读取类-StreamReader类" class="headerlink" title="流读取类(StreamReader类)"></a>流读取类(StreamReader类)</h4><p>和FileStream类差不多，也是对系统文件进行读取的（没有写入功能捏），但是FileStream类读取的是字节数组，适用于非文本文件，所以不太适合读取String类型的JSON文件</p><p><strong>注意：写完也记得把流关了</strong></p><p><del><em>就是复制粘贴改了的，略略略</em></del></p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//不需要加别的命名空间，简直爽死(bushiprivate void SaveByJSON()&#123;Save save= CreateSave();    //创建一个Save实例存储游戏数据(CreateSave函数在上面)    String JsonString=JsonUtility.ToJson(save);    //将对象save转化为json字符串    //上面说了Json是string类型，所以命名string    StreamWriter sw=new StreamWriter(Application.dataPath+&quot;/Data.yj&quot;);//persistentDataPath是隐藏文件的，所以你找不到Data.yj的所在地，//而dataPath就不会隐藏，同时文件后缀也可以乱取    sw.Write(JsonString);//将json字符串写入流参数    sw.Close();//把流关了&#125;private void LoadByJSON()&#123;    if(File.Exists(Application.dataPath+&quot;Data.yj&quot;))    //判断文件是否创建    &#123;        StreamReader sr=new StreamReader(Application.dataPath+&quot;/Data.yj&quot;);        //从流中读取字符串        String JsonString=sr.ReadToEnd();//ReadToEnd()方法可以读取从流当前位置到结尾的所有字符//还有Read()方法，但是只读了一个字符，还有更多方法捏懒得打了        sr.Close();//把流关了        Save save=JsonUtility.FromJson&lt;Save&gt;(JsonString);//该方法属于泛型方法T，需要给出明确的类型定义，所以要写&lt;Save&gt;        GameManager.Instance.coins=save.coins;        player.transform.position=new Vector2(save.playerPosition.x,save.playerPositionY);        //属于是常规方式了    &#125;    else&#123;        Debug.LogError(&quot;File Not Found.&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们使用json完成了游戏的存档和读档操作</p><h5 id="小贴士："><a href="#小贴士：" class="headerlink" title="小贴士："></a>小贴士：</h5><p>json方法里的泛型和强制转换属于两码事，前者是一个方法，可以满足多个类型的实现(但是要使用&lt;&gt;标明类型)而后者只能完成一个类型，所以需要在前面加括号，或者使用as对错误的类型进行强制转换</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>json看似完美的解决了文件可读性的问题（如果我们打开文件，看到的便是json本来的文本样式），但是json背后还是有着缺点：当在人机都需要识别数据时（比如说配置文件），json的可读性也会变得差，如果你要储存复杂场景，比如树的坐标，比如草的坐标，那一堆堆的数组表示的坐标肯定看得你想要坐牢。在这里提醒一下，当你打开json文件时，里面可不会有换行符一行行给你打的清楚，而是全部拧成了一团。那么，有没有一种文件保存类型，既可以在Unity里保存和读取数据，也可以具有良好的结构性和描述性呢？那就是最后一个我要介绍的最后一个类型：</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><h4 id="XML-1"><a href="#XML-1" class="headerlink" title="XML"></a>XML</h4><p>XML，意思是可扩展标记语言（eXtensible Markup Language）。为什么不叫EML呢？因为这样和eml（发邮件的文件后缀格式）重名了。。。</p><p>咳咳，言归正传，它专门被设计用来结构化“存储”和”传输“数据或者信息。它可以在不兼容的系统之间轻松交换数据，简化数据共享。而且，XML数据以纯文本方式进行存储（本质就是字符串），可以给任何阅读设备使用。</p><p>有些人听着可能觉得：这不就是html🐎？事实上两者确实是有区别的：html主要显示网站上的内容（文字、图片等），事实上，我们文章一开头网易云音乐放的真夜的歌（\真夜/\真夜/\真夜/\真夜/\真夜/\真夜/）<del>（突发恶疾.jpg）</del>就是通过html实现的：</p><p>阿巴<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1399789328&auto=1&height=66"></iframe>阿巴</p><p>在一个网站中，HTML负责网页内容的显示，CSS负责内容的颜色和排版，javascript负责进行一些交互功能的实现。（这些是前端的知识了属于是）</p><p>而XML相比于HTML，XML更在意里面存储的信息。比如说XML里面的标签可以自定义，而HTML都是预先定义好的，所以XML更能胜任这个存档的职能。</p><p><strong>接下来就有点重要了：</strong></p><p>为什么我们说XML相比于json更具有结构性呢？这是因为XML中的每个元素形成了一个文档树。我们可以创建一个玩家的根节点或者敌人的根节点，然后把这些对象应该拥有的变量通过AppendChild的方式附录到根节点上。这样人们想要看玩家的数据，只要找到玩家的节点一个个看就可以了，而不要像json一样挤在一起，难以分辨。下面应用里我手打的XML应该可以体现这一点。</p><h4 id="XmlDocument类"><a href="#XmlDocument类" class="headerlink" title="XmlDocument类"></a>XmlDocument类</h4><p>用来保存，加载和解析XML文件，通过这个类可以对xml文件进行创建、保存、读取、添加以及删除。</p><p>不仅如此，这个类还有一个静态方法：<code>xmlDocument.CreateElement(&quot;node&quot;);</code>它可以在xml文档中创建一个“元素节点”（名字当然是自定义的，也就是标签），</p><p><strong>注意：使用XmlDocument类前需要引入<code>System.Xml</code>命名空间哟~</strong></p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System.Xml; //还是提醒一下private void SaveByXML()&#123;    Save save=CreateSave();    XmlDocument xmlDocument=new XmlDocument();        #region CreateXML elements            XmlElement root=XmlDocument.CreateElement(&quot;Save&quot;);    //创建一个参数名为&quot;Save&quot;的xml元素，这个元素名字叫root    //这么取在脚本里就更好理解了    root.SetAttribute(&quot;FileName&quot;,&quot;File_01&quot;);        XmlElement coinElement=xmlDocument.CreateElement(&quot;Coins&quot;);    coinElement.InnerText=save.coins.ToString();    //创建金币保存的元素，并将金币数以字符串形式导入    root.AppendChild(coinElement);    //将coinElement这一元素附录至根节点root上        XmlElement playerPositionXElement=xmlDocument.CreateElement(&quot;PlayerPositionX&quot;);    playerPositionXElement.InnerText=save.playerPositionX.ToString();    root.AppendChild(playerPositionXElement);    //接下来就是重复步骤：创建节点、储存数据、将节点附录至根节点        XmlElement playerPositionYElement=xmlDocument.CreateElement(&quot;PlayerPositionY&quot;);    playerPositionYElement.InnerText=save.playerPositionY.ToString();    root.AppendChild(playerPositionYElement);        #endregion    xmlDocument.AppendChild(root);    //最后要把根节点附录在文件上，以便于文件可以保存        xmlDocument.Save(Application.dataPath+&quot;DataXML.yj&quot;);    //把数据保存在文件“DataXML.yj”里    if(File.Exists(Application.dataPath+&quot;DataXML.yj&quot;))&#123;        Debug.Log(&quot;XML FILE SAVED&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>接下来，如果你保存了并且打开了DataXML.yj，里面会是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Save</span> <span class="attr">FileName</span>=<span class="string">&quot;File_01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Coins</span>&gt;</span>20<span class="tag">&lt;/<span class="name">Coins</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionX</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">PlayerPositionX</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionY</span>&gt;</span>-6<span class="tag">&lt;/<span class="name">PlayerPositionY</span>&gt;</span><span class="tag">&lt;/<span class="name">Save</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从这里我们就能看得很清楚了：在root节点（名字被我们命名为Save）下有三个子节点：Coins、PlayerPositionX、PlayerPositionY，它们都嵌套在了Save这个根节点下。相信通过这个更能理解XML文件的优越结构性了。</p><p>接下来就是读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void LoadByXML()&#123;    if(File.Exists(Application.dataPath+&quot;/DataXML.yj&quot;))    &#123;        Save save=new Save();                XmlDocument xmlDocument=new XmlDocument();        xmlDocument.Load(Applicatiom.dataPath+&quot;/DataXML.yj&quot;);        //创建并读取保存的XML文件        XmlNodeList coins=xmlDocument.GetElementsByTagName(&quot;Coins&quot;);        //寻找标签名称来找到保存在文件里的金币数        int coincount=int.Parse(coins[0].InnerText);        //MARKER 为什么是[0]呢？因为如果标签名为Coins的有很多的话，就会重复        //所以返回的是List集合类型，第一个为[0]，第二个为[1]        //将String类的金币数通过Parse转化为int并存进变量里        save.coins=coincount;        XmlNodeList positionX=xml.DocumentXGetElementsByTagName(&quot;positionX&quot;);        float positionXcount=float.Parse(positionX[0].InnerText);        save.playerPositionX=positionXcount;                XmlNodeList positionY=xml.Document.GetElementsByTagName(&quot;positionY&quot;);        float positionYcount=float.Parse(positionY[0].InnerText);        save.playerPositionY=positionYcount;                GameManager.instance.coins=save.coins;        player.transform.position=new Vector2(save.playerPositionX,save.playerPositionY);    &#125;    else    &#123;        Debug.LogError(&quot;NOT FOUND FILE&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样看XML可能还不太清楚，所以我打算在把敌人的数据也保存在XML里面，这样就得改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using System.Xml; //还是提醒一下private void SaveByXML()&#123;    Save save=CreateSave();    XmlDocument xmlDocument=new XmlDocument();        #region CreateXML elements            XmlElement root=XmlDocument.CreateElement(&quot;Save&quot;);    //创建一个参数名为&quot;Save&quot;的xml元素，这个元素名字叫root    //这么取在脚本里就更好理解了    root.SetAttribute(&quot;FileName&quot;,&quot;File_01&quot;);        XmlElement coinElement=xmlDocument.CreateElement(&quot;Coins&quot;);    coinElement.InnerText=save.coins.ToString();    //创建金币保存的元素，并将金币数以字符串形式导入    root.AppendChild(coinElement);    //将coinElement这一元素附录至根节点root上        XmlElement playerPositionXElement=xmlDocument.CreateElement(&quot;PlayerPositionX&quot;);    playerPositionXElement.InnerText=save.playerPositionX.ToString();    root.AppendChild(playerPositionXElement);    //接下来就是重复步骤：创建节点、储存数据、将节点附录至根节点        XmlElement playerPositionYElement=xmlDocument.CreateElement(&quot;PlayerPositionY&quot;);    playerPositionYElement.InnerText=save.playerPositionY.ToString();    root.AppendChild(playerPositionYElement);        XmlElement enemy,enemyPositionX,enemyPositionY,isDead;    for(int i=0;i&lt;save.enemyPositionX.Count;i++)&#123;        enemy=xmlDocument.CreateElement(&quot;Enemy&quot;);        enemyPositionX=xmlDocument.CreateElement(&quot;EnemyPositionX&quot;);        enemyPositionY=xmlDocument.CreateElement(&quot;EnemyPositionY&quot;);        isDead=xmlDocument.CreateElement(&quot;IsDead&quot;);        enemyPositionX.InnerText=save.enemyPositionX[i].ToString();        enemyPositionY.InnerText=save.enemyPositionY[i].ToString();        isDead.InnerText=save.isDead[i].ToString();        enemy.AppendChild(enemyPositionX);        enemy.AppendChild(enemyPositionY);        enemy.AppendChild(isDead);        root.AppendChild(enemy);    &#125;        #endregion    xmlDocument.AppendChild(root);    //最后要把根节点附录在文件上，以便于文件可以保存        xmlDocument.Save(Application.dataPath+&quot;DataXML.yj&quot;);    //把数据保存在文件“DataXML.yj”里    if(File.Exists(Application.dataPath+&quot;DataXML.yj&quot;))&#123;        Debug.Log(&quot;XML FILE SAVED&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><p>而XML文档也会变成这个样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Save</span> <span class="attr">FileName</span>=<span class="string">&quot;File_01&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Coins</span>&gt;</span>20<span class="tag">&lt;/<span class="name">Coins</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionX</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">PlayerPositionX</span>&gt;</span>    <span class="tag">&lt;<span class="name">PlayerPositionY</span>&gt;</span>-6<span class="tag">&lt;/<span class="name">PlayerPositionY</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-2.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>2<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>True<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-2.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>2<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>False<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-0.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>5<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>True<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>2<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>False<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span>    <span class="tag">&lt;<span class="name">Enemy</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionX</span>&gt;</span>-21<span class="tag">&lt;/<span class="name">EnemyPositionX</span>&gt;</span>        <span class="tag">&lt;<span class="name">EnemyPositionY</span>&gt;</span>20<span class="tag">&lt;/<span class="name">EnemyPositionY</span>&gt;</span>        <span class="tag">&lt;<span class="name">IsDead</span>&gt;</span>False<span class="tag">&lt;/<span class="name">IsDead</span>&gt;</span>    <span class="tag">&lt;/<span class="name">Enemy</span>&gt;</span><span class="tag">&lt;/<span class="name">Save</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样看起来确实就很舒适了(相比于json文件)</p><p>在读取环节也要加一点东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void LoadByXML()&#123;    if(File.Exists(Application.dataPath+&quot;/DataXML.yj&quot;))    &#123;        Save save=new Save();                XmlDocument xmlDocument=new XmlDocument();        xmlDocument.Load(Applicatiom.dataPath+&quot;/DataXML.yj&quot;);        //创建并读取保存的XML文件        XmlNodeList coins=xmlDocument.GetElementsByTagName(&quot;Coins&quot;);        //寻找标签名称来找到保存在文件里的金币数        int coincount=int.Parse(coins[0].InnerText);        //MARKER 为什么是[0]呢？因为如果标签名为Coins的有很多的话，就会重复        //所以返回的是List集合类型，第一个为[0]，第二个为[1]        //将String类的金币数通过Parse转化为int并存进变量里        save.coins=coincount;        XmlNodeList positionX=xml.DocumentXGetElementsByTagName(&quot;positionX&quot;);        float positionXcount=float.Parse(positionX[0].InnerText);        save.playerPositionX=positionXcount;                XmlNodeList positionY=xml.Document.GetElementsByTagName(&quot;positionY&quot;);        float positionYcount=float.Parse(positionY[0].InnerText);        save.playerPositionY=positionYcount;        if(enemy.Count!=0)&#123;            for(int i=0;i&lt;enemy.Count;i++)&#123;                XmlNodeList enemyPositionX=xml.Document.GetElementsByTagName(&quot;EnemyPositionX&quot;);                float enemyPosX=float.Parse(enemyPositionX.InnerText);                save.enemyPositionX.Add(enemyPosX);//由于对象save中敌人坐标声明为List集合，所以需要List.Add进行数值的添加                XmlNodeList enemyPositionY=xml.Document.GetElementsByTagName(&quot;EnemyPositionY&quot;);                float enemyPosY=float.Parse(enemyPositionY.InnerText);                save.enemyPositionY。Add(enemyPosY);                XmlNodeList isDead=xml.Document.GetElementsByTagName(&quot;IsDead&quot;);            &#125;        &#125;                GameManager.instance.coins=save.coins;        player.transform.position=new Vector2(save.playerPositionX,save.playerPositionY);                for(int i=0;i&lt;save.isDead.Count;i++)&#123;    if(GameManager.instance.enemies[i]==null)&#123;        if(!save.isDead[i])//如果敌人在我们保存之后死了        &#123;            float enemyPosX=save.enemyPositionX[i];            float enemyPosY=save.enemyPositionY[i];            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);            GameManager.Instance.enemies[i]=newBat;            //把本该活着的敌人数据进行填充        &#125;else&#123;            float enemyPosX=save.enemyPositionX[i];            float enemyPosY=save.enemyPositionY[i];            Enemy newEnemy=Instantiate(enemyPrefab,new Vector2(enemyPosX,enemyPosY),Quaternion.identity);        &#125;    &#125;&#125;    &#125;    else    &#123;        Debug.LogError(&quot;NOT FOUND FILE&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>XML从个人观感上确实好了不少，可是你看着这代码。。。属实让人头皮发麻。毕竟你要在存储内容的基础上还要加上结构层次，多点代码量看上去也是理所应当的。</p><h2 id="All-In-All"><a href="#All-In-All" class="headerlink" title="All In All"></a>All In All</h2><p>其实把对象储存进文件的方式还有很多，只是目前主流方式就是这四种了。PlayerPrefs可以较为简单的进行存档读档，但是却只能进行一些简单的操作（比如玩家设置等轻量数据），存储的数值也只局限于int,float,string三种类型，连List类都无法支持。序列化和反序列化看似可以解决数据的存储和读取，而且存档的内容也不至于让别人那么容易地进行篡改。但是改不了你自己也读不懂啊，而且还要加上很长的命名空间。json相对而言就不用加上一些复杂的命名空间，存储的文档也让人看得懂。但是储存的东西一下多了，你打开文档时，那不带换行的原始json文件又给你带来一个全新的坐牢体验。XML就很好的解决了文档可读性的问题，但是相对的代码量也提高了114514倍，命名空间也加了一个。关于这四种方式的解决问题，建议读者根据自己的实际情况进行选择。不过在我看来，json应该是最佳的选择把。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="https://karmotrine.fun/categories/Unity/"/>
    
    
    <category term="教程" scheme="https://karmotrine.fun/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://karmotrine.fun/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>关于Unity协程函数的个人理解</title>
    <link href="https://karmotrine.fun/2021/04/11/%E5%85%B3%E4%BA%8EUnity%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>https://karmotrine.fun/2021/04/11/%E5%85%B3%E4%BA%8EUnity%E5%8D%8F%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2021-04-11T15:03:06.000Z</published>
    <updated>2022-01-07T11:30:50.085Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=29794281&auto=1&height=66"></iframe><p>Hello,这里是Karmotrine之众所周知，Unity的协程函数一直Unity匪夷所思的难点之一。至少它在一开始就困扰了我很久.但是在现在，我好像悟了（bushi，就把自己的理解打在公屏上，希望dalao轻喷。<del>想不到吧我竟然更了哈哈哈哈哈哈好吧其实我也妹想到</del></p><h2 id="Unity的协程和线程"><a href="#Unity的协程和线程" class="headerlink" title="Unity的协程和线程"></a>Unity的协程和线程</h2><p>​        在谈协程函数之前，我们先了解一下协程和线程的区别。线程相当于Unity中一直在进行的事物，只有在程序或者脚本结束时才能停止。比如说<code>Update</code>函数，它在程序开始时的每一帧都会被调用，而不是<code>Start</code>或者<code>Awake</code>那样只被调用一次。而协程函数就不一样了。它可以随意在某个时间被启用，也可以持续随便一段时间，也可以在任意时间暂停又开始，也可以在任意时间结束。比如说之前文章里的对话框系统。我只想这个脚本在对话框系统启用时才调用它，然后一结束就关闭。这个时候使用线程显然是不太行的，用协程函数写简直无比舒适。demone,协程函数也有所谓的缺点，它的开始，暂停，结束都需要我们手动进行操作，而不像线程那样只要一开程序就不用管了。而且协程改变的参量会被线程改变。比如说我协程写了冲刺给物体的速度赋值，然后它就被线程里的<code>Move</code>函数改回来了，导致根本冲不动<del>(????????)</del>的事情发生。</p><p>​        综上所述，协程和线程的主要区别为：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。而线程就不需要管那么多，写就完事了，但是我们也要做好不能随意让它停止或者不干扰协程运行的准备。</p><h2 id="IEnumerator的神仙妙用"><a href="#IEnumerator的神仙妙用" class="headerlink" title="IEnumerator的神仙妙用"></a><code>IEnumerator</code>的神仙妙用</h2><p>在了解了协程的主要功能后，我们就可以来聊聊协程函数了？然而并不行，我们还要从一个功能开始：</p><h3 id="如何完成cd的冷却-倒计时？"><a href="#如何完成cd的冷却-倒计时？" class="headerlink" title="如何完成cd的冷却/倒计时？"></a>如何完成cd的冷却/倒计时？</h3><p>​        众所周知，一个游戏肯定要有cd：闪现有cd，对话框一个字一个字出来有cd，<del>就连手冲都要有cd（我有个朋友想要这个游戏）</del>，但是如何实现这个功能呢？这显然是easygame：<code>Update</code>函数会每一帧调用，这样就能实现时间的流逝，而不像其他函数就调用一帧，指过一帧的时间就咋瓦鲁多了，这还怎么整嘛。所以，倒计时系统就应该这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;//这里timer要在函数外面赋值，这里就省略了</span><br><span class="line">timer -= Time.deltaTime; //控制cd的变量随时间减小而自减</span><br><span class="line">if(timer &lt;= 0)</span><br><span class="line">Debug.Log(&quot;结束辣！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这搞一个倒计时还好，但如果我要整114514个呢？<del>（怎么臭起来了）</del>这样我们只能多写几个变量一起算？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">shanxianTimer -= Time.deltaTime;</span><br><span class="line">if(shanxianTimer &lt;= 0)</span><br><span class="line">Debug.Log(&quot;交闪现辣！&quot;);</span><br><span class="line">tell -= Time.deltaTime;</span><br><span class="line">if(tell &lt;= 0)</span><br><span class="line">Debug.Log(&quot;讲完辣!&quot;);</span><br><span class="line">kkskkksk -= Time.deltaTime;</span><br><span class="line">if(kkskkksk &lt;= 0)</span><br><span class="line">Debug.Log(&quot;冲完辣！&quot;); //？？？？？？？？</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demone,这样做岂不是有亿点繁琐，这样还是3个，如果是114514个<del>（捂鼻）</del>该怎么办？那不如写个循环？？？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(float timer = 114514; timer &gt;= 0; timer -= Time.deltaTime)</span><br><span class="line">&#123;</span><br><span class="line">//交闪现了！blabla</span><br><span class="line">&#125;</span><br><span class="line">Debug.Log(&quot;owari!&quot;);</span><br></pre></td></tr></table></figure><p>欸，你这个写的就正好和协程一样了，因为瓦塔西的协程函数正好可以做到这一点！</p><h3 id="协程函数的主要介绍"><a href="#协程函数的主要介绍" class="headerlink" title="协程函数的主要介绍"></a>协程函数的主要介绍</h3><p>那我们就以协程函数来写一个倒计时系统吧（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">StartCoroutine(Countdown());</span><br><span class="line">&#125;</span><br><span class="line">IEnumerator Countdown()</span><br><span class="line">&#123;</span><br><span class="line">for(float shanxian = 3; shanxian &gt;= 0; shanxian -= Time.deltaTime)</span><br><span class="line">yield return 0;</span><br><span class="line">Debug.Log(&quot;交闪现辣!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这中间：</p><p><code>StartCoroutine(Countdown())</code>就指的是开始协程函数（协程函数这么nb，自然要有特殊的打开方式</p><p><code>IEnumerator</code>是协程函数特有的开头，就类似于<code>void</code>、<code>int</code>之类的</p><p><code>for</code>函数和<code>Debug</code>没什么好说的，也就是倒计时然后提醒而已。</p><p>然后结束协程函数就是<code>StopCoroutine(Countdown())</code>了，然后如果要全部停止就可以打<code>StopAllCoroutine()</code>，但是我们不是经常用，因为协程函数也和其它函数一样，一到末尾就结束了。</p><p><strong>接下来才是我们重中之重的：</strong></p><p><code>yield return 0</code>了。</p><h3 id="wtf-is-yield-return"><a href="#wtf-is-yield-return" class="headerlink" title="wtf is yield return???"></a>wtf is yield return???</h3><p>关于<code>yield return 0</code>真的困扰了我很久，对于它的功能，我只能说是：停止执行方法，并且在下一帧从这里重新开始。这是什么意思呢？我们先看下面一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator SayWDNMD()</span><br><span class="line">&#123;//模仿打csgo的语音对话(bushi</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;W&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;D&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;N&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;M&quot;);</span><br><span class="line">Yield return 0;</span><br><span class="line">Debug.Log(&quot;D&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在调用这个方法的结果是什么呢，由于我懒得开Unity截图结果，再加上可能会出现偏差，所以这波直接高中理科实验吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间 内容</span><br><span class="line">0    W</span><br><span class="line">0.02 D</span><br><span class="line">0.04 N</span><br><span class="line">0.06 M</span><br><span class="line">0.08 D</span><br></pre></td></tr></table></figure><p>那么结果就显而易见了，每当<code>yield return 0</code>调用一次就会暂停0.02s（顺便一提，其中的0没有任何作用，改成1也是停一帧，2也是一帧，114514也是一帧）。我们把协程函数比喻你在彩虹六号：围攻作为防守的一次对局的各种动作，那么<code>yield return 0</code>就相当于lion开了技能时你的表现。你想继续行动，但是<code>yield return 0</code>卡着你硬要你等一帧才能继续。</p><h4 id="常见提问："><a href="#常见提问：" class="headerlink" title="常见提问："></a>常见提问：</h4><p><strong>为什么会出现偏差？</strong></p><p>因为Unity每一帧的时间是不一样的，可能这帧时间为0.02s，但下一帧就可能不是。因此Unity提供了<code>Update</code>和<code>FixedUpdate</code>两个函数，其中<code>FixedUpdate</code>函数就是在每个固定一帧的时间内调用。这里为了方便就固定是0.02s<del>（明明就是你想偷懒）</del></p><p><strong>可不可以不停一帧，改成其他时间？</strong></p><p>可以的，但是要改成<code>yield return new WaitForSeconds(Time)</code>，其中Time表示你要暂停的时间，以秒为单位。</p><h3 id="小细节，大作用"><a href="#小细节，大作用" class="headerlink" title="小细节，大作用"></a>小细节，大作用</h3><p>那么我们这样卡一下到底有什么用呢？作用可以说是很大了。因为：</p><p><em><strong>我们可以将需要时间流逝的函数写成了一种单独的方法，不需要一股脑全部丢进<code>Update</code>函数里。并且我们还可以随时停止并规定停止的时间，不像<code>Update</code>函数一开始就停不下来。</strong></em></p><p>协程函数最为简单的应用就是作为倒计时使用，比如进行冲刺后的冷却：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator Recover()</span><br><span class="line">    &#123;</span><br><span class="line">        for(;CoolDownTimer&gt;=0f; CoolDownTimer -= Time.deltaTime)</span><br><span class="line">        &#123;</span><br><span class="line">            yield return 0; </span><br><span class="line">        &#125;</span><br><span class="line">        if (CoolDownTimer &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            canDash = true;</span><br><span class="line">            DashTimer = DashTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>众所周知，我们在游戏时肯定不会一直冲啊，<del>（一直冲现实也受不了吧）</del>放进<code>Update</code>函数里肯定不太合适（但实际上放进去是可以的，写个if放里面就差不多，但是作为方法储存代码肯定更好看一点）。而这时候作为方法写进协程函数简直是再好不过了。</p><h4 id="常见提问：-1"><a href="#常见提问：-1" class="headerlink" title="常见提问："></a>常见提问：</h4><p><strong><code>yield return 0</code>放在循环里是否必要？</strong></p><p>依照我个人理解，其实<code>yield return 0</code>放在哪里都可以。因为它只是借用了协程函数可以按照时间变化而变化的好处来写的，其实并不需要在哪里停一下。但是为什么要写呢，因为<strong>Unity规定协程函数至少要有一个<code>yield</code>进行结束</strong>，所以就随便放呗~~（大概）~~~</p><p><strong>但是要注意一点，在计时的循环里一定要存在<code>yield return 0</code>这个语句</strong>，因为它的功能是在这一帧停止，然后在下一帧开始。如果没有加的话，它就一直继续，然后就能在一帧内处理你设定的几秒的计时，也就不存在你的计时了。。。</p><h2 id="一些其他要注意的"><a href="#一些其他要注意的" class="headerlink" title="一些其他要注意的"></a>一些其他要注意的</h2><h3 id="协程函数可以嵌套🐎？"><a href="#协程函数可以嵌套🐎？" class="headerlink" title="协程函数可以嵌套🐎？"></a>协程函数可以嵌套🐎？</h3><p>可以的，比如在冲刺和冲刺后回复的两个协程函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator CountingDash()</span><br><span class="line">    &#123;</span><br><span class="line">        if (VerticalMove != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Dashing = true;</span><br><span class="line">            PressedDash = false;</span><br><span class="line">            CoolDownTimer = CoolDownTime;</span><br><span class="line">            for (; DashTimer &gt;= 0; DashTimer -= Time.deltaTime)</span><br><span class="line">            &#123;</span><br><span class="line">                rb.velocity = new Vector2(rb.velocity.x, VerticalMove * dashSpeed);</span><br><span class="line">                yield return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (HorizontalMove != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Dashing = true;</span><br><span class="line">            PressedDash = false;</span><br><span class="line">            CoolDownTimer = CoolDownTime;</span><br><span class="line">            for (; DashTimer &gt;= 0; DashTimer -= Time.deltaTime)</span><br><span class="line">            &#123;</span><br><span class="line">                rb.velocity = new Vector2(HorizontalMove * dashSpeed, rb.velocity.y);</span><br><span class="line">                yield return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Dashing = false;</span><br><span class="line">        canDash = false;</span><br><span class="line">        StartCoroutine(Recover()); //看，这里嵌套了</span><br><span class="line">        yield break; //和yield return 0一样的结果</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>虽然协程函数有时候很好用，但是建议没有掌握的人还是全部丢进<code>Update</code>函数里，毕竟我之前因为协程已经卡死114514次，重做了114514次对话框了。。。</p><p><em><strong>其他的以后想到了在更qwq</strong></em></p><p><strong>差不多讲完了，祝民那桑用协程函数“怎么那么熟练啊”，Unity不卡崩~</strong></p><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p>csdn的各种协程函数教程：（自己上官网看吧）<del>这nm是友情链接？？？</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="https://karmotrine.fun/categories/Unity/"/>
    
    
    <category term="教程" scheme="https://karmotrine.fun/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://karmotrine.fun/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>在Unity中不使用任何插件制作角色对话框系统</title>
    <link href="https://karmotrine.fun/2021/04/08/%E5%9C%A8Unity%E4%B8%AD%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E8%A7%92%E8%89%B2%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://karmotrine.fun/2021/04/08/%E5%9C%A8Unity%E4%B8%AD%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E8%A7%92%E8%89%B2%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-04-08T13:42:08.000Z</published>
    <updated>2022-01-07T11:42:13.905Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1810759765&auto=1&height=66"></iframe><p>在众多RPG等游戏中，对话框系统显然属于不可或缺的一部分。玩家通过对话了解剧情以及接下来的主线。可以说，<del>对话系统就是RPG游戏的灵魂（bushi</del>,而这个文章介绍的对话系统可以在无需插件并且完成对话系统基本功能的同时完成以下三点内容：</p><p><strong>1.剧情内容只用按照规律写在txt文件里</strong></p><p><strong>2.可以选择跳过，自动播放或者手动播放</strong></p><p><strong>3.文字会一个一个显示，而不是整句话蹦出来</strong></p><p>撒，那我们开始把（</p><h2 id="搭建对话框"><a href="#搭建对话框" class="headerlink" title="搭建对话框"></a>搭建对话框</h2><p>​        按照以往经验，对话框肯定要包括对话信息框，角色的头像和名字。然后我在此基础上还要实现自动播放，跳过，所以加了两个按钮。如果还要其它功能可以自己再加。。。我直接简单搭了一个：</p><p><img src="%E5%AF%B9%E8%AF%9D%E6%A1%86.png" alt="对话框" loading="lazy"></p><p>其中对话框主体直接在canvas的最下面加了panel，角色名称，对话内容分开来各用一个text（因为到时候要随着角色的改变而改变），并且以panel为父物体。（这个没什么难度，直接简写了）</p><p><strong>注意！：</strong></p><p>无论要怎么改，对话框物体一定要设置锚点卡在屏幕的各个角落，否则会因为屏幕尺寸发生变化而偏移！</p><p><img src="%E6%B3%A8%E6%84%8F.png" alt="注意" loading="lazy"></p><p>锚点设置方法：点击红箭头指的按钮，按住alt键，选择要固定在屏幕的哪个地点。</p><h2 id="构建基础功能"><a href="#构建基础功能" class="headerlink" title="构建基础功能"></a>构建基础功能</h2><p>要实现基础功能，就要通过三个流程：</p><p><strong>1.将txt文本文件导入列表</strong></p><p><strong>2.将列表内的台词依次播放，同时根据角色的转变而变换头像</strong></p><p><strong>3.判断结束对话并且把所有对话框组件setactive改为false</strong></p><p>先是声明的各种物体代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> [Header(&quot;UI组件&quot;)]</span><br><span class="line">    public Text textLabel;  //对话框的内容text</span><br><span class="line">    public GameObject SkipButton; //跳过按钮</span><br><span class="line">    public GameObject AutoButton; //自动播放按钮</span><br><span class="line">    public GameObject Log; //对话框的panel</span><br><span class="line">    public Text AutoText; //自动播放按钮的“自动播放”文本的text（用于实现自动手动切换的功能）</span><br><span class="line">    public GameObject Warning; //提醒玩家按左键继续，可要可不要</span><br><span class="line">[Header(&quot;文本文件&quot;)]</span><br><span class="line">public TextAsset textfile; //剧情文本的txt文件</span><br><span class="line">public int index; //进行到了第几句话，用于实现基础功能</span><br><span class="line">public float textSpeed = 0.05f; //每个字多久才能出现</span><br><span class="line"></span><br><span class="line">[Header(&quot;头像&quot;)]</span><br><span class="line">public GameObject A; //角色的头像以及名字</span><br><span class="line">public GameObject B; //角色的头像以及名字</span><br><span class="line">//因为我直接把名字和头像绑定为父子物体了，所以只声明了一个GameObect</span><br><span class="line"></span><br><span class="line">bool textFinished; //判断对话是否结束</span><br><span class="line">float i=0f; //判断是否为自动还是手动播放</span><br><span class="line"></span><br><span class="line">List&lt;string&gt; textList = new List&lt;string&gt;(); //将txt文件的对话内容导入列表内</span><br></pre></td></tr></table></figure><p>接着进unity把每个组件都挂载一下（具体是啥我在注释都写了，所以就不贴图了）</p><h3 id="将txt文本文件导入列表"><a href="#将txt文本文件导入列表" class="headerlink" title="将txt文本文件导入列表"></a>将txt文本文件导入列表</h3><p>在说明代码前先把txt的格式说明一下（为什么这样之后再说）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">换一个角色说话之前要把角色的名字单独打一行</span><br><span class="line">就像这样</span><br><span class="line">B</span><br><span class="line">这样就换成了我（</span><br><span class="line">结束的时候不需要标记什么</span><br></pre></td></tr></table></figure><p>先贴上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> void GetTextFromFile(TextAsset file)</span><br><span class="line">&#123;</span><br><span class="line">     textList.Clear(); //如果不是第一次调用对话框，就需要把之前一次所有对话的列表给清空</span><br><span class="line">     index = 0; //并且把显示第几句话的index清零</span><br><span class="line">     var lineData = file.text.Split(&#x27;\n&#x27;); //把文本文件以回车分割一句句台词和角色名称</span><br><span class="line"></span><br><span class="line">     foreach (var line in lineData) </span><br><span class="line">    &#123;</span><br><span class="line">        textList.Add(line); //把一句句台词录入line列表里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之就是：重置之前用过的台词和数据，处理文本文件，用回车键分割一句句台词，然后把台词录入列表以供对话系统使用。</p><p><strong>注意：</strong></p><p>在调用时要放在Awake函数里，因为Awake函数是一启用脚本就开始运行，而这个工序也要一经使用就开始运行。我的脚本调用是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        GetTextFromFile(textfile);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="将列表内台词播放"><a href="#将列表内台词播放" class="headerlink" title="将列表内台词播放"></a>将列表内台词播放</h3><p><em><strong>注意：看懂这段代码需要学习unity协程函数的知识，如果之前没有听过建议百度学习一下或者等我的文章更新<del>（算了我天天鸽还是别等了）</del></strong></em></p><h4 id="单个句子的播放"><a href="#单个句子的播放" class="headerlink" title="单个句子的播放"></a>单个句子的播放</h4><p>还是贴代码（这个代码实现的只是单个句子的播放，而不是整个对话）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator SetTextUI() //协程函数的标准形式</span><br><span class="line">    &#123;</span><br><span class="line">        textFinished = false; //正在播放，所以bool值为false</span><br><span class="line">        textLabel.text = &quot;&quot;; //可能上一个句子使用结束后还在text上，所以要清空</span><br><span class="line">    switch (textList[index]) //index是指播放到了第几句，所以这是来判断当前播放到的台词</span><br><span class="line">        //用来判断是谁说出来的（所以txt要按标准写嘛（叉腰））</span><br><span class="line">    &#123;</span><br><span class="line">        case &quot;A\r&quot;://如果A要说话</span><br><span class="line">            &#123;</span><br><span class="line">                A.SetActive(true); //头像名字显示出来</span><br><span class="line">                index++; //直接跳到下一句，这样就不会直接出现在对话框的对话里面</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">                //如果还要写别人的话，case信息和上面一样</span><br><span class="line">        case &quot;旁白\r&quot;: //与上面同理</span><br><span class="line">            &#123;</span><br><span class="line">                QingShan.SetActive(false);</span><br><span class="line">                index++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; textList[index].Length; i++)</span><br><span class="line">        //按照一句话的一个字慢慢来，如果没有到一句台词最后一个字的话就一直向后</span><br><span class="line">    &#123;</span><br><span class="line">        textLabel.text += textList[index][i]; //往之前已经打出的台词中加进新的文字</span><br><span class="line">        yield return new WaitForSeconds(textSpeed);//等待textSpeed后继续循环</span><br><span class="line">    &#125;</span><br><span class="line">    textFinished = true; //如果跳出循环说明文字已经放完了，所以bool值是true</span><br><span class="line">    index++; //这句话已经放完了，index++跳进下一句话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>yield return</code>的意思就是，在这一帧return，并且在下一帧继续开始。如果看不懂的话还是建议百度一下unity协程函数。<del>这样的话不用放进update函数里面也可以实现延时等效果。(暴论)</del></p><h5 id="常见问答（bushi-："><a href="#常见问答（bushi-：" class="headerlink" title="常见问答（bushi)："></a>常见问答（bushi)：</h5><p><strong>为什么判断是角色名字后不直接跳出函数，而是继续打出呢？</strong></p><p>因为txt里面角色名字后面一定是角色说的话而不是另一个角色的名字，所以可以直接不需要判断而进入循环。<del>同时在写txt剧情时也要注意：哪有一个角色还没讲话就出现另外一个角色的道理哼哼啊啊啊啊啊</del></p><p><strong>为什么角色名字后面要加/r?</strong></p><p>因为在windows的txt文本中，每次回车都会有\r的存在。如果要判断是不是角色名就一定要加上\r，<del>除非你不是拿windows做游戏。</del></p><hr><h4 id="整个对话文本的播放"><a href="#整个对话文本的播放" class="headerlink" title="整个对话文本的播放"></a>整个对话文本的播放</h4><p>还是先贴代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Update()&#123;</span><br><span class="line">AutoText.text = &quot;自动播放&quot;; //切换自动手动播放时要用的</span><br><span class="line">    textSpeed = 0.05f; //每个字出来的间隔时0.05秒</span><br><span class="line">    if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; index == textList.Count)</span><br><span class="line">    &#123;</span><br><span class="line">    EndDialogue();//如果按下鼠标左键并且播放到了最后一句的话就启动结束对话的函数</span><br><span class="line">    &#125;</span><br><span class="line">    if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; textFinished)</span><br><span class="line">    &#123;</span><br><span class="line">    StartCoroutine(SetTextUI());//如果按下鼠标左键的同时一句话已经放完了，就继续启动下一句的播放</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常见问答-bushi-："><a href="#常见问答-bushi-：" class="headerlink" title="常见问答(bushi)："></a>常见问答(bushi)：</h5><p><strong>为什么要设置一个textFinished的布尔值？</strong></p><p>因为如果不设置的话前面一句还没有看完下一句的台词直接来了，这样会严重影响读者的阅读体验，所以我决定直接卡死不让玩家快进。</p><hr><h4 id="结束播放对话文本"><a href="#结束播放对话文本" class="headerlink" title="结束播放对话文本"></a>结束播放对话文本</h4><p>依旧是先贴上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void EndDialogue()</span><br><span class="line">&#123;//把114514个对话框组件全部隐藏，代表对话已经结束了</span><br><span class="line">gameObject.SetActive(false);</span><br><span class="line">QingShan.SetActive(false);</span><br><span class="line">Log.SetActive(false);</span><br><span class="line">SkipButton.SetActive(false);</span><br><span class="line">AutoButton.SetActive(false);</span><br><span class="line">    index = 0; //把目录调整成最开始，这样下一次开始就是从第一句播放</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个完整的对话就结束了。</p><p><em><strong>但是如何实现对话的自动手动播放，以及跳过播放呢？</strong></em></p><h2 id="完成增值功能："><a href="#完成增值功能：" class="headerlink" title="完成增值功能："></a>完成增值功能：</h2><h3 id="实现跳过对话的功能"><a href="#实现跳过对话的功能" class="headerlink" title="实现跳过对话的功能"></a>实现跳过对话的功能</h3><p>这活儿很简单，只要把脚本放进空物体，然后把按钮按下的脚本挂载进并选择EndDailogue函数里就可以了。</p><p><img src="%E6%8C%82%E8%BD%BD.png" alt="挂载" loading="lazy"></p><h3 id="实现自动手动播放的功能"><a href="#实现自动手动播放的功能" class="headerlink" title="实现自动手动播放的功能"></a>实现自动手动播放的功能</h3><p>这个功能其实比较简陋，因为我目前还没有尝试在每句话结束后调节时间的功能，只是把每个字播放的顺序调慢而已。（请大神轻喷）</p><p>还是代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (i % 2 == 0f)//当i是偶数时，说明点了偶数按钮，就是手动播放，奇数同理</span><br><span class="line">        &#123;</span><br><span class="line">            AutoText.text = &quot;自动播放&quot;; //把按钮文本改了，因为现在是手动播放</span><br><span class="line">            textSpeed = 0.05f; </span><br><span class="line">            if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; index == textList.Count)</span><br><span class="line">            &#123;</span><br><span class="line">                EndDialogue();</span><br><span class="line">            &#125;</span><br><span class="line">            if (Input.GetKeyDown(KeyCode.Mouse0) &amp;&amp; textFinished)</span><br><span class="line">            &#123;</span><br><span class="line">                StartCoroutine(SetTextUI());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            AutoText.text = &quot;手动播放&quot;;</span><br><span class="line">            textSpeed = 0.15f; //把每个字出现的时长调整长了</span><br><span class="line">            if (index == textList.Count) //因为是自动播放，所以去掉了按鼠标左键的限制</span><br><span class="line">            &#123;</span><br><span class="line">                EndDialogue();</span><br><span class="line">            &#125;</span><br><span class="line">            if (textFinished) //这里也是</span><br><span class="line">            &#123;</span><br><span class="line">                StartCoroutine(SetTextUI());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> public void AutoPlay() //要把这个函数挂载进自动播放的按钮里</span><br><span class="line">    &#123;</span><br><span class="line">        i = i + 1f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>说起来这个功能还是比较简陋，它的是否是自动手动的判定机制仅仅是判断点击按钮的次数是奇数还是偶数，按钮每次点击也只是计算点击次数的变量+1，但是它就是这么实现了？<del>就很怪</del></p><p><em><strong>再次提醒一下，AutoPlay函数要挂载进按钮里面，挂载方式和之前跳过对话的按钮一样，否则无法实现功能。</strong></em></p><hr><p><em><strong>就这样差不多就完成了，虽然小编也很惊奇，但是对话框系统就是这样完成了。有疑惑的小伙伴欢迎在评论区留下点赞评论吧！我们下期再见！<del>（你是营销号吗？？）</del></strong></em></p><h2 id="友情链接："><a href="#友情链接：" class="headerlink" title="友情链接："></a>友情链接：</h2><p><strong>大多数代码以及思想借鉴的视频：</strong><a href="https://www.bilibili.com/video/BV1WJ411Y71J">https://www.bilibili.com/video/BV1WJ411Y71J</a></p><p>(Michael真的很强，建议初学者都去康康他的视频嗷)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Unity" scheme="https://karmotrine.fun/categories/Unity/"/>
    
    
    <category term="教程" scheme="https://karmotrine.fun/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://karmotrine.fun/tags/Unity/"/>
    
  </entry>
  
</feed>
