<!DOCTYPE html><html lang="ch"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Karmotrine"><meta name="copyright" content="Karmotrine"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>简析Unity射线检测的概念与应用 | Utopia</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":["し","い","な","の","博","客"],"version":"1.7.0","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Utopia" type="application/atom+xml"><meta name="description" content="众所周知，在一款游戏中使用检测手法是十分常见的。比如说玩家自动来到某个地方触发剧情，判断子弹击中玩家的部位并造成相应血量。。。这其实都是碰撞检测的相关体现。但是，虽然碰撞检测在日常使用中相当普遍，但是碰撞检测也有相应的局限性。比如说APEX里恶灵被人拿枪指着时会有相应提示（感觉我的游戏偏好要在博客里面暴露光了），又或者是我们拿鼠标光标指向某些物体时显示出物体的具体信息（就比如像是城市模拟经营，">
<meta property="og:type" content="article">
<meta property="og:title" content="简析Unity射线检测的概念与应用">
<meta property="og:url" content="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="Utopia">
<meta property="og:description" content="众所周知，在一款游戏中使用检测手法是十分常见的。比如说玩家自动来到某个地方触发剧情，判断子弹击中玩家的部位并造成相应血量。。。这其实都是碰撞检测的相关体现。但是，虽然碰撞检测在日常使用中相当普遍，但是碰撞检测也有相应的局限性。比如说APEX里恶灵被人拿枪指着时会有相应提示（感觉我的游戏偏好要在博客里面暴露光了），又或者是我们拿鼠标光标指向某些物体时显示出物体的具体信息（就比如像是城市模拟经营，">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/%E9%A3%9E.gif">
<meta property="og:image" content="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/%E8%B5%B0.gif">
<meta property="og:image" content="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/Line.png">
<meta property="og:image" content="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/LineRenderer.png">
<meta property="og:image" content="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.png">
<meta property="article:published_time" content="2021-09-08T09:50:08.000Z">
<meta property="article:modified_time" content="2022-01-07T11:37:58.327Z">
<meta property="article:author" content="Karmotrine">
<meta property="article:tag" content="教程">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/%E9%A3%9E.gif"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Karmotrine"><img width="96" loading="lazy" src="https://portrait.gitee.com/uploads/avatars/user/2943/8831424_karmotrine_1616074181.png!avatar100" alt="Karmotrine"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">Karmotrine</a></div><span class="site-name">Utopia</span><sub class="site-subtitle">Kyrie eleison.</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">1</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=657493712&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/karm0tr1ne" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:657493712@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/191503773/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1376395329" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/karmotrine-32" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/85367843" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%84%E7%BA%BF%E6%98%AF%E5%95%A5"><span class="toc-number">1.</span> <span class="toc-text">射线是啥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3D%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-number">2.</span> <span class="toc-text">3D世界中的射线检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%8D%8F%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">咋检测的捏？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%95%A5%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.这个方法返回啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-origin%E5%92%8Cdirection%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%88%E4%BA%8C%E4%B8%BA%E4%B8%80%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.origin和direction可不可以合二为一？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%99%E6%A0%B7%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E6%88%91%E7%9C%8B%E4%B8%8D%E5%88%B0%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E6%98%BE%E7%A4%BA%E5%B0%84%E7%BA%BF%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.这样射线检测我看不到，有什么办法显示射线吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-RaycastHit%E6%84%9F%E8%A7%89%E4%B8%8D%E5%A6%82%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E3%80%82%E3%80%82%E3%80%82%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.4.</span> <span class="toc-text">4.RaycastHit感觉不如碰撞检测。。。功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-What%E2%80%99s-up-%E4%BD%A0%E8%BF%99Raycast%E5%8F%AA%E8%83%BD%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%95%8A%EF%BC%9F%EF%BC%81"><span class="toc-number">2.1.5.</span> <span class="toc-text">5.What’s up?你这Raycast只能测一个啊？！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BD%A0%E8%BF%99LayerMask%E6%9C%89%E9%97%AE%E9%A2%98%E5%95%8A%EF%BC%9F%E6%80%8E%E4%B9%88%E6%98%AFint%EF%BC%9F"><span class="toc-number">2.1.6.</span> <span class="toc-text">6.你这LayerMask有问题啊？怎么是int？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E4%BD%A0%E8%BF%99LayerMask%E5%8F%AA%E8%83%BD%E6%B5%8B%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%B1%82%EF%BC%9F"><span class="toc-number">2.1.7.</span> <span class="toc-text">6.5.你这LayerMask只能测一个图层？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%EF%BC%88%E5%9B%A0%E4%B8%BA%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E5%86%99%E6%9C%80%E5%90%8E%EF%BC%89"><span class="toc-number">2.1.8.</span> <span class="toc-text">7.（因为重中之重一定要写最后）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8B%E5%BA%94%E7%94%A8%E7%9A%84%E6%8D%8F%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">咋应用的捏？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-number">3.</span> <span class="toc-text">2D世界中的射线检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%8D%8F%EF%BC%9F-1"><span class="toc-number">3.1.</span> <span class="toc-text">咋检测的捏？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-Z%E8%BD%B4%EF%BC%8C%E5%AF%84%EF%BC%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">0.Z轴，寄！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Ray%EF%BC%8C%E5%AF%84%EF%BC%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.Ray，寄！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E6%9C%80%E6%98%8E%E6%98%BE%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BA%86%E5%B1%9E%E4%BA%8E%E6%98%AF%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">2.返回类型（作为方法最明显的不同了属于是）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%8Ftips"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.小tips</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BF%98%E6%9C%89%E4%B8%A4%E7%A7%8D%E9%87%8D%E8%BD%BD%E3%80%82%E3%80%82%E3%80%82"><span class="toc-number">3.1.5.</span> <span class="toc-text">4.还有两种重载。。。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%EF%BC%88%E5%9B%A0%E4%B8%BA%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E5%86%99%E6%9C%80%E5%90%8E%EF%BC%8C%E8%99%BD%E7%84%B6%E5%89%8D%E9%9D%A2%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86%E4%BD%86%E6%98%AF%E8%BF%98%E6%98%AF%E8%A6%81%E7%B2%98%E8%B4%B4%E4%B8%80%E6%B3%A2%EF%BC%89"><span class="toc-number">3.1.6.</span> <span class="toc-text">5.（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8B%E5%BA%94%E7%94%A8%E7%9A%84%E6%8D%8F%EF%BC%9F-1"><span class="toc-number">3.2.</span> <span class="toc-text">咋应用的捏？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%88%A4%E5%AE%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">内部判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E8%A7%89%E5%AE%9E%E7%8E%B0%EF%BC%88LineRenderer%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">视觉实现（LineRenderer组件）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Position"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">（1）Position</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-Width"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">（2） Width</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Color"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">（3）Color</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89End-CapVertices"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">（4）End CapVertices</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Use-World-Space"><span class="toc-number">3.2.2.5.</span> <span class="toc-text">(5)Use World Space</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%BA%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">射线检测的一些缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%EF%BC%8C%E5%AF%84%EF%BC%81"><span class="toc-number">4.1.</span> <span class="toc-text">射线检测，寄！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OverLap%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">OverLap的妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8D%E4%B8%80%E6%A0%B7"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.返回值不一样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%E4%B8%8D%E4%B8%80%E6%A0%B7"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.适用范围不一样</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">4.3.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%83%8FDrawLine%E9%82%A3%E6%A0%B7%E6%98%BE%E7%A4%BA%E5%87%BA%E6%95%B4%E4%B8%AA%E6%A3%80%E6%B5%8B%E8%8C%83%E5%9B%B4%EF%BC%9F"><span class="toc-number">4.3.1.</span> <span class="toc-text">如何像DrawLine那样显示出整个检测范围？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%B3%E5%8F%B0%E8%B7%B3%E8%B7%83%E4%B8%AD%E8%B4%B4%E7%9D%80%E5%A2%99%E6%8E%89%E4%B8%8D%E4%B8%8B%E5%8E%BB%EF%BC%9F"><span class="toc-number">4.3.2.</span> <span class="toc-text">为什么平台跳跃中贴着墙掉不下去？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E8%AF%A5%E5%BD%A2%E7%8A%B6%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E7%A2%B0%E6%92%9E%E4%BD%93%EF%BC%9F"><span class="toc-number">4.3.3.</span> <span class="toc-text">如何检测该形状范围内的所有碰撞体？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-number">5.</span> <span class="toc-text">总结一下</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Karmotrine"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Utopia"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">简析Unity射线检测的概念与应用</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-09-08 17:50:08" itemprop="dateCreated datePublished" datetime="2021-09-08T17:50:08+08:00">2021-09-08</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-01-07 19:37:58" itemprop="dateModified" datetime="2022-01-07T19:37:58+08:00">2022-01-07</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">5.3k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">19m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Unity/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Unity</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E6%95%99%E7%A8%8B/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">教程</span></a><a class="tag-item" href="/tags/Unity/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Unity</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/6c9385ec68c559cae4e1d7a3e3b483c0?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">Karmotrine.</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1840474281&auto=1&height=66"></iframe>

<p>众所周知，在一款游戏中使用检测手法是十分常见的。比如说玩家自动来到某个地方触发剧情，判断子弹击中玩家的部位并造成相应血量。。。这其实都是碰撞检测的相关体现。但是，虽然碰撞检测在日常使用中相当普遍，但是碰撞检测也有相应的局限性。比如说APEX里恶灵被人拿枪指着时会有相应提示（感觉我的游戏偏好要在博客里面暴露光了），又或者是我们拿鼠标光标指向某些物体时显示出物体的具体信息（就比如像是城市模拟经营，我们想知道这个建筑具体是啥东西；又比如即时战略游戏我们想看一个兵种的具体血量等属性），那碰撞检测就显得见襟捉肘了。我总不能对着光标方向创建一个透明长方体来检测碰撞吧。但这样就显得很繁琐了。这时候我们就可以引入一个全新的检测手法：也就是射线检测了。我们可以像超市自动开关门那样引出一个射线，如果射线指向了某些特定属性的物体就会发出信号。这也是射线检测的基本方法。</p>
<h2 id="射线是啥"><a href="#射线是啥" class="headerlink" title="射线是啥"></a>射线是啥</h2><p>在进入射线检测的正题前，我们先回顾一下小学的知识：射线是个啥？百度百科上写的是：具有特定能量的粒子束或光子束流。<del>看到这里你肯定十分疑惑，因为我也很疑惑，然后我发现我复制粘贴错了。</del>咳咳，射线实际上是：直线上的一点和它一旁的部分所组成的图形。它由一个起始点开始，向着一个方向放出无限长的线。当线与我们想要检测的物体重合就会发出信号。就实际例子上来说，我们在射击游戏中端着枪，枪口到远处就算是一个射线。虽然我很想把射线一次全部整完，但由于射线检测在2D和3D的区别还是蛮大的，所以还是分成两个部分一起说吧。</p>
<h2 id="3D世界中的射线检测"><a href="#3D世界中的射线检测" class="headerlink" title="3D世界中的射线检测"></a>3D世界中的射线检测</h2><h3 id="咋检测的捏？"><a href="#咋检测的捏？" class="headerlink" title="咋检测的捏？"></a>咋检测的捏？</h3><p>我们既然讲了射线检测的原理，那就直接上射线检测的代码8：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Physics.Raycast(Vector3 origin,Vector3 direction,out RaycastHit hitinfo,float distance,int LayerMask);</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//direction：射线的方向，因为是方向坐标所以使用Vector3表示</span><br><span class="line">//hitinfo：一个结构体，可以储存碰撞体的所有信息。你可以声明一个空的然后直接代入就可以</span><br><span class="line">//结构体里面很有价值，后面会说</span><br><span class="line">//下面俩参数是可选参数：</span><br><span class="line">//distance:射线检测的距离，虽然说射线的长度是无限长，但是可以设置它的检测距离，只有在这个距离内的物体才可以被检测到</span><br><span class="line">//LayerMask：图层，虽然物体都处在一个3D世界中，但都有着图层之分。如果输入图层的序号就可以只检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用</span><br></pre></td></tr></table></figure>

<h4 id="1-这个方法返回啥？"><a href="#1-这个方法返回啥？" class="headerlink" title="1.这个方法返回啥？"></a>1.这个方法返回啥？</h4><p>这个方法返回的是布尔类型的值，但是它害可以通过out返回一个RaycastHit结构体。</p>
<p>**out:**c#中特有的参数，可以不通过return返回变量。out后面的东西不需要赋值甚至实例化。</p>
<h4 id="2-origin和direction可不可以合二为一？"><a href="#2-origin和direction可不可以合二为一？" class="headerlink" title="2.origin和direction可不可以合二为一？"></a>2.origin和direction可不可以合二为一？</h4><p>其实Unity自身内置一个叫做Ray的类：</p>
<p><code>Ray ray=new ray(Vector3 origin,Vector3 direction)；</code>这样就可以直接把两个Vector变量直接合成一个射线的Ray变量，代码内容也可以改成：</p>
<p><code>Physics.Raycast(ray,out RaycastHit hitinfo,float distance,int LayerMask);</code></p>
<h4 id="3-这样射线检测我看不到，有什么办法显示射线吗？"><a href="#3-这样射线检测我看不到，有什么办法显示射线吗？" class="headerlink" title="3.这样射线检测我看不到，有什么办法显示射线吗？"></a>3.这样射线检测我看不到，有什么办法显示射线吗？</h4><p>如果想拿着这个代码去unity内部尝试的话，可以参考下面这个代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Debug.DrawLine(Vector3 origin,Vector3 destination,Color color);</span><br><span class="line">//功能是在Scene窗口显示一条可见的线段</span><br><span class="line">//origin:线段的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//destination：线段的终点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//color:你想在窗口上看到的线段的颜色</span><br><span class="line">Debug.DrawRay(Vector3 origin,Vector3 direction,Color color)</span><br><span class="line">//功能是在Scene窗口显示一条可见的射线</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector3表示</span><br><span class="line">//destination：射线的方向，因为是方向所以使用Vector3表示</span><br><span class="line">//color:你想在窗口上看到的射线的颜色</span><br></pre></td></tr></table></figure>

<p>当然，如果你是想显示特定的射线的样子，就可以改成：</p>
<p><code>Debug.DrawLine(ray.origin,ray.origin+ray.direction,Color.red);</code></p>
<p>但是你可能会发现Scene窗口看到的实在是太短了，原因是我们线段终点有点短，所以可以尝试在终点后面乘上个100甚至是1000</p>
<h4 id="4-RaycastHit感觉不如碰撞检测。。。功能"><a href="#4-RaycastHit感觉不如碰撞检测。。。功能" class="headerlink" title="4.RaycastHit感觉不如碰撞检测。。。功能"></a>4.RaycastHit感觉不如碰撞检测。。。功能</h4><p>RaycastHit很有用，结构体内除了位置坐标以外还有检测到物体的碰撞体。这意味着我们可以获取这个物体的相关组件了：</p>
<p><code>hit.collider.gameObject.GetComponent&lt;RigidBody&gt;();</code></p>
<p>或者<code>hit.collider.gameObject.name</code></p>
<p>是不是很好用。</p>
<h4 id="5-What’s-up-你这Raycast只能测一个啊？！"><a href="#5-What’s-up-你这Raycast只能测一个啊？！" class="headerlink" title="5.What’s up?你这Raycast只能测一个啊？！"></a>5.What’s up?你这Raycast只能测一个啊？！</h4><p>raycasthit只有一个返回值，那如果我想获得所有在射线上的物体怎么办？</p>
<p>答案是使用<code>RaycastAll</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RaycastHit[] hits;</span><br><span class="line">hits=Physics.RaycastAll(ray,maxDistance,mask);</span><br><span class="line">/*</span><br><span class="line">1.返回值是RaycastHit数组,所以记得加等号</span><br><span class="line">2.后面俩参数依然是最远距离和图层，前面写了</span><br><span class="line">3.后面可以使用foreach遍历数组里面的</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="6-你这LayerMask有问题啊？怎么是int？"><a href="#6-你这LayerMask有问题啊？怎么是int？" class="headerlink" title="6.你这LayerMask有问题啊？怎么是int？"></a>6.你这LayerMask有问题啊？怎么是int？</h4><p>LayerMask的形式是int，没错，不是字符而是int。它表示的是你涂层的序号的<strong>二次方倍</strong>，没错，<strong>二次方倍</strong>。这意味着你想检测的图层序号是第九层，但你在LayerMask这一变量里要输2的九次方，也就是512……</p>
<p>这个原因是Unity中以二维矩阵对LayerMask进行存储，所以要进行位运算。</p>
<p>我也针对这个写两个方法：</p>
<p>（1）public一个LayerMask然后在Inspector里面给它挂图层</p>
<p>（2）可以改写成<code>LayerMask.GetMask(&quot;这里写图层名字&quot;);</code></p>
<h4 id="6-5-你这LayerMask只能测一个图层？"><a href="#6-5-你这LayerMask只能测一个图层？" class="headerlink" title="6.5.你这LayerMask只能测一个图层？"></a>6.5.你这LayerMask只能测一个图层？</h4><p>如果你在<code>LayerMask.GetMask(&quot;&quot;);</code>前加~，这代表除了这个图层以外全部检测。这样射线检测就会绕过你指定的图层检测别的图层。</p>
<h4 id="7-（因为重中之重一定要写最后）"><a href="#7-（因为重中之重一定要写最后）" class="headerlink" title="7.（因为重中之重一定要写最后）"></a>7.（因为重中之重一定要写最后）</h4><p><strong>一定要加上collider组件！！！</strong></p>
<p>因为射线检测也是变相的射线和物体进行碰撞<del>（好吧这是我瞎编的）</del>，所以务必加collider组件！</p>
<p>你可以让射线检测没有trigger的，但是绝不能检测没有加collider组件的。</p>
<h3 id="咋应用的捏？"><a href="#咋应用的捏？" class="headerlink" title="咋应用的捏？"></a>咋应用的捏？</h3><p>按照上面的说法，我们根本无法实现拿鼠标点击物体看属性的功能。因为射线只能给一个物体，鼠标怎么整呢？</p>
<p>我们直接整一个复杂的情景：</p>
<p>假如你是李华，你在某模拟经营类游戏（类似冰汽时代）要在某个崎岖不平的地上造建筑，需要在光标上预览建筑造好后怎么样。所以你光标在哪里建筑要跟到哪里，同时遇到山你的建筑要有些倾斜。</p>
<p>接下来我们就来解决这个问题（以下脚本要挂载到你要放的物体上）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void FixedUpdate()&#123;</span><br><span class="line">    Ray ray=Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">    /*把鼠标在屏幕坐标上面的位置通过ScreenPointToRay方法转化为Ray射线类型（世界坐标系），因为屏幕坐标并不是世界系的坐标。这样射线从相机为起点向鼠标所在的方向延伸*/</span><br><span class="line">    if(Physics.Raycast(ray,out RaycastHit hitInfo,Mathf.Infinity))&#123;</span><br><span class="line">        //这里直接把检测距离改成无限</span><br><span class="line">        transform.position=hitInfo.point;</span><br><span class="line">       //这样物体会一直跟着射线交界点，也就是我们的鼠标</span><br><span class="line">        transform.rotation=Quaternion.FromToRotation(Vector3.up,hitInfo.normal);</span><br><span class="line">        //让物体的旋转角度迎合地面的角度</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这么做可能会有一个严重的问题：你的建筑会一直朝镜头飞。</p>
<p><img src="%E9%A3%9E.gif" alt="飞" loading="lazy"></p>
<p>原因很简单：你检测的是第一个碰撞体。而如果你的建筑有碰撞体，检测到的碰撞体不是地面而是你的建筑。这样point就一直是你的前面，就会一直朝建筑飞。</p>
<p>解决的方法有两种：</p>
<p>1.把建筑的碰撞体关了，然后建好了碰撞体开开</p>
<p>2.调整图层，把地面放到单独的图层里</p>
<p>这么做还有个不太严重的问题：建筑一半会陷进地面里。</p>
<p><img src="%E8%B5%B0.gif" alt="走" loading="lazy"></p>
<p>因为你的建筑位置坐标是你建筑的中心坐标，也就是point坐标。</p>
<p>解决方法也很简单，在上面做个空物体，把该物体上移建筑的半格，把它作为空物体的子物体，就可以了。这样它的坐标变成了空物体的中心坐标，也就是建筑的底部。</p>
<p>后面确认建造可以写：</p>
<p><code>Instantiate(prefab,transform.position,transform.rotation);</code></p>
<p>其实射线检测在3D世界上还有很多应用：</p>
<p>1.就Unity官方给出的例子来看，可以确定空投物资的降落伞什么时候打开：通过在物资下做一条有距离限制的射线检测，一检测到地面就开降落伞。</p>
<p>。。。<del>（你省略害搁着打个1.干嘛）</del></p>
<p>3D好像也没啥讲的了，就这么多把</p>
<h2 id="2D世界中的射线检测"><a href="#2D世界中的射线检测" class="headerlink" title="2D世界中的射线检测"></a>2D世界中的射线检测</h2><h3 id="咋检测的捏？-1"><a href="#咋检测的捏？-1" class="headerlink" title="咋检测的捏？"></a>咋检测的捏？</h3><p>2D和3D的代码是类似的，2D代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Physics2D.Raycast(Vector2 origin,Vector2 direction,float distance,int LayerMask,float minDepth,float maxDepth);</span><br><span class="line">//origin:射线的起始点，因为是位置坐标所以使用Vector2表示</span><br><span class="line">//direction：射线的方向，因为是方向坐标所以使用Vector2表示</span><br><span class="line">//distance:射线检测的距离，虽然说射线的长度是无限长，但是可以设置它的检测距离，只有在这个距离内的物体才可以被检测到</span><br><span class="line">//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用</span><br><span class="line">//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷</span><br></pre></td></tr></table></figure>

<p>看似只是在Physics后面加了2D，但实际上2D和3D是有很多区别的<del>（不然也不会特地做一个部分了）</del>。</p>
<h4 id="0-Z轴，寄！"><a href="#0-Z轴，寄！" class="headerlink" title="0.Z轴，寄！"></a>0.Z轴，寄！</h4><p>首先最明显的就是z轴没有用了：<code>transform.forward</code>指向z轴方向，所以在2D的场景里只会指向屏幕内，根本就没有了作用。</p>
<h4 id="1-Ray，寄！"><a href="#1-Ray，寄！" class="headerlink" title="1.Ray，寄！"></a>1.Ray，寄！</h4><p>上文提到过，Ray这个类是由两个Vector3变量构造而成的，而2D世界都是Vector2，自然Ray这个类就与2D无缘了，只能用俩Vector2变量表示了。</p>
<h4 id="2-返回类型（作为方法最明显的不同了属于是）"><a href="#2-返回类型（作为方法最明显的不同了属于是）" class="headerlink" title="2.返回类型（作为方法最明显的不同了属于是）"></a>2.返回类型（作为方法最明显的不同了属于是）</h4><p>不像3D的返回类型是一个布尔类型的变量，2D返回的是RaycastHit2D的结构体类型。这个结构体类型和3D的结构体类型相似，也是储存着射线的相关信息以及检测到的碰撞体信息。比如说<code>point</code>就储存射线和碰撞体交汇的坐标，很是方便。</p>
<h4 id="3-小tips"><a href="#3-小tips" class="headerlink" title="3.小tips"></a>3.小tips</h4><p>在现实的游戏中，发出射线检测的物体基本都是具有碰撞体的（比如怪物或者炮台什么的）。这就引发了一个问题：当从物体中心点发出时，检测到的第一个碰撞体却是自己，射线根本出不去。那我们该怎么解决这个问题呢？答案是<code>Physics2D.queriesStartInColliders=false;</code>queries:询问，start:开始，incolliders:在碰撞体内。这样如果碰撞体是我们射线所在起点的内部时，我们不让它返回该碰撞体。这样就可以完美解决问题了。</p>
<h4 id="4-还有两种重载。。。"><a href="#4-还有两种重载。。。" class="headerlink" title="4.还有两种重载。。。"></a>4.还有两种重载。。。</h4><p>但用的少而且比较复杂，就不在这里延申了。</p>
<h4 id="5-（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）"><a href="#5-（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）" class="headerlink" title="5.（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）"></a>5.（因为重中之重一定要写最后，虽然前面已经有了但是还是要粘贴一波）</h4><p><strong>一定要加上collider组件！！！</strong></p>
<p>因为射线检测也是变相的射线和物体进行碰撞<del>（好吧这是我瞎编的）</del>，所以务必加collider组件！</p>
<p>你可以让射线检测没有trigger的，但是绝不能检测没有加collider组件的。</p>
<p><strong>其它的就没了</strong></p>
<h3 id="咋应用的捏？-1"><a href="#咋应用的捏？-1" class="headerlink" title="咋应用的捏？"></a>咋应用的捏？</h3><p>还是整一个复杂的例子：</p>
<p>你想在TopDown游戏（比如元气骑士）中做一个激光束，激光束打到墙面会被墙面阻隔，打到人身上会掉血（为了方便直接写了GameOver）。而我们要从游戏视觉到内部判定上把这个功能实现出来。</p>
<h4 id="内部判定"><a href="#内部判定" class="headerlink" title="内部判定"></a>内部判定</h4><p>内部判定很简单，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void Detect()</span><br><span class="line">&#123;</span><br><span class="line">    //进行射线检测并将结果进行储存</span><br><span class="line">    RaycastHit2D hitInfo=Physics2D.Raycast(transform.position,-transform.right,maxDist,max);</span><br><span class="line">    //如果射线检测检测到了东西（因为检测到了东西有碰撞体就不会是null了）</span><br><span class="line">    if(hitInfo.collider!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Player&quot;)</span><br><span class="line">            //如果检测到的是player（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            GameOver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视觉实现（LineRenderer组件）"><a href="#视觉实现（LineRenderer组件）" class="headerlink" title="视觉实现（LineRenderer组件）"></a>视觉实现（LineRenderer组件）</h4><p>检测方面还是好写的。但如果我们要在实际的游戏画面中也要把这条射线给显示出来，使用DrawLine和DrawRay方法是无法胜任的。因为它们只能在Scene窗口内看到一条辅助线，而不是Game窗口里。</p>
<p>针对这个方法，我们可以使用Unity自带的LineRenderer来实现：</p>
<p><img src="Line.png" alt="LineRenderer位置在这里" loading="lazy"></p>
<p>LineRenderer是用于在游戏场景内对一条线段进行渲染。它的主要参数有很多，我们只讲几个重要的：</p>
<p><img src="LineRenderer.png" alt="内部格式" loading="lazy"></p>
<h5 id="（1）Position"><a href="#（1）Position" class="headerlink" title="（1）Position"></a>（1）Position</h5><p>众所周知，两点确定一条线段，而Position里面的两个index就是两个点的位置。index1是线段的起点，而index2则是线段的终点。</p>
<p>这里有个<code>SetPosition</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LineRenderer.SetPosition(int index,Vector3 position);</span><br><span class="line">//功能是设置LineRenderer的起始点和终点。index为Position里的序列号（如果是1就代表是index1），position为终点。</span><br></pre></td></tr></table></figure>

<h5 id="（2）-Width"><a href="#（2）-Width" class="headerlink" title="（2） Width"></a>（2） Width</h5><p>对线段的宽度进行设置。因为Width是一条线，所以你可以控制线段上的每一个点的粗细<del>（什么金箍棒）</del></p>
<h5 id="（3）Color"><a href="#（3）Color" class="headerlink" title="（3）Color"></a>（3）Color</h5><p>对线段的颜色进行设置。但因为是线段，所以你可以设置一个渐变的颜色，甚至是某些位置的透明度<del>（哇哦，好几把炫酷）</del></p>
<p>而这个颜色的类名也不能是<code>Color</code>了，而是<code>Gradient</code>（渐变色）</p>
<h5 id="（4）End-CapVertices"><a href="#（4）End-CapVertices" class="headerlink" title="（4）End CapVertices"></a>（4）End CapVertices</h5><p>对线段末端的圆滑度进行设置。如果这个数值是0，那线段末端就是一个正方。如果这个数值越大，末端也会更加圆滑，最后趋近于一个半圆。</p>
<h5 id="5-Use-World-Space"><a href="#5-Use-World-Space" class="headerlink" title="(5)Use World Space"></a>(5)Use World Space</h5><p>将Position里的坐标转化为世界坐标。不勾选这个的话我们就无法正确的让线段显示出来。</p>
<p>有了这个，视觉方面就好做了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private LineRenderer lineRenderer;</span><br><span class="line">//声明LineRenderer组件的变量</span><br><span class="line"></span><br><span class="line">private void Awake()&#123;</span><br><span class="line">    lineRenderer=GetComponent&lt;LineRenderer&gt;();</span><br><span class="line">    //如果LineRenderer组件物体是脚本挂载的子物体，那我们可以直接使用GetComponentInChildren方法。但是这个方法只会获取第一个发现的组件而不是所有子物体的组件。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Detect()</span><br><span class="line">&#123;</span><br><span class="line">    //进行射线检测并将结果进行储存</span><br><span class="line">    RaycastHit2D hitInfo=Physics2D.Raycast(transform.position,-transform.right,maxDist,max);</span><br><span class="line">    //如果射线检测检测到了东西（因为检测到了东西有碰撞体就不会是null了）</span><br><span class="line">    if(hitInfo.collider!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Wall&quot;)</span><br><span class="line">            //如果检测到的是Wall（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            lineRenderer.SetPosition(1,hitInfo.point);</span><br><span class="line">        &#125;</span><br><span class="line">        if(hitInfo.collider.gameObject.tag==&quot;Player&quot;)</span><br><span class="line">            //如果检测到的是player（指标签）</span><br><span class="line">        &#123;</span><br><span class="line">            lineRenderer.SetPosition(1,hitInfo.point);</span><br><span class="line">            GameOver();</span><br><span class="line">        &#125;</span><br><span class="line">        lineRenderer.SetPosition(0,transform.position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就差不多了。</p>
<h2 id="射线检测的一些缺点"><a href="#射线检测的一些缺点" class="headerlink" title="射线检测的一些缺点"></a>射线检测的一些缺点</h2><h3 id="射线检测，寄！"><a href="#射线检测，寄！" class="headerlink" title="射线检测，寄！"></a>射线检测，寄！</h3><p>在讲了这么多射线检测后，我还是想要明确一下射线检测的缺陷：在检测的范围不是一根线段而是一个面积的图形时，射线检测就显得有些见襟捉肘。比如说：我想在平台跳跃游戏中使用射线检测检测玩家是否与地面相碰。因为如果我们不这么做玩家就可以无限按跳跃键达到飞天的效果(bushi。在这里使用射线检测就会造成一些问题：</p>
<p><img src="%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.png" alt="发生肾么事了" loading="lazy"></p>
<p>如图，玩家依旧在地板上，但是由于中间超过一半部位已经离开了地板，导致在玩家中心点往下的射线检测并没有检测到地板。这样的结果就是玩家在这个地方本来可以跳却跳不起来。我们想要检测一定范围内的碰撞体，而射线检测却无法达到这个效果。</p>
<p>难道，就没有办法了吗？</p>
<h3 id="OverLap的妙用"><a href="#OverLap的妙用" class="headerlink" title="OverLap的妙用"></a>OverLap的妙用</h3><p>面对这个问题，Unity自然有解决方法：那就是OverLap方法。它的功能和射线检测大致类似，但是它并不是产生一条射线，而是产生一个形状，比如圆形(<code>OverLapCircle</code>)，方形(<code>OverLapBox</code>)等。这些方法的区别仅仅是形状不一样，而其他都是大致相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collider2D collider=Physics2D.OverLapCircle(Vector2 point, float radius, int layerMask, float minDepth, float maxDepth);//point:圆心的点所在坐标，因为是位置坐标所以使用Vector2表示//radius：圆的半径//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷Collider2D OverlapBox=Physics2D.OverLapBox(Vector2 point, Vector2 size, float angle, int layerMask, float minDepth, float maxDepth);//point:长方体中心点所在坐标，因为是位置坐标所以使用Vector2表示//size：长方体的长和宽，因为要有长和宽两个数所以使用Vector2表示//angle:长方体要倾斜的角度//LayerMask：图层，虽然物体都处在一个2D世界中，但都有着图层之分。如果输入图层的序号就可以“只”检测这个图层的相应物体，而其它图层的物体即使被射线扫到了也没有任何卵用//minDepth,maxDepth:检测确定Z轴的范围内的物体。但是由于都是使用Sorting Layers来调整物体而不是Z轴坐标，所以不是很常用。只要知道就行，默认是无穷</span><br></pre></td></tr></table></figure>

<p>方法和射线检测类似，但是又有些许的不同，比如：</p>
<h4 id="1-返回值不一样"><a href="#1-返回值不一样" class="headerlink" title="1.返回值不一样"></a>1.返回值不一样</h4><p>OverLap的返回值是collider2D，也就是碰撞体，不像射线检测是返回hitInfo那种结构体了。</p>
<h4 id="2-适用范围不一样"><a href="#2-适用范围不一样" class="headerlink" title="2.适用范围不一样"></a>2.适用范围不一样</h4><p>看到Physics2D也知道，OverLap只适用于2D世界，而不是2D、3D全适用了。</p>
<p>通过这个方法，我们可以在玩家碰撞体的正下面做一个OverLap检测，这样就可以完美解决跳跃检测的问题了。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="如何像DrawLine那样显示出整个检测范围？"><a href="#如何像DrawLine那样显示出整个检测范围？" class="headerlink" title="如何像DrawLine那样显示出整个检测范围？"></a>如何像DrawLine那样显示出整个检测范围？</h4><p>答案是使用gizmos:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private void OnDrawGizmos()&#123;    Gizmos.DrawWireSphere(transform.position,radius);    Gizmos.Color=Color.Red;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么平台跳跃中贴着墙掉不下去？"><a href="#为什么平台跳跃中贴着墙掉不下去？" class="headerlink" title="为什么平台跳跃中贴着墙掉不下去？"></a>为什么平台跳跃中贴着墙掉不下去？</h4><p>答案是所有碰撞体和刚体的材质都默认有摩擦力，只要你新建一个物理材质然后把摩擦力调整为0然后挂载到墙壁的刚体上就不会这样了。</p>
<h4 id="如何检测该形状范围内的所有碰撞体？"><a href="#如何检测该形状范围内的所有碰撞体？" class="headerlink" title="如何检测该形状范围内的所有碰撞体？"></a>如何检测该形状范围内的所有碰撞体？</h4><p>答案是OverLap***All方法，这个方法和之前射线检测的一样，可以返回所有碰撞体.</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>射线检测在Unity游戏制作中还是十分重要的。但和碰撞检测不同，射线检测在2D和3D的世界使用方面上还是有着不同的。并且，由于射线检测仅仅是一条射线的范围，在某些游戏某些功能的实现上还是有着局限性。为此OverLap这种可以检测一定范围的方法可以更加胜任这些工作。在文中2D中射线检测以及OverLap的介绍并没有3D中的那么详细，这是因为避免文章的重复性。基本上3D部分提到但是2D和OverLap没有提到的功能和注意在2D和OverLap上也是适用的。比如这些检测方法都需要碰撞体，都可以采用在后面加All的方法检测范围内的所有碰撞体的物体，LayerMask是int等等，还望大家谅解。</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Karmotrine.</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/" title="简析Unity射线检测的概念与应用">http://example.com/2021/09/08/%E7%AE%80%E6%9E%90Unity%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/06/26/Unity%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E5%AD%98%E6%A1%A3%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3/" rel="next" title="Unity中如何设置游戏存档方法归纳"><span class="post-nav-text">Unity中如何设置游戏存档方法归纳</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Karmotrine</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.0.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.7.0</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2022-01-07T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="7226373375" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listfolded data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>